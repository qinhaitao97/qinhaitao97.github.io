<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSS3动效]]></title>
    <url>%2F2018%2F08%2F13%2FCSS3%E5%8A%A8%E6%95%88%2F</url>
    <content type="text"><![CDATA[transform可以实现元素的形状、角度、位置等的变换 rotate()以x轴，y轴，z轴或者某个合成的矢量轴为旋转轴进行指定角度的旋转，默认情况下是以z轴为旋转轴 rotate(deg) 这是默认情况，以z轴为旋转轴进行旋转。deg是旋转的角度，当角度值为正时，正视图顺时针旋转 rotateX(deg) 以x轴为旋转轴进行旋转。deg是旋转的角度，当角度值为正时，右视图顺时针旋转 rotateY(deg) 以y轴为旋转轴进行旋转。deg是旋转的角度，当角度值为正时，仰视图顺时针旋转 rotateZ(deg) 以z轴为旋转轴进行旋转。deg是旋转的角度，当角度值为正时，正视图顺时针旋转 rotate3d(x, y, z, deg) 以x，y，z三个轴方向上的矢量合成的矢量为旋转轴进行旋转。x，y，z均为number类型，可以是0到1之间的数值，表示x、y、z方向上的矢量；deg代表旋转的角度 这里数值的大小代表什么呢？不同的数值会导致什么不同？ 参考：https://blog.csdn.net/u010552788/article/details/51505152 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #demo &#123; width: 100px; height: 100px; margin: 100px; background-color: red; transform: rotate3d(1, 1, 0, 45deg); &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="demo"&gt;a&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 注意 当元素进行旋转的同时，非旋转轴也会跟着元素一同进行旋转。比如 rotateX(90deg);，旋转结束后，旋转轴x方向不变水平向右，非旋转轴y轴和z轴分别垂直屏幕向外和竖直向上 transform: rotateX(45deg) rotateY(45deg) rotateZ(45deg); 和 transform: rotate3d(1, 1, 1, 45deg); 的效果是不一样的：前者是有先后顺序，先沿x轴旋转，再沿y轴旋转，再沿z轴旋转；后者直接沿合成的轴进行旋转 前者 后者 scale()以x轴，y轴，z轴为轴进行指定比例的缩放 scale(x, y) x，y分别是在各自方向上，以该方向上元素尺寸大小为基准，放大或者缩小的倍数；如果第二值没有给出，则第二个值取第一个值 0 (0, 1) 1 >1 绝对值 尺寸变成0 缩小 尺寸不变 放大 >0 &lt;0 值 直接按照比例缩放 先以轴为镜面做镜像对称，再按照比例缩放 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #wrapper &#123; width: 100px; height: 100px; background-color: #ccc; margin: 100px; &#125; #demo &#123; width: 100px; height: 100px; background-color: rgba(255, 0, 0, 0.5); font-size: 30px; /* transform: scale(0); */ /* transform: scale(1, 1); */ /* transform: scale(2, 1); */ /* transform: scale(1, 0.5); */ /* transform: scale(1, -2); */ /* transform: scale(-0.5, 1); */ /* transform: scale(-2, -2); */ &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="wrapper"&gt; &lt;div id="demo"&gt;a&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 依次打开注释观察效果，#wrapper是模拟元素原始效果，与变化之后的效果作比较 scaleX(m)、scaleY(m)、scaleZ(m) 分别以x、y、z轴为轴，进行缩放，括号中的值m表示倍数 scale3d(mx, my, mz) 在各自的方向上以各自的轴为轴，进行x、y、z倍数的缩放，等效于transform: scaleX(m) scaleY(m) scaleZ(m); skew()对元素进行倾斜扭曲 skew() 接受两个参数x，y，表示在y方向上以及x方向上倾斜的角度，角度为正向右倾斜，为负向左倾斜，为0不倾斜；如果不提供第二个参数，默认是0 skewX() 元素在x方向上的大小不变，y方向上进行倾斜 skewY() 元素在y方向上的大小不变，x方向上进行倾斜 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #wrapper &#123; width: 100px; height: 100px; background-color: #ccc; margin: 100px; &#125; #demo &#123; width: 100px; height: 100px; background-color: rgba(255, 0, 0, 0.5); font-size: 30px; transform: skew(20deg, 20deg); &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="wrapper"&gt; &lt;div id="demo"&gt;a&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; &lt;/html&gt; translate()平移产生位置变化，相对于自身的位置 translate(x, y) 接受两个参数x、y，分别代表沿x轴平移的x的距离、沿y轴移动y的距离，单位可以是px或者%（注意，如果是%，是相对于自身的大小）；如果不提供第二个参数，则默认为0 translateX(s)、translateY(s)、translateZ(s) 沿x轴、y轴、z轴平移指定的距离 translate3d(sx, sy, sz) 沿x轴、y轴、z轴平移指定的距离，等效于transform: translateX(s) translateY(s) translateZ(s); 利用这个属性的功能，可以实现元素的居中 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #wrapper &#123; position: relative; width: 200px; height: 200px; background-color: #ccc; &#125; #demo &#123; position: absolute; top: 50%; left: 50%; width: 40%; height: 40%; background-color: red; transform: translate(-50%, -50%); &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="wrapper"&gt; &lt;div id="demo"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 这里因为不知道#demo具体的宽高，所以不能用margin来调整位置，而translate是相对于元素自身的大小，利用%可以实现调整 transform-origin定义 任何元素都有一个中心点，默认情况下，其中心店居于x轴和y轴的50%处，可以通过transform-origin属性改变其原点；transform-origin有两个属性值，分别表示原点在x轴方向上的位置与原点在y轴方向的位置，这些属性值可以是以下几种形式： 关键字 百分比% 这个百分比的值是相对于元素自身的大小 像素值px 可以通过像素将元素的中心店设置在任意的位置 语法 现在主流的浏览器不仅支持 transition-origin 的2D属性，还支持他的3D属性，用来改变中心点在Z轴上的位置 transform-origin: x-axis y-axis z-axis; 值 取值 x-axis 关键字，length，% y-axis 关键字，length，% z-axis length 练习：画一个简易的钟表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; .clock &#123; width: 200px; height: 200px; border: 1px solid #000; border-radius: 50%; margin: 100px auto; &#125; .clock ul &#123; position: relative; width: 100%; height: 100%; font-size: 0px; &#125; .clock ul li &#123; position: absolute; top: 0px; left: 50%; width: 2px; height: 15px; background-color: #000; transform: translateX(-50%); transform-origin: 50% 100px; &#125; .clock ul li:nth-child(2) &#123; transform: rotateZ(90deg); &#125; .clock ul li:nth-child(3) &#123; transform: rotateZ(180deg); &#125; .clock ul li:nth-child(4) &#123; transform: rotateZ(270deg); &#125; .clock ul li span &#123; position: absolute; top: 14px; left: -9px; width: 20px; height: 20px; font-size: 16px; text-align: center; line-height: 20px; &#125; .clock ul li:nth-child(2) span &#123; transform: rotateZ(-90deg); &#125; .clock ul li:nth-child(3) span &#123; transform: rotateZ(-180deg); &#125; .clock ul li:nth-child(4) span &#123; transform: rotateZ(-270deg); &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class="clock"&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;12&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;3&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;6&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;9&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 当刻度旋转到指定位置时，数字也会跟着旋转，这时我们看到的效果是这样的 所以我们要把数字自身旋转到正面的位置，在数字外面包裹一层span，对span进行旋转 transition过渡动画，是CSS3的一个复合属性，只对block级元素生效，主要包括以下几个子属性 触发条件 单纯的代码不会触发任何过渡操作，需要通过用户的行为（如点击，悬浮等）触发，可以触发的方式有：:hover、:checked、:focus、媒体查询、JavaScript transition是实现元素从一种状态变到另一种状态时过渡动画的效果，所以很明显，要想让transition生效，就要产生元素状态的变化，比如说一个方块初始状态下宽高100px，当鼠标hover时，宽高变成了200px，这个过程就是方块状态改变的过程，正常情况下它的宽高瞬间就变成了200px，我们不想让这个过程变的太快，想让它慢慢的过渡到最终的状态，这就要使用transition来实现过渡效果 transition-property过渡或者模拟的css属性 语法：transition-property: all|none|property; 值 描述 none 没有属性会获得过渡效果。 all 所有属性都将获得过渡效果。 property 定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔。 不是所有的属性都可以参与过渡动画，需要属性具有中间状态，所有可以参与过渡属性动画的属性：点击这里 transition-duration值过渡所需要的时间，单位可以是s或者ms，如果时间为0，则过渡效果不能实现 transition-timing-function指过渡函数，规定过渡效果的速率曲线 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease（默认值） 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。 ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。 ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 可以用最后一个贝塞尔函数的不同取值来代替上述的的所有速率曲线 transition-delay指开始出现的延迟时间 demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; .demo1, .demo2, .demo3 &#123; display: inline-block; &#125; .hover &#123; width: 60px; height: 30px; background-color: #ccc; text-align: center; line-height: 30px; cursor: pointer; &#125; .item &#123; position: absolute; left: 0px; width: 100px; height: 100px; background-color: #f40; text-align: center; line-height: 100px; &#125; .demo1 .item1 &#123; top: 100px; transition: all 1500ms linear; &#125; .demo2 .item2 &#123; top: 210px; transition: left 1000ms, top 1000ms; &#125; .demo3 .item3 &#123; top: 320px; opacity: 1; transition: top 1000ms ease-in, background-color 1000ms linear, left 1500ms ease-out 1000ms, opacity 1500ms linear 1000ms; &#125; .demo1 .hover1:hover + .item1 &#123; width: 300px; height: 200px; &#125; .demo2 .hover2:hover + .item2 &#123; left: 300px; top: 0px; &#125; .demo3 .hover3:hover + .item3 &#123; left: 200px; top: 400px; background-color: green; opacity: 0.1; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class="demo1"&gt; &lt;div class="hover hover1"&gt;hover1&lt;/div&gt; &lt;div class="item item1"&gt;item1&lt;/div&gt; &lt;/div&gt; &lt;div class="demo2"&gt; &lt;div class="hover hover2"&gt;hover2&lt;/div&gt; &lt;div class="item item2"&gt;item2&lt;/div&gt; &lt;/div&gt; &lt;div class="demo3"&gt; &lt;div class="hover hover3"&gt;hover3&lt;/div&gt; &lt;div class="item item3"&gt;item3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 以上demo把transition的属性合起来写了，也可以分开来写 局限性 transition过渡动画不能再网页加载时自动触发，需要事件触发 transition过渡动画是一次性的，不能重复播放，除非一再触发 transition过渡动画只能定义元素开始和结尾的两种状态，不能定义中间过程的状态 使用位置一个元素从初始状态过渡到最终状态要使用transition属性，那这个transition是设置在初始状态中还是最终状态中呢？这个要根据具体情况而定，推荐设置在最终状态中，这样在状态较多时不容易混乱 比如：还是以方块的宽高变换为例，现有一宽高100px的方块和三个按钮，点击0.5s 按钮，宽度0.5s变成200px；点击1.0s 按钮，高度1s变成300px；点击origin 按钮，2s回到初始状态 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .demo &#123; position: absolute; top: 100px; left: 200px; width: 100px; height: 100px; background-color: orange; transition: all 2s linear; &#125; .half-second &#123; width: 200px; transition: width 0.5s linear; &#125; .one-second &#123; width: 300px; transition: width 1s linear; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;button class="half"&gt;0.5s&lt;/button&gt; &lt;button class="one"&gt;1.0s&lt;/button&gt; &lt;button class="origin"&gt;origin&lt;/button&gt; &lt;script&gt; $('.half').on('click', function () &#123; $('.demo').addClass('half-second'); &#125;); $('.one').on('click', function () &#123; $('.demo').addClass('one-second'); &#125;); $('.origin').on('click', function () &#123; $('.demo').prop('class', 'demo'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结合代码来讲，.demo 算是方块的初始状态，最终状态有两个 .half-second 和 .one-second，从初始状态到这两个状态的过渡动画是不同的（时间不同），如果把 transition 设置在 .demo 中就无法实现两个状态各自的变换，所以这里把他们的 transition 设置在了最终状态的元素中，不过你一定看到了 .demo 中的 transition 属性，这个属性并不是实现width变大的过渡效果，而是实现从最终状态变回初始状态的过渡效果，这时的两个最终状态就变成了初始状态，而原来的初始状态就成了这次变换中的最终状态，所以这个过程的 transition 属性设置在 .demo 中 animationanimation通过动画关键帧来实现过渡动画的效果，是一个复合属性，主要包括下面将要介绍的几个子属性 关键帧说明 animation用来实现过渡动画的效果的，transition也是实现过渡动画效果的，那两者有什么区别呢？从定义可以 看的出来，animation是通过关键帧来实现过渡动画效果的，一个关键帧代表了整个动画过程中的一个状态（以视频中的每一帧类比），通过定义关键帧的样式来控制CSS动画序列的中间步骤，与transition相比能更好的控制中间状态的动画 创建关键帧 要使用关键帧, 先创建一个带名称的@keyframes规则，以便后续使用 animation-name 这个属性来将一个动画同其关键帧声明匹配。每个@keyframes 规则包含多个关键帧，也就是一段样式块语句，每个关键帧有一个百分比值作为名称，代表在动画进行中，在哪个阶段触发这个帧所包含的样式。 关键帧百分比列出的顺序不影响它被执行的顺序，他们会按照该发生的顺序来处理 让关键帧生效 如果一个关键帧规则没有指定动画的开始或结束状态（也就是，0%/from 和100%/to，浏览器将使用元素的现有样式作为起始/结束状态。这可以用来从初始状态开始元素动画，最终返回初始状态。 如果在关键帧的样式中使用了不能用作动画的属性，那么这些属性会被忽略掉，支持动画的属性仍然是有效的，不受波及。 除了百分比以外，还可以用关键词来表示某个状态(某个关键帧)：0% ==&gt; from 100% ==&gt; to 重复定义 下面说的不支持层叠样式是Firefox 14版本之前，现在主流的浏览器基本已经支持百分比的层叠样式了，但是对于多个重名关键帧的层叠样式，还没有较好的支持（即如果关键帧使用同一个名称，则以最后一个定义为准；如果百分比重复定义，则按照层叠规则进行判断） 如果多个关键帧使用同一个名称，以最后一次的定义为准。@keyframes不存在层叠样式的情况，所以动画在一个阶段只会使用一个关键帧的数据。 如果一个@keyframes里的关键帧的百分比存在重复的情况，以最后一次定义的关键帧为准。因为@keyframes的规则不存在层叠样式的情况，即使多个关键帧设置相同的百分值也不会全部执行（执行最后一个） 属性个数不定 如果一个关键帧中没有出现其他关键帧中的属性，那么这个属性将使用插值(不能使用插值的属性除外，这些属性会被忽略掉) 这里要注意，如果没有定义 初始/结束 状态，浏览器使用元素的现有样式作为 初始/结束状态；或者 初始/结束 状态中有些属性没有设置，那么这些属性的值也是元素现有样式的值 demo 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #demo &#123; width: 100px; height: 100px; background-color: #f40; animation: demo 1s linear; &#125; @keyframes demo &#123; 50% &#123; width: 300px; &#125; &#125; @keyframes demo &#123; 0% &#123; width: 100px; &#125; 50% &#123; width: 500px; height: 200px; &#125; 50% &#123; width: 300px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 关于demo的说明： 在此样例中创建了两个同名的关键帧，以最后一个定义的关键帧为准，所以第一个关键帧不起作用 在第二个关键帧中，一共涉及了两个属性，width和height，对于height属性来说，没有定义 初始/结束 状态，所以height属性的 初始/结束 状态即为元素初始的样式（100px）；对于width来说，定义了初始状态（与元素现有的样式相同），没有定义结束状态，则结束状态为100px； 50%被重复定义，所以按照层叠样式，在50%这个时间点，元素的状态应该是width：300px；height：200px（相当于把两个50%中的定义都写在一个里面，然后判断最终的属性） 整个过程的变化就是 0% — 50% 50% — 100% width 100px -&gt; 300px 300px -&gt; 100px height 100px -&gt; 200px 200px -&gt; 100px 还有一点需要注意的就是，一个关键帧内的多个状态之间的不要用 ; 进行分隔，有可能会造成关键帧失效 animation-name定义 指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列 语法 1234567891011121314/* Single animation */animation-name: none;animation-name: test_05;animation-name: -specific;animation-name: sliding-vertically; /* Multiple animations */animation-name: test1, animation4;animation-name: none, -moz-specific, sliding; /* Global values */animation-name: initial /* 设置属性为其默认值 */animation-name: inherit /* 从父元素继承属性 */animation-name: unset demo 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #demo &#123; width: 100px; height: 100px; background-color: #f40; /* 写法一： */ animation-name: demo1, demo2; animation-duration: 1s, 1s; /* 写法二： */ /* animation: demo1 1s, demo2 1s; */ &#125; @keyframes demo1 &#123; 100% &#123; width: 200px; &#125; &#125; @keyframes demo2 &#123; 100% &#123; height: 200px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注意 写法一与写法二是等效的 animation-duration定义 指定一个动画周期的时长 语法 1234animation-duration: 6sanimation-duration: 120msanimation-duration: 1s, 15sanimation-duration: 10s, 30s, 230ms animation-timing-function定义 定义css动画在每一动画周期中执行的节奏。可能值为一个或多个 对于关键帧动画来说，timing function作用于一个关键帧周期而非整个动画周期，即从关键帧开始开始，到关键帧结束结束 定义一个关键帧区块的缓动函数应用到该关键帧；另外，若该关键帧没有定义缓动函数，则使用定义于整个动画的缓动函数 语法 123456789101112131415161718192021/* Keyword values */animation-timing-function: ease;animation-timing-function: ease-in;animation-timing-function: ease-out;animation-timing-function: ease-in-out;animation-timing-function: linear;animation-timing-function: step-start;animation-timing-function: step-end; /* Function values */animation-timing-function: cubic-bezier(0.1, 0.7, 1.0, 0.1);animation-timing-function: steps(4, end);animation-timing-function: frames(10); /* Multiple animations */animation-timing-function: ease, step-start, cubic-bezier(0.1, 0.7, 1.0, 0.1); /* Global values */animation-timing-function: inherit;animation-timing-function: initial;animation-timing-function: unset; 值 描述 linear 动画从开始到结束具有相同的速度。 ease 动画有一个缓慢的开始，然后快，结束慢。 ease-in 动画有一个缓慢的开始。 ease-out 动画结束缓慢。 ease-in-out 动画具有缓慢的开始和慢的结束。 cubic-bezier(n,n,n,n) 在立方贝塞尔函数中定义速度函数。 可能的值是从0到1的数字值。 这里关于animation-timing-function值的其他几种类型如step-start、step-end、steps(n, start/end)等后面再讲 animation-delay定义 CSS属性定义动画开始于何时，即从动画应用在元素上到动画开始的这段时间 说明 0s是该属性的默认值，代表动画在应用到元素上后立即开始执行。否则，该属性的值代表动画样式应用到元素上后到开始执行前的时间长度； 定义一个正值m会让动画经过ns的延迟后，再开始运动 定义一个负值n会让动画立即开始，开始的位置是元素运动的ns后的位置。例如，如果设定值为1s，动画会从它动画序列的第1s位置处立即开始。 demo 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @keyframes demo &#123; to &#123; left: 500px; &#125; &#125; #demo1, #demo2, #demo3 &#123; position: absolute; left: 0px; width: 100px; height: 100px; background-color: red; &#125; #demo1 &#123; top: 0px; animation: demo 2s linear 0s; &#125; #demo2 &#123; top: 120px; animation: demo 2s linear 1s; &#125; #demo3 &#123; top: 240px; animation: demo 2s linear -1s; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo1"&gt;animation-delay: 0s&lt;/div&gt; &lt;div id="demo2"&gt;animation-delay: 1s&lt;/div&gt; &lt;div id="demo3"&gt;animation-delay: -1s&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; animation-iteration-count定义 定义动画在结束前播放的次数。可以是1次（默认）、多次、无限次。 语法 12345animation-iteration-count: infinite;animation-iteration-count: 3;animation-iteration-count: 2.3; animation-iteration-count: 2, 0, infinite; demo 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @keyframes demo &#123; 30% &#123; width: 200px; &#125; 60% &#123; width: 300px; &#125; 100% &#123; width: 400px; &#125; &#125; #demo &#123; width: 100px; height: 100px; background-color: red; animation: demo 3s linear 0s; animation-iteration-count: 1; /* animation-iteration-count: 2.5; */ /* animation-iteration-count: infinite; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; animation-direction定义 指示动画播放的方向 语法 123456animation-direction: normalanimation-direction: reverseanimation-direction: alternateanimation-direction: alternate-reverseanimation-direction: normal, reverseanimation-direction: alternate, reverse, normal 值 含义 normal（默认） 动画正向播放 reverse 反向播放动画，每周期动画由尾到头运行 alternate 动画按照 “正反正反…”的顺序交替播放 alternate-reverse 动画按照 “反正反正…”的顺序交替播放 demo 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @keyframes demo &#123; 30% &#123; width: 200px; &#125; 60% &#123; width: 300px; &#125; 100% &#123; width: 400px; &#125; &#125; #demo &#123; width: 100px; height: 100px; background-color: red; animation: demo 3s linear 0s 3; animation-direction: normal; /* animation-direction: reverse; */ /* animation-direction: alternate; */ /* animation-direction: alternate-reverse; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; animation-play-state定义 定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放 语法 1234567891011/* Single animation */animation-play-state: running; /* 运行 */animation-play-state: paused; /* 暂停 */ /* Multiple animations */animation-play-state: paused, running, running; /* Global values */animation-play-state: inherited;animation-play-state: initial;animation-play-state: unset; demo 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @keyframes demo &#123; to &#123; width: 500px; &#125; &#125; #demo &#123; width: 100px; height: 100px; background-color: red; animation: demo 3s linear 0s infinite normal; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo"&gt;&lt;/div&gt; &lt;button&gt;running/paused&lt;/button&gt; &lt;script type="text/javascript"&gt; var oBtn = document.getElementsByTagName('button')[0], oDiv = document.getElementById('demo'); oBtn.onclick = function () &#123; oDiv.style.animationPlayState = window.getComputedStyle(oDiv, null)['animationPlayState'] == 'running' ? 'paused' : 'running'; console.log(window.getComputedStyle(oDiv, null)['animationPlayState']); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; animation-fill-mode定义 指定在动画执行之前和之后如何给动画的目标应用样式 语法 123456789animation-fill-mode: noneanimation-fill-mode: forwardsanimation-fill-mode: backwardsanimation-fill-mode: both /* 可以应用多个参数，这个时候使用逗号隔开 *//* 各个参数应用于与次序相对应的动画名 */animation-fill-mode: none, backwardsanimation-fill-mode: both, forwards, none 值 含义 forwards 动画结束时，目标保持动画最后一帧的样式 backwards 动画执行前，应用关键帧第一帧的样式 both 执行 forwards 和 backwards的动作 注意 上述的第一帧有可能是0%也有可能是100%（正向播放、反向播放） 对于backwards，动画采用第一帧的样式，保持 animation-delay demo 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @keyframes demo &#123; 0% &#123; left: 100px; &#125; 50% &#123; left: 200px; &#125; 100% &#123; left: 300px; &#125; &#125; #demo1, #demo2 &#123; position: absolute; left: 0px; width: 100px; height: 100px; background-color: red; &#125; #demo1 &#123; top: 0px; animation: demo 2s linear 1s; &#125; #demo2 &#123; top: 120px; animation: demo 2s linear 1s backwards; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo1"&gt;&lt;/div&gt; &lt;div id="demo2"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 可以看到，如果对于没有使用backwards值的小方块（上），在其初始位置等待延迟；对于使用backwards值的小方块（下），先立即应用第一帧的样式，然后在该位置等待延迟 下面这个demo是测试forwards和both： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @keyframes demo &#123; 0% &#123; left: 100px; &#125; 50% &#123; left: 200px; &#125; 100% &#123; left: 300px; &#125; &#125; #demo &#123; position: absolute; top: 0px; left: 0px; width: 100px; height: 100px; background-color: red; animation: demo 2s linear 1s forwards; /* animation: demo 2s linear 1s both; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; transition 和 animation的比较区别 触发条件不同 transition 通常和hover等事件配合使用，由事件触发。animation 则和 gif效果差不多 循环 transition 是一次性的，除非反复的触发事件；而 animation可以设定循环，重复播放 精确性 animation 可以设定每一帧的样式和时间；transition 只能设定头尾；animation 中可以设置每一帧需要的单独变化的样式属性，transition 中所有样式属性要一起变化 与JavaScript交互 animation 与 js 的交互不是很紧密；transition 和 js 的结合更强大。js设定要变化的样式，transition 负责动画效果 应用场景 如果要灵活定制多个帧以及循环，用animation 如果要加单的from to 效果，用transition 如果要使用js灵活设定动画属性，用transition 参考链接mdn css3 animation 属性众妙]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F08%2F12%2Ftest%2F</url>
    <content type="text"></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量-数据类型-运算]]></title>
    <url>%2F2018%2F03%2F12%2F%E5%8F%98%E9%87%8F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[变量声明、赋值、初始化声明，JS 中的变量用 var 关键词声明 1var a; 赋值，给变量赋予一定的值 123a = 1;b = 'hello';c = true; 初始化，在声明变量的同时，赋予变量一定的值 1var a = 1; 单一 var 模式，减少 var 的使用，对于一组变量声明，应当使用一个 var 进行声明 123456789101112// badvar a;var b;var c;// acceptablevar a, b, c;// good for developmentvar a, b, c; 命名命名规则 区分大小写 不允许使用 JavaScript 中的保留字，关键字 可以包含英文字母、_、$、数字，但不能以数字开头 123456789101112// 区分大小写, a 和 A 是两个变量var a;var A;// 不允许使用保留字、关键字，var 是声明关键字，不允许被当做变量使用var var = 1;// 可以包含英文字母、_、$、数字，但是不能以数字开头var a1 = 1; // 正确var _a = 1; // 正确var $a = 1; // 正确var 1a = 1; // 错误 数据类型原始值原始值采用 栈存储（stack），复制时生成副本，共有 6 中原始值类型： 123456- Number // 数字- String // 字符串- Boolean // 布尔- Undefined // 未定义- Null // 不存在- Symbol(ES6) // 引用值引用值采用 堆存储（heap），复制时不生成副本，采用引用方式，常见的引用类型数据有： 1234- Array // 数组- Object // 对象- function // 方法- RegExp // 正则 运算运算符数学运算符1234+、-、*、/、%、=、()、++、--、+=、-=、*=、/=、%=- 其中 &apos;+&apos; 运算符除了有数学运算的功能，还有字符串连接的功能- 任何数据类型 + 字符串，结果都是字符串 比较运算符123&gt;、&lt;、==、===、&gt;=、&lt;=、!=- &apos;===&apos;：绝对等于 逻辑运算符12345&amp;&amp;、||、！- &amp;&amp;：自左向右依次检查每一个表达式的运算结果的布尔值，若为真，则继续向后检查，若为假则停止检查，直到整个 与运算表达式结束；返回结果为停止检查时，当前表达式的运算结果- ||：自左向右依次检查每一个表达式的运算结果的布尔值，若为假，则继续向后检查，若为真则停止检查，直到整个 与运算表达式结束；返回结果为停止检查时，当前表达式的运算结果- !： 将表达式的运算结果转换成布尔值再取反，值为true或false 12345678910111213141516171819202122// 练习var a = 1 &amp;&amp; 2 + 3；// a = 5;var a = 0 &amp;&amp; 2 + 3;// a = 0;var a = 1 || 2 + 3;// a = 1;var a = 0 || 2 + 3;// a = 5;var a = !1 + 1;// a = 1;var a = !0 + 1;// a = 2;var a = !(1 + 1)// a = false;var a = !0// a = true;// 应用data &amp;&amp; fn(data)e = e || window.event 小数运算精度小数运算存在精度问题 12345678910111213141516171819202122// 加法 =====================// 0.1 + 0.2 = 0.30000000000000004// 0.7 + 0.1 = 0.7999999999999999// 0.2 + 0.4 = 0.6000000000000001// 2.22 + 0.1 = 2.3200000000000003 // 减法 =====================// 1.5 - 1.2 = 0.30000000000000004// 0.3 - 0.2 = 0.09999999999999998 // 乘法 =====================// 19.9 * 100 = 1989.9999999999998// 19.9 * 10 * 10 = 1990// 1306377.64 * 100 = 130637763.99999999// 1306377.64 * 10 * 10 = 130637763.99999999// 0.7 * 180 = 125.99999999999999// 9.7 * 100 = 969.9999999999999// 39.7 * 100 = 3970.0000000000005 // 除法 =====================// 0.3 / 0.1 = 2.9999999999999996// 0.69 / 10 = 0.06899999999999999 原因 JavaScript 中的数字采用 IEEE 754 的64为双精度标准，第 0 位表示符号位，1~11 位表示指数为，12~63 位表示小数位，符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度，IEEE 754规定，有效数字第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript提供的有效数字最长为53个二进制位 以 0.1 + 0.2 为例，0.1 和 0.2 在被转换成二进制时，其浮点数用二进制表达是无穷的 120.1 -&gt; 0.0001100110011001...(无限)0.2 -&gt; 0.0011001100110011...(无限) IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持 53 位二进制位，所以两者相加之后得到二进制为 10.0100110011001100110011001100110011001100110011001100 因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了 0.30000000000000004。所以在进行算术计算时会产生误差，详细参考 取整向上取整 1Math.ceil() 向下取整 1Math.floor() 随机数生成一个 (0, 1) 之间的随机数 1Math.random() 练习 随机生成 (0, 100) 之间的整数 1Math.floor(Math.random() * 100); 生成 [min, max] 之间的随机数 123Math.floor(Math.random() * (max - min + 1) + min)parseInt(Math.random() * (max - min + 1) + min, 10) 处理位数可以处理小数点前后 16 为的数据]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
