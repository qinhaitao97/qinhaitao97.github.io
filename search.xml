<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git入门]]></title>
    <url>%2F2018%2F06%2F30%2Fg01_git%2F</url>
    <content type="text"><![CDATA[下载安装官网下载，循环下一步安装 1https://git-scm.com/downloads 基本工作流 基本指令GitHub账户1https://www.github.com 登录以上GitHub网站，注册属于你的GitHub账户 配置环境 SSH配置 1ssh-keygen 在桌面或者某一个空文件夹下，右键选择 Git Bash Here，在打开的命令行中输入以上指令 首先他会询问想要把秘钥存放在本地的路径，这里直接回车选择默认路径即可；后面两步输入回车或者是 y 完成后找到第一步选择的路径下 .ssh 文件下的 id_rsa.pub 文件，用记事本打开，复制其中的公钥 打开你的GitHub网站，点击头像，在下拉菜单中选择 settings，在左侧菜单中选择 SSH and GPG keys 右侧点击绿色 New SSH key 按钮，Title栏中输入自定义名称（一般为当前机器名称，代表给哪台机器配置了 了 SSH 环境），在 Key 栏中粘贴刚才复制的内容 配置完毕 本地环境配置 123git config --global user.name &lt;username&gt;git config --global user.email &lt;useremail&gt; 在命令行中输入以上指令，注意尖括号内为自定义内容： username：GitHub的用户名 useremail：GitHub的邮件地址 查看本地配置 1git config --list 工作目录 &amp; 本地仓库 创建工作目录 在本地新建一个文件夹作为工作目录 初始化本地仓库 1git init 在工作目录文件夹，右键鼠标选择 Git Bash Here，在打开的命令行窗口中输入以上指令，用来初始化本地仓库，成功之后，在该文件夹会有一个隐藏的 .git 文件夹，包含所有的版本信息，这就是我们的本地仓库 远程仓库 创建远程仓库 打开GitHub网站，登录GitHub账号，点击右上角头像，在下拉菜单中选择 Your repositories，在打开的页面中，点击右侧绿色的 New 按钮，新建一个远程仓库，根据提示输入相关的信息 创建成功之后的界面如下 关联 本地分支与远程分支建立关联 1git remote add &lt;name&gt; &lt;repository&gt; 之前我们已经创建好了本地仓库和远程仓库，那怎么把两者关联起来了呢？使用上述命令进行关联，注意 &lt;&gt; 内的内容为自定义，其代表的含义如下 name：给要关联的远端仓库起个别名 repository：要关联的远端仓库的地址 别名可以自定义，那这个远端仓库的地址在哪获取呢？步骤如下： 打开GitHub网站，登录后点击头像，选择 Your repositories 选择你要关联的远端仓库(如之前教程中创建的test仓库) 点击右侧绿色的 Clone or download 按钮，复制下面的地址，此地址即为上面命令中的 &lt;repository&gt; 查看远端仓库的别名 1git remote 重命名远端仓库 1git remote rename &lt;oldname&gt; &lt;newname&gt; 如果想给远程仓库重命名，使用这条指令，注意 &lt;&gt; 内的内容为自定义，其含义如下 oldname：远端仓库原来的名字 newname：远端仓库新的名字 查看远程仓库 1git remote -v 查看已关联的远程仓库 工作 创建或修改工作目录中的文件 完成了创建以及关联的工作后，我们就可以进行工作了，我们的工作区还没有任何的文件，所以我们在工作目录新建一个文件，如 index.html 查看当前文件状态 1git status 如果工作目录中的某一个文件是刚刚创建的或者刚刚被修改过的，那么我们输入这条指令后，会提示我们 Untracked files，在这条提示的下面列出了所有的 Untracked files，表示这些文件是未被追踪的，即对于本地仓库来说，这些文件是不存在的，所以我们要先把这些文件提交到 暂存区，方法如下 添加到暂存区 123git add &lt;file&gt;git add . 第一条指令表示要添加哪个文件到暂存区，&lt;file&gt; 代表文件，第二条指令表示将工作目录中所有文件都添加到暂存区中去；把文件添加到暂存区是为了临时保存，比如在开发过程中临时有事，暂时不能开发，那就先把文件添加到暂存区中，方便后续继续进行修改；如果我们已经确定开发完成，那么就可以把暂存区中的内容提交到本地仓库，方法如下 提交到本地仓库 1git commit -m &lt;description&gt; -m 是 message 的意思，代表这次提交的描述信息，比如这是第几次提交、这是第几次修改等等，&lt;description&gt; 就是用来写这个描述信息 提交内容到远程仓库 1git push &lt;remote&gt; &lt;branch&gt; 将本地仓库中的内容提交到远程仓库中 remote：被提交的本地仓库 branch：提交到远程仓库中的哪个分支（分支的概念后面介绍，这里我们暂且只有一个 master 分支） 撤销 撤销工作区修改 1git checkout -- &lt;file&gt; 撤销工作区的修改，是相对于暂存区而言的；比如我们将工作区 index.html 文件添加到暂存区，然后我们又在工作区对 index.html 文件进行了修改，修改了一大堆发现还是不修改比较好，当然这个时候我们可以一步步的 Ctrl + z ，但更好的方式是直接使用上述命令，工作区中的该文件直接回退到暂存区中这个文件的版本 查看提交日志 1git log 查看所有的提交记录，包括 commit 信息、作者、时间、描述信息，以及 HEAD -&gt; branch 当前指向哪个版本 查看提交id 1git reflog 查看所有提交的 commit ID，以及 HEAD -&gt; branch 当前指向哪个版本 版本回退 1git reset (--hard | soft | mixed) (&lt;HEAD~ num&gt; | &lt;commit ID&gt;) --hard：重置位置的同时，清空工作目录的所有改动 --soft：重置位置的同时，保留并做目录和暂存区的内容，并把重置 HEAD 的位置所导致的新的文件差异放进暂存区 --mixed：默认参数，重置位置的同时，保留工作目录的内容，并清空暂存区 使用举例： 使用 hard 参数回退一个版本 123git reset --hard HEAD~ 1git reset --hard HEAD^ 使用 mixed 参数退回两个版本 123git reset --mixed HEAD~ 2git reset HEAD~2 使用 soft 参数回退一个版本 1git reset --soft HEAD~ 1 使用 hard 参数回退到指定版本 1git reset --hard &lt;commit ID&gt; 差异比较 比较工作区和暂存区的内容 1git diff 比较暂存区和本地仓库最近一次 commit 内容 1git diff --cached 比较工作区与本地仓库最近一次 commit 内容 1git diff HEAD 比较两个 commit 之间的差异 1git diff &lt;commit ID&gt; &lt;commit ID&gt; 分支不同分支之间互不影响 查看分支 1git branch 创建新分支 1git branch &lt;name&gt; 切换分支 1git checkout &lt;name&gt; 创建并切换分支 1git checkout -b &lt;name&gt; 删除本地分支 1git branch -d &lt;name&gt; 删除远程分支 1git push -d &lt;remote&gt; &lt;branch&gt; 合并分支 1git merge &lt;branch&gt; 如果有分支冲突，选择保留哪一个分支的设置，然后 add、commit 将本地分支推到远程分支上 1git push &lt;remote&gt; &lt;branch1&gt;:&lt;branch2&gt; branch1：本地分支 branch2：远程分支 clone 克隆GitHub的项目 1git clone &lt;repository&gt;]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2018%2F06%2F27%2Ff02_module%2F</url>
    <content type="text"><![CDATA[什么是前端工程化前端工程化是根据业务特点，将前端开发流程规范化、标准化，它包括了开发流程、技术选型、代码规范、构建发布等，用于提高前端工程师的开发效率和代码质量 一个符合前端工程化要求的方案应该包含以下要素： 12345678- 开发规范- 模块化开发- 组件化开发- 组件仓库- 性能优化- 部署- 开发流程- 开发工具 那我们该怎么实现这一系列的工程化需求呢？ 构建工具自动化构建工具说到构建工具，我往往会在前面加「自动化」三个字，因为构建工具就是用来让我们不再做机械重复的事情，解放我们的双手的。 要完成前端工程化，少不了工程化工具，requireJS与grunt的出现，改变了业界前端代码的编写习惯，同时他们也是推动前端工程化的一个基础。 requireJS是一伟大的模块加载器，他的出现让javascript制作多人维护的大型项目变成了事实；grunt是一款javascript构建工具，主要完成编译、压缩、合并等一系列工作，后续又出了yeoman、Gulp、webpack等构建工具。 Webpack具有Grunt、Gulp对于静态资源自动化构建的能力，但更重要的是，Webpack弥补了requireJS在模块化方面的缺陷，同时兼容AMD与CMD的模块加载规范，具有更强大的JS模块化的功能。 自动化构建工具的两个模式开发模式 开发模式主要就是监听文件变化，自动进行打包、合并等操作 生产模式 参考我们的技术栈与需求，我们的静态文件都要发布到 CDN 上，而且必须有 md5 版本号，方便快速发布（CDN 更新机器缓慢，所以更新必须使用新的文件名） 生产模式主要增加了文件压缩、文件 md5 修改、替换 html 等操作 这样的好处就是上线非常方便，一个命令即可更新上线，而且不存在缓存问题 CDN基本原理CDN 是构建在网络上内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、调度、内容发布等功能模块，使用户就近的获取所需内容，降低网络拥塞，提高用户的响应速度和命中率；CDN 关键技术主要有 内容存储 和 分发技术 CDN 基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器，有缓存服务器直接响应用户请求 CDN 网络是在用户和服务器之间增加了 cache 层，如何将用户的请求引导到 cache 上获得服务器的数据，主要是通过接管 DNS 实现的，这就是 CDN 的基本原理 流程 用户向浏览器输入 www.web.com 这个域名，浏览器第一次发现本地没有 DNS 缓存，则向网站的 DNS 服务器请求 网站的 DNS 域名解析设置了 CNAME，指向了 www.web.51cdn.com，请求指向了 CDN 网络中的智能 DNS 负载均衡系统 智能 DNS 负载均衡系统解析域名，把用户响应速度最快的的 IP 节点返回给用户 用户向改 IP 节点（DNS 服务器）发出请求 由于是第一次访问，CDN 服务器会向原 web 站点请求，并缓存内容 请求结果发给用户 webpack概述 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle 安装node webpack 运行基于 node 环境，在升级到 4.x+ 版本以后，运行环境升级，node-v &gt;= 6.11.5，官网下载 循环下一步安装即可，安装时不要有中文路径，安装完成后可选择性的 配置环境 (不是必须) 12345# 查看 node 版本node -v# 查看 npm 版本npm -v git 我们打算用 git 来进行指令操作，所以 官网下载，循环下一步安装 如果在 git 中查看 node 版本时出现以下提示，重启电脑即可 1bash: node: command not found webpack 全局安装 webpack，出现 + webpack@4.x 代表安装成功，下同 12# 全局安装 webpacknpm install webpack -g webpack 4.x+ 中，CLI 移到了 webpack-cli 中，需要单独安装 12# 全局安装 webpack-clinpm install webpack-cli -g 安装静态服务 package （不是必须，但是几乎所有项目都要用到，这里一并安装了） 12# 全局安装 webpack-dev-servernpm install webpack-dev-server -g 完成了以上操作后，已经在全局安装了 webpack 及 webpack-cli（命令行接口），接下来我们在本一个本地项目中使用 webpack，在本地新建一个文件夹然后右键 Git Bash Here 本地局部安装 webpack 12# 局部安装 webpacknpm install webpack 本地局部安装 webpack-cli 12345# 局部安装 webpack-clinpm intall webpack-cli --save-dev# --save-dev 意为在本地开发模式下安装，在 webpack 4.x+ 版本中，它等同于npm install webpack-cli -D 初始化项目，生成 package.json 配置文件 1npm init 至此，局部 webpack 安装完成，但是如果直接使用 webpack 命令，会出现以下错误 因为 webpack 4.x+ 会默认指定一个入口文件和一个出口文件，这个入口文件需要我们自己创建 1# 在刚刚新建的本地目录下，创建 "src/index.js" 这时，我们再使用 webpack 命令，不会报错，而且本地目录下会自动创建 “dist/main.js”，这便是输出；虽然不会报错，但使用这个命令还是会提示警告，类似于 这是因为我们没有配置 webpack 模式，这个后续再提，不影响接下来的操作 基本概念入口[entry] 入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的 出口[output] output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中 loader loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理 插件[plugins] loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务 模式 通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化 基本使用以上基本概念中提到的属性，均可以在 webpack.config.js 中进行配置，下面介绍基本语法 模式 方法一：在 webpack.config.js 文件中配置 1234// 方法一：在 webpack.config.js 文件中配置module.exports = &#123; mode: 'development'&#125; 方法二：从 CLI 参数中传递 12345# 方法二：从 CLI 参数中传递webpack --mode=production# 或者用空格 ' ' 代替 "="webpack --mode production 方法三：或者在 package.json 文件中的 “scripts” 属性下进行配置，然后配合 npm 指令运行 12345// 方法三：或者在 package.json 文件中的 "scripts" 属性下进行配置，然后配合 npm 指令运行"scripts": &#123; // ..., "dev": "webpack --mode development"&#125; 12# npm指令，配合方法三npm run dev 入口 可自定义入口文件，默认是我们创建时所提供的 src/index.js 单个入口 1234const config = &#123; entry: './src/entrance.js'&#125;module.exports = config; 多个入口 1234567const config = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125;; 输出 配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个 入口 起点，但只指定一个 输出 配置 在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名 目标输出目录 path 的绝对路径 12345678910111213141516171819202122232425262728module.exports = &#123; // ... output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', &#125;,&#125;// 或者多个入口生成不同文件module.exports = &#123; entry: &#123; foo: './src/foo.js', bar: './src/bar.js', &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist', &#125;,&#125;// 路径中使用 hash，每次构建时会有一个不同 hash 值，避免发布新版本时线上使用浏览器缓存module.exports = &#123; // ... output: &#123; filename: '[name].js', path: __dirname + '/dist/[hash]', &#125;,&#125; loader 当我们需要使用不同的 loader 来解析处理不同类型的文件时，我们可以在 module.rules 字段下来配置相关的规则，例如使用 Babel 来处理 .js 文件： 123456789101112module: &#123; // ... rules: [ &#123; test: /\.jsx?/, // 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀 include: [ path.resolve(__dirname, 'src') // 指定哪些路径下的文件需要经过 loader 处理 ], use: ['babel-loader'] // 指定使用的 loader &#125;, ]&#125; 使用前需要先下载相应的 loader 12345# 下载 babel-loader，要与 babel-loader 一起安装npm install babel-core babel-loader -D# 可以一次下载多个 loadernpm install css-loader style-loader -D 插件 插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！ 插件目的在于解决 loader 无法实现的其他事 1234567const UglifyPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; plugins: [ new UglifyPlugin() ],&#125; 使用前需要先下载相应的插件 1234npm install uglifyjs-webpack-plugin -D# 可以一次下载多个插件npm install uglifyjs-webpack-plugin extract-text-webpack-plugin@next -D 模块 对比 node.js 模块，webpack 模块能够以各种方式表达他们的依赖关系 123456789101112- ES6 import- CommonJS require- AMD define require- css / sass / less @import- url url image url 基本命令12 搭建基本的前端开发环境12345- 构建我们发布需要的 HTML、CSS、JS 文件- 使用 CSS 预处理器来编写样式- 处理和压缩图片- 使用 Babel 来支持 ES 新特性- 本地提供静态服务以方便开发调试 配置loader在 module.rules 数组中进行 loader 的配置，该数组中每一个对象对应一条 loader 规则 123456789101112131415module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\.jsx?/, // 条件 include: [ path.resolve(__dirname, 'src'), ], // 条件 use: 'babel-loader', // 规则应用结果 &#125;, // 一个 object 即一条规则 // ... ], &#125;,&#125; 在每一条规则中，有两种关键配置：匹配条件 和 匹配后的应用 匹配条件： 12345678910- 匹配特定的条件 &#123; test: ... &#125;- 匹配特定的路径 &#123; include: ... &#125;- 排除特定的路径 &#123; and: [...] &#125;- 匹配数组中任意一个条件 &#123; or: [...] &#125;- 排除匹配数组中所有的条件 &#123; not: [...] &#125; 通常会结合使用 test / and 和 include &amp; exclude 来进行条件配置 匹配后的应用： 用 module.rules 中的 use 属性进行配置，可以是字符串、对象或者数组，可以使用 optionis 给对应的 loader 传递一些配置项，可以参见官网对不同 loader 的配置说明 1234567891011121314151617181920rules: [ &#123; test: /\.less/, use: [ 'style-loader', // 直接使用字符串表示 loader &#123; loader: 'css-loader', options: &#123; importLoaders: 1 &#125; &#125;, // 用对象表示 loader，可以传递 loader 配置等 &#123; loader: 'less-loader', options: &#123; noIeCompat: true &#125; // 传递 loader 配置 &#125; ] &#125;,] loader 应用顺序 对于同一个 rule 中的 loader，应用顺序从后向前，对于不同 rule 中的 loader，应用顺序是：前置 &gt; 行内 &gt; 普通 &gt; 后置，前置和后置通过 rule 中的 enforce 字段来设置，行内 loader 是在应用代码中引用依赖时直接声明使用的 loader，如 const json = require(&#39;json-loader!./file.json&#39;) 这种，不建议在应用开发中使用这种 loader。其他的为普通 loader 12345678rules: [ &#123; enforce: 'pre', // 指定为前置类型，post 为后置类型 test: /\.js$/, exclude: /node_modules/, loader: "eslint-loader", &#125;,] 使用 noParse 除了 module.rules 字段用于配置 loader 之外，还有一个 module.noParse 字段，可以用于配置哪些模块文件的内容不需要进行解析。对于一些不需要解析依赖（即无依赖） 的第三方大型类库等，可以通过这个字段来配置，以提高整体的构建速度 使用 noParse 进行忽略的模块文件中不能使用 import、require、define 等导入机制。 1234567891011module.exports = &#123; // ... module: &#123; noParse: /jquery|lodash/, // 正则表达式 // 或者使用 function noParse(content) &#123; return /jquery|lodash/.test(content) &#125;, &#125;&#125; webpack-dev-serverwebpack-dev-server 是 webpack 官方提供的一个工具，可以基于当前的 webpack 构建配置快速启动一个静态服务。当 mode 为 development 时，会具备 hot reload 的功能，即当源码文件变化时，会即时更新当前页面，以便你看到最新的效果 安装 1npm install webpack-dev-server -g 使用 1webpack-dev-server --mode development 建议把 webpack-dev-server 作为开发依赖安装，然后使用 npm scripts 来启动 12345678// package.json&#123; // ... "scripts": &#123; // ... "start": "webpack-dev-server --mode development" &#125;&#125; webpack-dev-server 默认使用 8080 端口，如果你使用了 html-webpack-plugin 来构建 HTML 文件，并且有一个 index.html 的构建结果，那么直接访问 http://localhost:8080/ 就可以看到 index.html 页面了。如果没有 HTML 文件的话，那么 webpack-dev-server 会生成一个展示静态资源列表的页面 使用 HMRHMR 全称是 Hot Module Replacement，即模块热替换。在这个概念出来之前，我们使用过 Hot Reloading，当代码变更时通知浏览器刷新页面，以避免频繁手动刷新浏览器页面。HMR 可以理解为增强版的 Hot Reloading，但不用整个页面刷新，而是局部替换掉部分模块代码并且使其生效，可以看到代码变更后的效果。所以，HMR 既避免了频繁手动刷新页面，也减少了页面刷新时的等待，可以极大地提高前端页面开发效率 配置使用 12345678910111213const webpack = require('webpack')module.exports = &#123; // ... devServer: &#123; hot: true // dev server 的配置要启动 hot，或者在命令行中带参数开启 &#125;, plugins: [ // ... new webpack.NamedModulesPlugin(), // 用于启动 HMR 时可以显示模块的相对路径 new webpack.HotModuleReplacementPlugin(), // Hot Module Replacement 的插件 ],&#125; 优化前端资源加载图片加载优化和代码压缩CSS Sprites图片压缩在一般的项目中，图片资源会占前端资源的很大一部分，既然代码都进行压缩了，占大头的图片就更不用说了。 我们之前提及使用 file-loader 来处理图片文件，在此基础上，我们再添加一个 image-webpack-loader 来压缩图片文件。简单的配置如下： 12345678910111213141516171819202122232425262728293031323334353637module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /.*\.(gif|png|jpe?g|svg|webp)$/i, use: [ &#123; loader: 'file-loader', options: &#123;&#125; &#125;, &#123; loader: 'image-webpack-loader', options: &#123; mozjpeg: &#123; // 压缩 jpeg 的配置 progressive: true, quality: 65 &#125;, optipng: &#123; // 使用 imagemin-optipng 压缩 png，enable: false 为关闭 enabled: false, &#125;, pngquant: &#123; // 使用 imagemin-pngquant 压缩 png quality: '65-90', speed: 4 &#125;, gifsicle: &#123; // 压缩 gif 的配置 interlaced: false, &#125;, webp: &#123; // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式 quality: 75 &#125;, &#125;, ], &#125;, ], &#125;,&#125; 使用 DataURL有的时候我们的项目中会有一些很小的图片，因为某些缘故并不想使用 CSS Sprites 的方式来处理（譬如小图片不多，因此引入 CSS Sprites 感觉麻烦），那么我们可以在 webpack 中使用 url-loader 来处理这些很小的图片。 url-loader 和 file-loader 的功能类似，但是在处理文件的时候，可以通过配置指定一个大小，当文件小于这个配置值时，url-loader 会将其转换为一个 base64 编码的 DataURL，配置如下 123456789101112131415161718module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192, // 单位是 Byte，当文件小于 8KB 时作为 DataURL 处理 &#125;, &#125;, ], &#125;, ], &#125;,&#125; 代码压缩对于 HTML 文件，之前介绍的 html-webpack-plugin 插件可以帮助我们生成需要的 HTML 并对其进行压缩 12345678910111213module.exports = &#123; // ... plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 配置输出文件名和路径 template: 'assets/index.html', // 配置文件模板 minify: &#123; // 压缩 HTML 的配置 minifyCSS: true, // 压缩 HTML 中出现的 CSS 代码 minifyJS: true // 压缩 HTML 中出现的 JS 代码 &#125; &#125;), ],&#125; 对于 CSS 文件，我们之前介绍过用来处理 CSS 文件的 css-loader，也提供了压缩 CSS 代码的功能： 12345678910111213141516171819202122module.exports = &#123; module: &#123; rules: [ // ... &#123; test: /\.css/, include: [ path.resolve(__dirname, 'src'), ], use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; minimize: true, // 使用 css 的压缩功能 &#125;, &#125;, ], &#125;, ], &#125;&#125; 对于 JS 文件，使用 uglifyjs-webpack-plugin 插件进行压缩 123456789const UglifyPlugin = require('uglifyjs-webpack-plugin');const config = &#123; // ... plugins: [ new UglifyPlugin() // ... ]&#125;module.exports = config; 常见错误 Error: Cannot find module ‘less’ 12# 原因：less-loader 与 less 是相互依赖的，在使用 less 开发时，两者都要安装npm install less -D (node:20256) DeprecationWarning: Tapable.plugin is deprecated. Use new API on .hooks instead 12345# 原因：'extract-text-webpack-plugin' 不支持 webpack 4.x+ 版本# 使用 alpha 版本npm install extract-text-webpack-plugin@next -D# 或者使用支持 webpack 4.x+ 的正式版本，这个具体用法和 extract-text-webpack-plugin 不一样，详细见链接npm install mini-css-extract-plugin -D mini-css-extract-plugin ERROR in ./src/less/index.less 1:0Module parse failed: Unexpected character ‘@’ (1:0)You may need an appropriate loader to handle this file type. @import ‘base.less’;|| .wrapper {@ ./src/js/index.js 1:0-29 出现这样类似的问题，有可能是 webpack.config.js 中 module.rules 中的 test 属性匹配错误（比如正则表达式的错误）]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>module</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化入门]]></title>
    <url>%2F2018%2F06%2F26%2Ff01_module%2F</url>
    <content type="text"><![CDATA[模块化简介概述具有相同属性和行为的事物的集合。在前端中，将一些属性比较类似行为比较相近的内容放在同一个js文件里面，把这个js文件称为模块，为了每个js文件只关注与自身有关的事情，让每个js文件各司其职 特点模块化主要有几个特点： 独立 完整 依赖关系 实现 函数 对象写法 匿名函数、返回对象 依赖传入实参 以上几种实现的缺点是依赖关系不好处理，需要按顺序加载，会阻塞页面 CommonJs根据CommonJs规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量，该规范最初是用在服务器端node的，前端的webpack也是对CommonJs原生支持的 CommonJs核心思想就是通过 require 方法同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口 12345678910// index.jsvar print = require('module.js');print.aa('hello');// module.jsmodule.exports = &#123; aa: function (str) &#123; console.log(str); &#125;&#125; 但是浏览器不兼容CommonJs，原因是浏览器缺少module、exports、require、global四个环境变量。如要使用需要工具转换 CommonJS采用同步加载不同模块文件，适用于服务器端的。因为模块文件都存放在服务器的各个硬盘上，读取加载时间快，适合服务器端，不适应浏览器 AMDCommonJs为服务器端而生，采用同步加载的方式，因此不适合浏览器，因为浏览器需要到服务器加载文件，请求时间远大于本机读取的时间，倘若文件较多，网络延迟就会导致页面瘫痪，所以浏览器更希望能够实现异步加载的方式 AMD规范则是异步加载模块，允许指定回调函数，等模块异步加载完成之后即可调用回调函数 AMD的得意产出是require.js AMD的核心思想就是通过 define 来定义一个模块，然后使用 require 来加载一个模块 123456789// main.jsrequire(['jquery', 'math'], function ($, math) &#123; // ...&#125;)// math.jsdefine(function () &#123; // ...&#125;) CMDCMD异步加载，和AMD主要的区别在于，AMD依赖前置，提前加载依赖，而CMD就近加载，按需加载 产物是 seaJs，和 requireJs 使用有些相似 CMD用法也会使用 define 来定义一个模块，用 require 来家在一个模块 123456789101112131415&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="./js/sea.js"&gt;&lt;/script&gt; &lt;script src="./js/math.js"&gt;&lt;/script&gt; &lt;script&gt; seajs.use('./js/main.js'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456// main.jsdefine(function (require, exports, module) &#123; var math = require('math'); console.log(math.add(1, 2)); console.log(math.str);&#125;) 123456789// math.jsdefine(function (require, exports, module) &#123; function add(a, b) &#123; return a + b; &#125; module.exports.add = add; exports.str = '123'; &#125;) 123456// sea.config.jsseajs.config(&#123; alias: &#123; 'math': './math.js' &#125;&#125;) 12// sea.js// 官网下载 ES6ES6自带模块化，可以使用 import 关键字引入模块，通过 export 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的，但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>module</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket]]></title>
    <url>%2F2018%2F06%2F24%2Fe07_html5%2F</url>
    <content type="text"><![CDATA[概述WebSocket是一种在单个TCP连接上进行全双工通信的协议，它使得客户端与服务器端的通信变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以建立持久性的连接，并进行双向数据传输 背景HTTP协议的缺陷我们已知的通信协议HTTP，有一个缺陷：只能由客户端发出请求，服务端不能主动的发送请求；这样如果我们需要获取服务端的数据就必须先在客户端发送HTTP请求，但有时我们并不想主动的发送数据，而期待客户端能主动地向客户端推送一些数据，典型的比如聊天室的功能，我们并不想点击某个接受按钮才接受消息，而是服务端一旦有了新的消息便推送到我们的客户端的，但实际中我们好像确实没有点击某个按钮才能接收到消息，这是因为采用了一种 “轮询” 技术 轮询轮询分为传统的轮询方式和一种较新的 “Comet” 轮询方式。传统的轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器，这种模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 而比较新的技术去做轮询的效果是Comet)。这种技术虽然可以双向通信，但依然需要反复发出请求。而且在Comet中，普遍采用的长链接，也会消耗服务器资源 特点在上述背景下，HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行双向通讯，有以下特点 建立在 TCP 协议之上，服务端的实现比较容易 与 HTTP 有良好的兼容性，默认端口也是 80 和 443 ，握手阶段采用 HTTP 协议 数据格式比较轻量，性能开销较小，通信效率高 可以发送文本也可以发送二进制数据 没有同源限制，客户端可以与任意服务器通信 协议标识符是 ws，如果加密则为 wss 建立连接的过程当 web 应用程序调用 new WebSocket(url) 接口时，浏览器就开始了与地址为 url 的 webserver 建立握手连接的过程 浏览器与 WebSocket 服务器通过 TCP 握手建立连接，如果这个链接失败，那么后面的过程就不会执行，web 应用程序就会收到错误通知 在 TCP 建立成功之后，浏览器通过 HTTP 协议传送 WebSocket 支持的版本号、协议的字版本号、原始地址主机地址等一系列字段给服务器端 WebSocket 服务器收到浏览器发送的请求后，如果数据包的数据和格式正确，客户端和服务端的协议版本号匹配，就接受本次握手连接，并给出相应的数据回复，同样，回复数据也是采用 HTTP 协议传输 浏览器收到服务器回复的数据包后，如果数据包内容、格式等没有问题，就表示本次连接成功，触发 onopen 事件，此时 web 开发者就可以通过 send() 接口向服务器发送数据。如果数据包内容、格式等不正确，则握手连接失败，触发 onerror 事件，可以获取失败的原因 WebSocket API创建连接 1var Socket = new WebSocket(url); 状态 12345- readyState 0: CONNECTING，表示正在连接。 1: OPEN，表示连接成功，可以通信了。 2: CLOSING，表示连接正在关闭。 3: CLOSED，值为3，表示连接已经关闭，或者打开连接失败 方法 12345// 传输数据Socket.send(data);// 终止任何现有连接Socket.close(); 事件 事件 描述 open 连接建立时触发 message 客户端接受服务端数据时触发 close 连接关闭时触发 error 通信发生错误时触发 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- practice: WedSocket API 针对上述API知识点的练习--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;WebSocket&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // WebSocket.org 提供了一个专门用来测试WebSocket的服务器 var socket = new WebSocket('ws://echo.websocket.org'); console.log(socket.readyState); socket.onopen = function () &#123; console.log(this.readyState); this.send('hello websocket'); &#125; socket.onmessage = function (e) &#123; console.log(this.readyState); console.log(e.data); this.close(); &#125; socket.onclose = function () &#123; console.log(this.readyState); console.log('closed'); &#125; socket.onerror = function () &#123; console.log('error'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拖拽、文件读取]]></title>
    <url>%2F2018%2F06%2F23%2Fe06_html5%2F</url>
    <content type="text"><![CDATA[drag &amp; drop功能 1常用于各种拖动操作，不同于我们之前用onmousemove等事件写的拖拽 创建拖拽元素 12&lt;!-- 添加 draggable 属性，并设置为true --&gt;&lt;div class="drag" draggable="true"&gt;&lt;/div&gt; 123456789101112131415161718192021222324&lt;!-- practice: 创建 针对上述知识点的联系--&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;drag&lt;/title&gt; &lt;style&gt; .drag &#123; width: 100px; height: 100px; background-color: deepskyblue; margin-top: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="drag" draggable="true"&gt;可拖拽元素&lt;/div&gt; &lt;div class="drag"&gt;不可拖拽元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 拖拽相关的事件 12345678910- dragstart 被拖拽元素开始被拖拽时触发- dragend 被拖拽元素拖拽完成时触发- dragenter 被拖拽元素进入目标元素时触发（是否进入是由鼠标的位置判断的）- dragover 被拖拽元素在目标元素区域内时触发- drop 被拖拽元素在目标元素区域内前提下，鼠标放开时触发，注意要触发这个事件必须先取消 dragover 的默认事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!-- use: 事件 上述事件知识点的使用方法--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;drag&lt;/title&gt; &lt;style&gt; .drag &#123; width: 100px; height: 100px; background-color: deepskyblue; &#125; .target &#123; width: 300px; height: 300px; border: 1px solid #000; margin-top: 60px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="drag" draggable="true"&gt;可拖拽元素&lt;/div&gt; &lt;div class="target"&gt;&lt;/div&gt; &lt;script&gt; var item = document.getElementsByClassName('drag')[0]; var target = document.getElementsByClassName('target')[0]; item.addEventListener('dragstart', function () &#123; console.log('dragstart'); &#125;, false); item.addEventListener('dragend', function () &#123; console.log('dragend'); &#125;, false); target.addEventListener('dragenter', function () &#123; console.log('dragenter'); &#125;, false); target.addEventListener('dragover', function (e) &#123; e.preventDefault(); console.log('dragover'); &#125;, false); target.addEventListener('drop', function () &#123; console.log('drop'); &#125;, false); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; dragEvent 事件对象 1234- e.dataTransfer.setData(name, value) 给被拖拽的元素传值- e.dataTransfer.getData(name) 从被拖拽的元素取值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!-- demo: 拖拽 将被拖拽元素拖入目标区域的demo--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;drag&lt;/title&gt; &lt;style&gt; #item1, #item2 &#123; width: 100px; height: 100px; background-color: deeppink; &#125; #item2 &#123; background-color: deepskyblue; &#125; #target &#123; width: 300px; height: 300px; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="item1" draggable="true"&gt;item1&lt;/div&gt; &lt;div id="item2" draggable="true"&gt;item2&lt;/div&gt; &lt;div id="target"&gt;目标区域&lt;/div&gt; &lt;script&gt; var item1 = document.getElementById('item1'), item2 = document.getElementById('item2'), target = document.getElementById('target'); // 被拖拽元素开始拖拽时，给他设置属于它的属性值 item1.addEventListener('dragstart', function (e) &#123; e.dataTransfer.setData('name', this.id); &#125;, false); // 被拖拽元素开始拖拽时，给他设置属于它的属性值 item2.addEventListener('dragstart', function (e) &#123; e.dataTransfer.setData('name', this.id); &#125;, false); // 取消 dragover 事件的默认事件 target.addEventListener('dragover', function (e) &#123; e.preventDefault(); &#125;, false); // 被拖拽元素在目标区域内且鼠标松开时，获取之前设置的属性值，通过该值将此元素插入到目标区域 target.addEventListener('drop', function (e) &#123; var itemId = e.dataTransfer.getData('name'); var item = document.getElementById(itemId); this.appendChild(item); &#125;, false); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!-- demo：排序 &amp; 删除 排序：将灰色方块a移动到另一个灰色方块b上时，将方块a插入到方块b前 删除：将灰色方块移入删除区域中，该灰色方块被删除--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;drag&lt;/title&gt; &lt;style&gt; #wrapper div &#123; width: 200px; height: 60px; background-color: #999; text-align: center; line-height: 60px; margin-top: 10px; &#125; #delete &#123; position: absolute; top: 30px; left: 300px; width: 300px; height: 300px; border: 1px solid #000; text-align: center; line-height: 300px; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="wrapper"&gt; &lt;div id="item1" class="item" draggable="true"&gt;item1&lt;/div&gt; &lt;div id="item2" class="item" draggable="true"&gt;item2&lt;/div&gt; &lt;div id="item3" class="item" draggable="true"&gt;item3&lt;/div&gt; &lt;div id="item4" class="item" draggable="true"&gt;item4&lt;/div&gt; &lt;div id="item5" class="item" draggable="true"&gt;item5&lt;/div&gt; &lt;/div&gt; &lt;div id="delete"&gt;拖入删除&lt;/div&gt; &lt;script&gt; var item = document.getElementsByClassName('item'), itemLen = item.length; // 在item元素上绑定事件，因为对于排序功能，被拖拽元素和目标元素都是item，所以这个功能的事件都绑定在item上 function bindItem() &#123; for (var i = 0; i &lt; itemLen; i++) &#123; // 注意，这里会形成闭包，要使用立即执行函数 (function (i) &#123; item[i].addEventListener('dragstart', function (e) &#123; e.stopPropagation(); e.dataTransfer.setData('name', 'item' + (i + 1)); &#125;, false); item[i].addEventListener('dragover', function (e) &#123; e.preventDefault(); &#125;, false); // 鼠标松开时，将被拖拽元素移动到目标元素前面 item[i].addEventListener('drop', function (e) &#123; var name = e.dataTransfer.getData('name'); var wrapper = document.getElementById('wrapper'); var oItem = document.getElementById(name); wrapper.insertBefore(oItem, this); &#125;, false); &#125;)(i); &#125; &#125; bindItem(); // 在delete上绑定事件，在排序功能中已经实现了item拖拽记录信息，所以这里只需要在目标区域将信息读取出来，并删除被拖拽元素 function bindDelete() &#123; var del = document.getElementById('delete'); del.addEventListener('dragover', function (e) &#123; e.preventDefault(); &#125;, false); del.addEventListener('drop', function (e) &#123; var name = e.dataTransfer.getData('name'); var oItem = document.getElementById(name); oItem.remove(); &#125;, false); &#125; bindDelete(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 拖拽上传文件 现在我们来想一下文件拖拽上传的功能，即我们从本地电脑选择一个文件，将它拖拽到浏览器的指定区域，该区域读取文件后，将该文件上传到服务器，可以可以看到，改功能大致分为三步：拖拽文件、读取文件、上传文件，我们先来讲拖拽文件 第一步：拖拽文件 首先，我们要了解一个知识，把文件拖拽到浏览器中，浏览器可以对它可识别的文件进行展示，举个例子： 这样就会带来一个问题，我们只是想把文件拖拽到指定区域进行展示，并不想让浏览器展示我们拖拽的文件，解决方法是取消目标区域 drop 事件的默认事件 1234567891011121314151617181920212223242526272829303132&lt;!-- use: 取消默认事件 取消目标区域 drop 事件的默认事件--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;drag&lt;/title&gt; &lt;style&gt; .target &#123; width: 200px; height: 200px; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="target"&gt;&lt;/div&gt; &lt;script&gt; var target = document.getElementsByClassName('target')[0]; target.addEventListener('dragover', function (e) &#123; e.preventDefault(); &#125;, false); target.addEventListener('drop', function (e) &#123; e.preventDefault(); &#125;, false); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 将文件拖拽到目标区域，我们可以通过事件对象的 e.dataTransfer.files 属性来读取关于文件的信息，注意只是读取相关信息，并不是我们上面所说的第二步读取文件的操作 123456789101112131415161718192021222324252627282930313233&lt;!-- use: 读取文件信息 读取被拖入目标区域的文件的相关信息--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;drag&lt;/title&gt; &lt;style&gt; .target &#123; width: 200px; height: 200px; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="target"&gt;&lt;/div&gt; &lt;script&gt; var target = document.getElementsByClassName('target')[0]; target.addEventListener('dragover', function (e) &#123; e.preventDefault(); &#125;, false); target.addEventListener('drop', function (e) &#123; e.preventDefault(); console.log(e.dataTransfer.files); &#125;, false); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，该属性返回一个 FileList 对象，记录了我们拖入该区域的所有文件的信息 FileReader方法 12345678910- abort() 终止读取- readAsBinaryString(file) 将文件读取为二进制编码- readAsDataURL(file) 将文件读取为 DataURL 编码- readAsText(file [, encoding]) 将文件读取为文本- readAsArrayBuffer(flie) 将文件读取为 arraybuffer 事件 123456789101112- onloadstart 读取开始时触发- onprogress 读取中触发- onloadend 读取完成触发，无论成功失败- onload 文件读取成功时触发- onabort 中断时触发- onerror 出错时触发 获取读取的结果 123fr.onload = function () &#123; this.result; // 读取的结果&#125;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多媒体]]></title>
    <url>%2F2018%2F06%2F21%2Fe05_html5%2F</url>
    <content type="text"><![CDATA[多媒体元素 audio 音频 video 视频 使用引入多媒体资源 12345&lt;!-- 音频标签 --&gt;&lt;audio id="audio" src="./demo.mp3"&gt;&lt;/audio&gt;&lt;!-- 视频标签 --&gt;&lt;video id="video" src="./demo.mp4"&gt;&lt;/video&gt; 播放控件 123&lt;audio src="./七十里城墙.mp3" controls&gt;&lt;/audio&gt;&lt;video src="./七十里城墙.mp4" controls&gt;&lt;/video&gt; 自动播放 123&lt;audio src="./七十里城墙.mp3" autoplay&gt;&lt;/audio&gt;&lt;video src="./七十里城墙.mp4" autoplay&gt;&lt;/video&gt; 预加载 1234- preload=&quot;none | metadata | auto&quot;- none: 不需要加载数据- metadata: 元数据，诸如时长、比特率、振大小这样的数据，而不是媒体播放需要加载的数据- auto: 浏览器应该当加载它认为适量的媒体内容 123&lt;audio src="./七十里城墙.mp3" controls preload="auto"&gt;&lt;/audio&gt;&lt;video src="./七十里城墙.mp4" controls preload="metadata"&gt;&lt;/video&gt; 循环播放 123&lt;audio src="./七十里城墙.mp3" controls loop&gt;&lt;/audio&gt;&lt;video src="./七十里城墙.mp4" controls loop&gt;&lt;/video&gt; 海报 123&lt;!-- video标签独有 --&gt;&lt;!-- 当视频不能正常加载时，用一张图片作为视频封面海报，否则是空白 --&gt;&lt;video src="./七十里城墙.mp4" controls poster="./封面.jpg"&gt;&lt;/video&gt; tips：因为浏览器和设备的不同，在视频未播放的时候，有些时候能展示第一帧的画面，有些时候就是黑屏，为了保证在任何条件下都可以保证用户都不看到黑屏，通常截取视频第一帧的画面作为视频的海报，这样在播放前显示第一帧画面，点击播放，海报消失开始播放视频 多类型资源 1234567891011&lt;!-- 当 .ogg 格式不能播放时，就使用 .mp3 格式，以此列推 --&gt;&lt;audio controls&gt; &lt;source src="./七十里城墙.ogg" type="audio/ogg" /&gt; &lt;source src="./七十里城墙.mp3" type="audio/mpeg" /&gt;&lt;/audio&gt;&lt;!-- type类型只是为了让浏览器更好的识别当前媒体格式，也可以省略不写 --&gt;&lt;video width="500" height="300" controls&gt; &lt;source src="./七十里城墙.avi" /&gt; &lt;source src="./七十里城墙.mp4" /&gt;&lt;/video&gt; 脚本化获取多媒体元素 123var audio = document.getElementById('audio');var video = document.getElementById('video'); 创建多媒体元素 123456// 这种方法只适用于 audio 标签，没有 video 元素的构造方法var audio = new Audio('./七十里城墙.mp3');// 创建时可以不指定src// var audio = new Audio();// audio.src = './七十里城墙.mp3'; 创建多媒体元素 123var audio = document.createElement('audio');var video = document.createElement('video'); 设置属性 12345678// 两种写法都可以audio.controls = true;audio.controls = 'controls';// 资源url地址 "currentSrc"，注意要配合onload事件使用window.onload = function () &#123; console.log(audio.currentSrc)&#125; 方法 12345678- play() 播放- pause() 暂停- load() 重新加载多媒体元素，用于在更改来源或者其他设置后对多媒体元素进行更新- canPlayType() 检测是否支持指定的媒体格式 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="play"&gt;play&lt;/button&gt; &lt;button id="pause"&gt;stop&lt;/button&gt; &lt;button id="reload"&gt;reload&lt;/button&gt; &lt;script&gt; var audio = new Audio(); if (audio.canPlayType('audio/mp3')) &#123; audio.src = './七十里城墙.mp3'; audio.controls = 'controls'; document.body.appendChild(audio); audio.autoplay = true; play.onclick = function () &#123; audio.play(); &#125; pause.onclick = function () &#123; audio.pause(); &#125; reload.onclick = function () &#123; audio.load(); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 音量属性 123456- volume [0, 1]: 0为静音，1为最大音量（默认） 注意，不在范围内会报错- muted true: 静音 false：取消静音 播放速率属性 12345- playbackRate 1: 正常倍速 (0, 1): 慢速 不能降到太低，浏览器会认为到某一个值时，会影响听觉效果，所以太低就没声音了 &gt; 1: 快速 同理也不能升到太高，原因是一样的 &lt; 0: 可以到放 现在浏览器实现这一功能的很少，所以最好不用 时间属性 1234567- currentTime 设置或返回音频/视频当前播放的位置 单位：秒- duration 返回当前音频/视频的时长 单位：秒 注意：一定要配合 window.onload 事件使用 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;button id="play"&gt;play&lt;/button&gt; &lt;button id="pause"&gt;stop&lt;/button&gt; &lt;button id="reload"&gt;reload&lt;/button&gt; --&gt; &lt;script&gt; var audio = new Audio('./七十里城墙.mp3'); audio.controls = 'controls'; document.body.appendChild(audio); audio.currentTime = 100; console.log(audio.currentTime); window.onload = function () &#123; console.log(audio.duration); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 三个属性(played / buffered / seekable) 123456789101112131415161718- played 已经播放过的时间段 比如音频从0s播放到10s的时候，用户将音频跳转到了20s，10s到20s的内容没有播放，然后从20s，播放到了0s， 那么至此为止，播放过的时间段共有两段，第一段是0s到10s，第二段是20s到30s - buffered 已经缓存过的时间段 同played基本类似，表示缓存过的时间段 - seekable 可以跳转的时间段 比如缓存过的时间段是可以跳转的- TimeRanges - length 时间段的个数，即对象包括多少个时间段 - start(n) 第 n+1 段时间段开始的时间（n从0开始，所以角标0代表第一段，角标n代表第n+1段） - end(n) 第 n+1 段时间段结束的时间（n从0开始，所以角标0代表第一段，角标n代表第n+1段） played、buffered、seekable三个属性均为 TimeRanges 对象，该对象包括一个 length 属性，和两个 start()、end() 方法，属性及方法含义如上 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="playedTest"&gt;测试played&lt;/button&gt; &lt;button id="bufferedTest"&gt;测试buffered&lt;/button&gt; &lt;button id="seekableTest"&gt;测试seekable&lt;/button&gt; &lt;script&gt; var audio = new Audio('./七十里城墙.mp3'); audio.controls = 'controls'; document.body.appendChild(audio); playedTest.onclick = function () &#123; var len = audio.played.length; console.log('一共播放了 ' + len + ' 段音频'); for (var i = 0; i &lt; len; i++) &#123; console.log('第' + (i + 1) + '段：' + audio.played.start(i) + '~' + audio.played.end(i)); &#125; &#125; bufferedTest.onclick = function () &#123; var len = audio.buffered.length; console.log('一共缓存了 ' + len + ' 段音频'); for (var i = 0; i &lt; len; i++) &#123; console.log('第' + (i + 1) + '段：' + audio.buffered.start(i) + '~' + audio.buffered.end(i)); &#125; &#125; seekableTest.onclick = function () &#123; var len = audio.seekable.length; console.log('一共有 ' + len + '段可跳转'); for (var i = 0; i &lt; len; i++) &#123; console.log('第' + (i + 1) + '段：' + audio.seekable.start(i) + '~' + audio.seekable.end(i)); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 查看媒体播放状态 123456- pused true: 表示播放暂停的状态- seeking true: 表示正在调整到一个新的播放点的状态- ended true: 播放完成并且停止的状态 事件 1234567891011121314- play 开始播放触发- pause 暂停播放触发- loadedmetadata 浏览器获取完媒体的元数据触发- loadeddata 浏览器已加载完当前帧数据，准备播放时触发- ended 播放结束后触发（循环播放不算是结束）- error 媒体加载错误时触发- 还有很多事件 http://wiki.jikexueyuan.com/project/html5/events.html 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var audio = new Audio(); if (audio.canPlayType('audio/mp3')) &#123; audio.src = './七十里城墙.mp3'; audio.controls = 'controls'; document.body.appendChild(audio); audio.onplay = function () &#123; console.log('开始播放了!'); &#125; audio.onpause = function () &#123; console.log('暂停了?假装弹出广告'); &#125; audio.onloadedmetadata = function () &#123; console.log('已经获取完了媒体的元数据'); &#125; audio.onloadeddata = function () &#123; console.log('已获取当前数据帧'); &#125; audio.onended = function () &#123; console.log('播放结束了，再看一遍?'); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 错误属性 12345678- error audio.error: 值为null表示正常- error.code audio.error.code 1: 用户终止 2: 网络错误 3: 解码错误 4: URL无效 准备状态 1234567- readyState audio.readyState 0: HAVE_NOTHING 没有关于媒体是否就绪的信息 1: HAVE_METADATA 关于媒体就绪的元数据 2: HAVE_CURRENT_DATA 当前播放位置的数据是可用的，但没有足够的数据来播放下一帧/ms 3: HAVE_FUTURE_DATA 当前及至少下一振的数据是可用的 4: HAVE_ENOUGH_DATA 可用数据足以开始播放 网络状态 123456- networkState audio.networkState 0: NETWORK_EMPTY 媒体尚未初始化 1: NETWORK_IDLE 媒体是活动的且已取资源，但并未使用网络 2: NETWORK_LOADING 浏览器正在下载数据 3: NETWORK_NO_SOURCE 未找到媒体来源]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地理信息、重力感应、方向判断]]></title>
    <url>%2F2018%2F06%2F20%2Fe04_html5%2F</url>
    <content type="text"><![CDATA[window.navigation.geolocationwindow.navigation.geolocation 会返回一个 Geolocation 对象，用来描述地理位置信息，接下来我们来介绍 Geolocation 下的三个方法 123- getCurrentPosition() 获取当前的位置信息- watchPosition() 监视位置变化，参数同 getCurrentPosition- clearWatch() 清除位置监视 getCurrentPosition() 功能 获取当前的位置信息 语法 getCurrentPosition(s, e, p) 参数 s：success回调函数（必填） e：error回调函数 p：options参数 使用 该方法会给成功的回调函数返回一个记录位置信息的参数 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function suc(pos) &#123; console.log(pos); &#125; window.navigator.geolocation.getCurrentPosition(suc, err); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567- latitude: 纬度- longitude: 经度- altitude: 海拔- accuracy: 定位精准度，单位m- altitudeAccuracy: 海拔精准度，单位m- heading: 方向- speed: 速度 该方法会给失败的回调函数返回一个 PositionError对象 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function suc(pos) &#123; console.log(pos); &#125; function err() &#123; console.log('error'); &#125; window.navigator.geolocation.getCurrentPosition(suc, err); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234- 用户拒绝： code = 1- 获取不到： code = 2- 连接超时： code = 3- 描述信息： message options参数：是一个对象，包含以下几个属性 1234- enableHighAccuracy: true 是否需要高精度位置- timeout: NUM 请求超时时间，默认infinite，默认false- maximumAge: 位置信息过期时间，单位ms，默认为0 watchPosition 方法则不停地取用户的地理位置信息，不停地更新用户的 地理位置信息，位置信息过期时间设置为0，就能无条件获取新的地理位置 信息 watchPosition() 功能 监听位置变化；注册监听器，在设备的地理位置发生变化时自动被调用 语法 var id = geolocation.watchPosition(s, e, p) 参数 同 getCurrentLocation() clearWatch() 功能 清除 watchPosition() 设置的位置监听 语法 clearWatch(id) 参数 接收 watchPosition() 方法的变量值 devicemotion 事件 功能 监听设备的加速的变化，比如说手机摇摆的时候，该事件能监听的到手机设备的加速度变化 检测设备的支持能力 12345if (window.DeviceMotionEvent) &#123; window.addEventListener('devicemotion', func, false);&#125; else &#123; alert('本设备不支持devicemotion事件');&#125; devicemotion 事件对象所包含的属性 以下属性均为只读属性 acceleration acceleration指定设备相对于地球在x、y与z轴上的加速状况，可以分别通过其x、y与z属性进行访问，单位必须是m/s2 accelerationIncludingGravity accelerationIncludingGravity与acceleration属性所取的数值相同，但会加上一个加速度相等方向相反的反重力加速度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;shake&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id="xx"&gt;&lt;/h1&gt; &lt;h1 id="yy"&gt;&lt;/h1&gt; &lt;h1 id="zz"&gt;&lt;/h1&gt; &lt;script&gt; if (window.DeviceMotionEvent) &#123; window.addEventListener('devicemotion', devicemotionHandler, false); &#125; else &#123; window.alert('此设备不支持devicemotion事件'); &#125; var SHAKE_THRESHOLD = 800; var x, y, z, lastX = 0, lastY = 0, lastZ = 0; var curTime, diffTime, lastTime = 0; function devicemotionHandler(e) &#123; var acceleration = e.accelerationIncludingGravity; curTime = new Date().getTime(); diffTime = curTime - lastTime; if (diffTime &gt; 300) &#123; lastTime = curTime; x = acceleration.x; y = acceleration.y; z = acceleration.z; var speed = Math.abs(x + y + z - lastX - lastY - lastZ) / diffTime * 10000; if (speed &gt; SHAKE_THRESHOLD) &#123; xx.innerHTML = x; yy.innerHTML = y; zz.innerHTML = z; alert('shaked'); &#125; lastX = x; lastY = y; lastZ = z; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 需要在手机设备端查看测试结果，记得摇一摇 rotationRate 指定设备在各个轴上每秒运动多少度，他有三个属性 alpha、beta、gamma，单位是 deg/s interval 指定不同数据获取数据之间的时间间隔，单位必须是毫秒，并且他是一个常量，一旦设定不能改变 deviceorientation 事件 功能 监听设备在方向上的变化 检测设备的支持能力 12345if (window.DeviceOrientationEvent) &#123; window.addEventListener('deviceorientation', func, false);&#125; else &#123; alert('本设备不支持deviceorientation事件');&#125; 设备方向 deviceorientation 事件包含的属性 alpha：表示设备沿z轴上的旋转角度，范围 [0, 360) beta：表示设备沿x轴上的旋转角度，范围 [-180, 180)，描述设备前后旋转的情况 gamma：表示设备沿y轴上的旋转角度，范围 [-90, 90)，描述设备由左向右的旋转情况 指北针 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;指北针&lt;/title&gt; &lt;style&gt; * &#123; margin: 0px; padding: 0px; list-style: none; &#125; :root, body &#123; width: 100%; height: 100%; background-color: #333; &#125; .wrapper &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 300px; height: 300px; &#125; .wrapper .base-pin &#123; position: absolute; top: -80px; left: 50%; transform: translate(-50%, 0); width: 3px; height: 40px; &#125; .wrapper .base-pin span &#123; display: block; width: 100%; height: 100%; background-color: #fff; &#125; .wrapper .turntable &#123; width: 100%; height: 100%; &#125; .wrapper .turntable ul &#123; width: 100%; height: 100%; transition: transform 0.5s linear; &#125; .wrapper .turntable ul .item &#123; position: absolute; top: 0px; left: 50%; width: 40px; font-size: 0; transform-origin: 20px 179px; &#125; .wrapper .turntable ul .item .num &#123; display: block; width: 100%; height: 30px; text-align: center; line-height: 30px; font-size: 20px; color: #fff; &#125; .wrapper .turntable ul .item .pin &#123; position: absolute; top: 33px; left: 50%; transform: translate(-50%, 0); display: block; width: 3px; height: 25px; background-color: red; &#125; .wrapper .line &#123; position: absolute; top: 50%; left: 50%; margin-left: -100px; margin-top: -100px; width: 200px; height: 200px; &#125; .wrapper .line .across, .parallel &#123; display: block; margin-top: 98px; width: 100%; height: 4px; background-color: #fff; &#125; .wrapper .line .parallel &#123; margin-top: -4px; transform: rotate(90deg); &#125; .wrapper .text &#123; position: absolute; top: 0px; left: 50%; transform: translate(-50%, 360px); width: 200px; height: 30px; &#125; .wrapper .text .direction &#123; display: block; width: 100%; height: 100%; text-align: center; line-height: 30px; font-size: 20px; color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="base-pin"&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="turntable"&gt; &lt;ul class="container"&gt; &lt;li class="item"&gt; &lt;span class="num"&gt;0&lt;/span&gt; &lt;span class="pin"&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;span class="num"&gt;330&lt;/span&gt; &lt;span class="pin"&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;span class="num"&gt;300&lt;/span&gt; &lt;span class="pin"&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;span class="num"&gt;270&lt;/span&gt; &lt;span class="pin"&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;span class="num"&gt;240&lt;/span&gt; &lt;span class="pin"&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;span class="num"&gt;210&lt;/span&gt; &lt;span class="pin"&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;span class="num"&gt;180&lt;/span&gt; &lt;span class="pin"&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;span class="num"&gt;150&lt;/span&gt; &lt;span class="pin"&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;span class="num"&gt;120&lt;/span&gt; &lt;span class="pin"&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;span class="num"&gt;90&lt;/span&gt; &lt;span class="pin"&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;span class="num"&gt;60&lt;/span&gt; &lt;span class="pin"&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="item"&gt; &lt;span class="num"&gt;30&lt;/span&gt; &lt;span class="pin"&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="line"&gt; &lt;span class="across"&gt;&lt;/span&gt; &lt;span class="parallel"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="text"&gt; &lt;span class="direction"&gt;东北35度&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; (function () &#123; if (window.DeviceOrientationEvent) &#123; // 绘制罗盘，将指针旋转至合适的角度 drawTurntable(); // 监听设别方向变化 window.addEventListener('deviceorientation', getAngle, false); &#125; else &#123; window.alert('你的设备不支持deviceorientation'); &#125; // 绘制罗盘 function drawTurntable() &#123; var item = document.getElementsByClassName('item'), len = item.length; for (var i = 0; i &lt; len; i++) &#123; item[i].style.transform = 'translate(-50%, -29px) rotate(' + i * 30 + 'deg)'; &#125; &#125; // 根据设备旋转的角度旋转罗盘 function rotateTurntable(angle) &#123; var container = document.getElementsByClassName('container')[0]; container.style.transform = 'rotate(' + angle + 'deg)'; &#125; // 将描述方向的文本填入dom结构 function addDirec(text) &#123; var direction = document.getElementsByClassName('direction')[0]; direction.innerText = text; &#125; // 获取设备旋转角 function getAngle(e) &#123; var angle = e.alpha; if (angle != null) &#123; // 计算旋转角所对应的方向 var direc = Math.round(Math.round(angle / 45) + 7) % 8; var direcText = ['东南', '东', '东北', '北', '西北', '西', '西南', '南']; rotateTurntable(angle - 180); addDirec(direcText[direc]); &#125; else &#123; window.alert('你的设备不支持deviceorientation'); &#125; &#125; &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时器优化、客户端存储、history、worker]]></title>
    <url>%2F2018%2F06%2F19%2Fe03_html5%2F</url>
    <content type="text"><![CDATA[requestAniamtionFramesetInterval 做动画的缺点 动画延迟执行 js是单线程的，当某一个进程在排队期间，插入了其他执行时间过长的进程，会导致原排队进程延迟执行 延迟不准确 如果把动画延迟时间设置太长了，则会感觉到动画卡顿，那就设置延迟短一点，但是实际执行的延迟不是我们设置的准确的延迟，因为要把计时器放到异步执行当中，再放到异步执行当中，然后主线程访问看拿哪个计时器；所以即使设置了0ms的响应时间，也不会立即执行，还是会有一个大概4ms的延迟 丢帧问题 我们能看到的动画是由一帧一帧的静态效果所连成的，比我们使用setInterval方法让一个物体每隔4ms动一次，即每隔4ms都是新的一帧，但是浏览器大概是每隔16ms才刷新一次，浏览器不刷新我们也就看不到帧的变化，这部分我们看不到的效果就叫做丢帧，设置的延迟时间越小，丢帧越多，但是设置的延迟时间大了又会造成视觉卡顿，比较合理的时间是浏览器的刷新周期，前面说了浏览器大概16ms刷新一次，但是也只是大概的时间，并不是说准确的就是16ms，所以如果使用setInterval，那么把延迟时间设置成16ms比较合理，但也不是最好的方法 requestAnimationFrame 页面刷新前执行一次 1000ms 60fps -&gt; 16ms 用法类似于setTimeout，而不是setInterval cancelAnimationFrame 取消 兼容性（IE10以上） 在不能使用这个方法的浏览器中，还是要用setTimeout方法 12345678910111213141516171819// 设置的兼容性写法window.requestAnimationFrame = (function () &#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) &#123; window.setTimeout(callback, 1000 / 60); &#125;&#125;)();// 取消的兼容性写法window.cancelAnimationFrame = (function () &#123; return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function (id) &#123; window.clearTimeout(id); &#125;&#125;)(); 使用实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box &#123; position: absolute; top: 0px; left: 0px; width: 100px; height: 100px; background-color: deepskyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; window.requestAnimationFrame = (function () &#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) &#123; window.setTimeout(callback, 1000 / 60); &#125; &#125;)(); window.cancelAnimationFrame = (function () &#123; return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function (id) &#123; window.clearTimeout(id); &#125; &#125;)(); var req; function move() &#123; if (box.offsetLeft &gt;= 300) &#123; window.cancelAnimationFrame(req); box.style.left = '300px'; &#125; else &#123; box.style.left = box.offsetLeft + 10 + 'px'; req = window.requestAnimationFrame(move); &#125; &#125; move(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 客户端存储storage简介之前介绍过利用cookie实现客户端存储，但是cookie有一些限制、不足： 使用cookie要在http请求头中设置字段，服务器接收到请求后，在响应头中返回相应的信息，所以cookie是随着http传输的，会浪费一些宽带 有路径的限制 cookie只能存储少量的数据 现在介绍另一中客户端存储技术 storage，不需要通过http传输，可以存储大量的数据 特性 cookie localStorage sessionStorage 数据的生命周期 一般有服务器生成，可设置失效时间。如果在浏览器端生成cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 尽在当前会话下有效，关闭页面或者浏览器后被清除 存放数据大小 4k左右 一般为5MB 同localStorage 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 尽在客户端（即浏览器）中保存，不参与和服务器的通信 同localStorage 易用性 需要程序员自己封装，原生的cookie接口不友好 原生接口可以接受，亦可再次封装来对Object 和 Array有更友好的支持 同localStorage 分类 localstorage 永久存储 sessionStorage 临时存储 属性方法查看storage 12345- 1.直接打开控制台，在 application -&gt; localStorage / sessionStorage / files 下查看- 2.window.localStorage / window.sessionStorage注： localStorage / sessionStorage 是window上的属性，cookie是document上的属性 存储数据 123456// 存储的数据必须是字符串格式localStorage.name = 'qht';localStorage.info = JSON.stringify(&#123;"name": "qht", "age": 20&#125;);sessionStorage.name = 'qht';sessionStorage.info = JSON.stringify(&#123;"name": "qht", "age": 20&#125;); 取出数据 12345localStorage.namelocalStorage.infosessionStorage.namesessionStorage.info 查看数据个数 123localStorage.lengthsessionStorage.length 存取的有效期 12- localStorage： 永久的，除非手动删除- sessionStorage：临时的，窗口关闭就没有了 作用域 12- localStorage: 受文档源限制（同源）- sessionStorage：受文档源限制（同源）+ 受窗口限制 API 12345678910// 设置属性localStorage.setItem(name, value)// 获取属性值localStorage.getItem(name)// 移除属性值localStorage.removeItem(name);// 清除所有属性localStorage.clear();// sessionStorage的使用方法一样 history概述window.history 指向 history 对象，表示浏览器当前窗口的浏览历史；history对象保存了当前窗口访问过的所有页面地址，可以通过前进/后退操作或者history的方法来前进/后退到后/前一个网址，出于安全性的考虑，我们只能通过前进后退操作进行导航，但是不能获取这些历史网页的地址 属性 history.length history.state length获得浏览器当前窗口历史记录的条数 1history.length; statehistory堆栈最上层的状态值 1history.state 方法 html中的方法 history.back() history.forward() history.go() html5新增的方法 history.pushState() history.replaceState() back()回退到上一条历史记录对应的页面，相当于浏览器后退按钮的作用 1history.back(); forward()前进到下一条历史记录对应的页面，相当于浏览器前进按钮的作用 1history.forward(); go()跳转到历史记录中相对于当前页面的前/后 n 个页面 12345history.go(n);// 举例:// history.go(0) 跳转到当前页面，相当于刷新操作// history.go(1) 跳转到当前页面的下一个页面// history.go(-1) 跳转到当前页面的上一个页面 通过以上三个方法，浏览器跳转到某个页面，页面通常是从浏览器缓存中加载的，而不是重新向服务器发送请求 pushState() 功能 在当前历史记录中，添加一条新的记录 语法 1history.pushState(state, title, url); 参数 state 一个对象或者字符串，用于描述新纪录的一些特性，由开发者自由给出，以便后续使用(主要用于 popstate 事件，该事件触发时，该参数被传入回调函数，浏览器会将这个参数序列化之后保存在本地，重新载入这个页面的时候，可以拿到这个参数) title 新页面的标题，现在所有的浏览器都会忽略这个参数，所以一般传 null 即可 url 新页面的地址，与当前页面要在同一个域下 强调 该方法受同源策略的限制 新添加的记录的地址要和当前页面在同一个域下 使用该方法后，浏览器地址栏会立即显示新添加的地址 浏览器的历史记录可以看做一个栈，前进操作或者打开新的网页或者添加新的历史记录，新的网址入栈；后退操作会使最上面的记录出栈，而浏览器向用户展示的是栈顶的记录，所以，使用了这个方法添加了一条新的记录后，栈顶记录就成了新的网址，浏览器的地址栏就会显示这个网址 使用该方法不会刷新网页 使用这个方法可以是地址栏显示新的地址，但是却不会刷新当前的页面，也就是说在使用js添加了一条新的历史记录后，只有地址栏会产生变化（显示新的地址），页面还是显示当前的页面，不会进行刷新 举例 样例1：展示整个过程 我们在服务器中创建一个 “history-pushState” 文件夹作为测试文件夹，在此文件夹中创建两个文件 “currentPage.html” 和 “newPage”，分别代表当前页面和新的页面，我们要做的就是在当前页面中把新的页面添加到历史记录中，为了区别当前页面和新页面，在两个页面中写入了不同的文字 1234567891011121314151617&lt;!-- currentPage.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;currentPage&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- currentPage 页面中显示的内容 --&gt; &lt;h3&gt;This is currentPage!&lt;/h3&gt; &lt;script&gt; // 添加新的记录 history.pushState(null, null, './newPage.html'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011&lt;!-- newPage.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;newPage&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;This is newPage!&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 接下类，为了能看清楚当前页面在执行了 pushState() 方法后有哪些变化，我们通过输入 “currentPage.html” 的地址来打开这个页面 可以看到，我们输入地址是 “currentPage.html” 的地址，按下回车后，地址栏却变成了 “newPage.html” 的地址，这是因为我们在 “currentPage.html” 页面中使用 pushState() 方法添加了一条新的历史记录，这条记录的地址就是 “newPage.html” 页面的地址，所以地址栏会立即变成当前新记录的地址；不过虽然地址栏变成了新纪录的地址，但显示的还是 “currentPage.html” 的页面，这因为使用 pushState() 方法不执行刷新操作，即便地址栏已经改成了新页面的地址，但如果我们不进行手动刷新，它依然会显示当前的页面 样例2：读取 history.state 状态属性 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;currentPage&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- currentPage 页面中显示的内容 --&gt; &lt;h3&gt;This is currentPage!&lt;/h3&gt; &lt;script&gt; // 添加新的记录 history.pushState(&#123;name: 'new'&#125;, null, './newPage.html'); // 读取状态属性 console.log(history.state); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 样例3：禁止添加跨域站点 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;currentPage&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- currentPage 页面中显示的内容 --&gt; &lt;h3&gt;This is currentPage!&lt;/h3&gt; &lt;script&gt; // 添加跨域的新记录 history.pushState(null, null, 'https://www.baidu.com'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 样例4：”query string” 形式的url 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;currentPage&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- currentPage 页面中显示的内容 --&gt; &lt;h3&gt;This is currentPage!&lt;/h3&gt; &lt;script&gt; history.pushState(null, null, './newPage.html?page=newPage'); // 如果只写查询字符串，则会被拼接到当前页面url后面 // history.pushState(null, null, '?page=currentPage'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; replaceState() 功能 修改history对象当前记录 语法 1history.repalceState(state, title, url); 参数 同 pushState 强调 同 pushState popstate 事件 触发条件 同一个文档的浏览历史(即 history 对象)发生变化时，该事件被触发 注意 pushState() 和 replaceState() 方法不会触发该事件 点击浏览器的前进 / 后退按钮、JS调用 history.back()、history.forward()、history.go()等方法可以触发该事件 该事件只针对同一个文档，如果浏览器历史的切换导致加载了不同的文档，该事件不会触发 页面第一次加载的时候，不会触发该事件 event.state 该事件的事件对象的属性 event.state 指向 pushState() 、replaceState() 方法为当前URL提供的状态对象（即这两个方法的第一个参数 state），这个 state 对象也可以通过 history.state 方法直接获取，但获取的条件和 popstate 事件触发的条件相同 举例 样例1：同一个文档 1234567891011121314151617181920&lt;!-- currentPage.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;currentPage&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;This is currentPage!&lt;/h3&gt; &lt;script&gt; history.pushState(&#123;name: 'current'&#125;, null, '?page=currentPage'); window.onpopstate = function (e) &#123; console.log(e); console.log(e.state); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 以上代码意思是当 popstate 事件触发时，打印事件对象 event 即 状态属性 event.state，当我们在浏览器中打开这个页面时，地址栏地址显示 http://localhost/test/history-pushState/currentPage.html?page=currentPage，此时控制台没有任何输出，因为还没有历史记录变化触发 popstate 事件；我们点击浏览器的回退按钮，此时浏览器地址栏显示 http://localhost/test/history-pushState/currentPage.html，控制台打印结果如下 首先有东西打印出来，说明刚才的回退操作造成了历史记录变化，触发了 popstate 事件，所以才会执行 popstate 事件的回调函数；下面我们来关注打印内容的第二个值 event.state ，它的值是 null ，明明我们在使用 pushState() 方法时，第一个参数设置了 {name: &#39;current&#39;} ，为什么这里是 null 呢？别急，接下来，我们再点击浏览器的前进按钮，地址栏显示 http://localhost/test/history-pushState/currentPage.html?page=currentPage，控制台又增加了两条打印内容，结果如下 有打印内容说明出发了 popstate 事件这个就不再多说了，继续来关注第二个打印内容 event.state ，这次它的值变成了我们给他设置的值，结合地址栏中不同的url，发现在 http://localhost/test/history-pushState/currentPage.html 这个地址下，event.state 结果为 null，而在 http://localhost/test/history-pushState/currentPage.html?page=currentPage这个地址下，event.state 结果为 {name: &#39;current&#39;}，这是因为我们在使用 pushState() 方法的时候，参数是这样设置的 pushState({name: &quot;current&quot;}, null, &#39;?page=currentPage&#39;)，关注第一个和第三个参数，我们把state状态传给了 http://localhost/test/history-pushState/currentPage.html?page=currentPage 这个地址的页面，所以只有在这个地址页面下，才能打印我们设置的state 样例2：不同文档 1234567891011121314151617181920&lt;!-- currentPage.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;currentPage&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;This is currentPage!&lt;/h3&gt; &lt;script&gt; history.pushState(&#123;name: 'current'&#125;, null, '?page=currentPage'); window.onpopstate = function (e) &#123; console.log(e); console.log(e.state); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 与上一个样例一样的代码，操作的步骤有所不同，首先打开一个新标签页（新标签页是为了保证历史记录的干净），然后在地址栏中输入 https://www.baidu.com，回车打开百度页面，打开后将地址栏中百度的url删除，输入 http://localhost/test/history-pushState/currentPage.html ，回车打开页面，此时地址栏中显示的是 http://localhost/test/history-pushState/currentPage.html?page=currentPage，我们点击浏览器的回退按钮，地址回退到 http://localhost/test/history-pushState/currentPage.html，此时控制台中有打印内容，这个过程上面一个样例已经解释清楚，接下来我们继续点击回退按钮，使地址回退到 https://www.baidu.com，这时控制台没有任何打印内容，因为历史记录变化的过程中加载百度页面，这与我们的 “currentPage.html” 是不同的文档，所以不会触发 popState 事件 pjaxpushState + ajax的应用 如果我们要做一个单页应用，简单地说我们要是实现的内容是通过ajax请求获得实现的，而不是通过页面跳转的其他页面显示内容实现的；但是仅仅通过ajax实现单页应用也有一定的限制，因为ajax是局部刷新而不刷新整个页面，这也就意味着我们虽然可以通过点击不同的标签显示不同的内容，但是因为过程种地址栏中的url没有发生变化导致我们无法通过前进或者是后退操作访问我们已经访问过的内容，这样对用户的习惯很不友好，而 history API 正好可以弥补这一缺陷，它只改变地址栏而不刷新页面的特性，使我们能够轻松的修改url，模拟出多页面的效果，实现前进或者后退的导航 下面做一个简单的例子来描述整个过程 功能演示 index.html 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;pajx&lt;/title&gt; &lt;link rel="stylesheet" href="./index.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="header"&gt; &lt;button class="btn" name="one"&gt;one&lt;/button&gt; &lt;button class="btn" name="two"&gt;two&lt;/button&gt; &lt;button class="btn" name="three"&gt;three&lt;/button&gt; &lt;/div&gt; &lt;div class="content"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src="./ajax.js"&gt;&lt;/script&gt; &lt;script src="./index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.css 123456789101112131415161718192021222324252627.wrapper &#123; width: 450px; height: 300px; border: 1px solid #000;&#125;.wrapper .header &#123; display: flex; width: 100%; height: 100px;&#125;.wrapper .header .btn &#123; width: 33.3%; height: 100%; box-sizing: content-box; border: 1px solid #000; outline: none; cursor: pointer;&#125;.wrapper .content &#123; width: 100%; height: 200px; text-align: center; line-height: 200px;&#125; getDate.php 1234567891011121314&lt;?phpheader('content-type:text/html;charset="utf-8"');error_reporting(0);$page = $_GET['page'];if ($page == 'one') &#123; $data = 'This is page one';&#125; else if ($page == 'two') &#123; $data = 'This is page two';&#125; else if ($page == 'three') &#123; $data = 'This is page three';&#125;echo "$data"; ajax.js 12345678910111213141516171819function ajax(method, url, data, flag, callback) &#123; method = method.toUpperCase(); var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHttp'); if (method == 'GET') &#123; xhr.open('GET', url + '?' + data, flag); xhr.send(); &#125; else if (method == 'POST') &#123; xhr.open('POST', url, flag); xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); xhr.send(data); &#125; xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; callback(xhr.responseText); &#125; &#125;;&#125; index.js 1234567891011121314151617181920212223242526272829303132333435363738394041var header = document.getElementsByClassName('header')[0], content = document.getElementsByClassName('content')[0];// 页面第一次加载默认显示第一个页的内容function init() &#123; var data = 'page=one'; ajax('GET', './getData.php', data, true, sovle); history.replaceState(&#123; dataFlag: data &#125;, null, '?' + data);&#125;init();// 绑定点击事件，点击不同的按钮，发送不同的ajax请求header.onclick = function (e) &#123; var event = e || window.event, target = event.target || event.srcElement, data; data = 'page=' + target.getAttribute('name'); ajax('GET', './getData.php', data, true, sovle); // 发送ajax请求后，在当前页面的url后拼接不同的页面标记 history.pushState(&#123; dataFlag: data &#125;, null, '?' + data);&#125;// ajax请求成功的回调函数function sovle(data) &#123; // 调用添加文本的方法 addContent(data);&#125;// 将ajax响应数据添加到dom结构中function addContent(data) &#123; content.innerText = data;&#125;// 每当有state的变化(导航操作)，重新发送ajax请求，获得当前页面标记对应的数据window.onpopstate = function (e) &#123; var event = e || window.event, data = event.state.dataFlag || 'page=one'; ajax('GET', './getData.php', data, true, sovle);&#125; 主要是index.js文件中的内容 worker我们都知道JavaScript是由一个主线程单线程执行的，这样的机制会有一些问题，如果在他执行的过程中，某一个方法需要大量大计算，那这个方法就会占用主线程很多的时间，性能不好，所以我们可不可以单独开辟一个线程，去处理这些非常耗时的操作呢？ 方法 使用worker创建子线程 语法 12var worker = new Worker('worker.js');// 主线程所在的文件和子线程worker所在的文件要满足同源策略 worker和主线程之间的通信 postMessage() 方法 用于主线程和子线程之间的消息传递 message 事件 用于监听主线程和子线程之间的消息传递 结束worker线程 close() 方法 在worker的作用域中调用，来结束自己（相当于辞职） terminate() 方法 在主线程的作用域中调用，来结束worker线程（相当于解雇） 一般使用第二种方法比较好 其他特性 importScripts(‘./math1.js’, ‘./math2.js’) worker 是window的子集，只能实现部分功能，不能获取到window、document，所以也就不能使用jQuery、zepto等类库，通常都是引入一些计算行的类库进行运算 navigator 可以使用navigator对象的某些属性方法，不是全部 XMLHttpRequest 可以发送ajax请求 setTimeout / setInterval 可以使用定时器、计时器 demo 简单的使用范例，这里以平方运算为例（假装平方运算是高计算量的运算，hh~） index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;worker&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="./worker.js"&gt;&lt;/script&gt; &lt;script src="./main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; main.js 12345678var data = 10;var worker = new Worker('worker.js');worker.postMessage(data);worker.onmessage = function (e) &#123; console.log(e.data);&#125; worker.js 1234onmessage = function (e) &#123; var res = e.data * e.data; this.postMessage(res);&#125; canvas图片处理的样例 index.html 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; button &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;img src=""&gt; &lt;button&gt;start&lt;/button&gt; &lt;script src="./worker.js"&gt;&lt;/script&gt; &lt;script src="./main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; main.js 12345678910111213141516171819202122232425262728293031323334var oImg = new Image();oImg.src = './xiaohei.png';oImg.onload = function () &#123; var canvas = document.getElementById('myCanvas'), canvasWidth = canvas.width, canvasHeight = canvas.height; var worker = new Worker('worker.js'); var btn = document.getElementsByTagName('button')[0]; btn.onclick = function () &#123; sovle(); &#125; function sovle() &#123; if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); var imageData; ctx.drawImage(oImg, 0, 0, canvasWidth, canvasHeight); imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight); worker.postMessage(imageData); worker.onmessage = function (e) &#123; ctx.putImageData(e.data, 0, 0); var url = canvas.toDataURL('image/jpeg', 0.5); document.getElementsByTagName('img')[0].src = url; worker.terminate(); &#125; &#125; &#125;&#125; worker.js 123456789101112131415161718onmessage = function (e) &#123; var imageData = e.data, imageDataLen; imageDataLen = imageData.data.length / 4; for (var i = 0; i &lt; imageDataLen; i++) &#123; var red = imageData.data[i * 4]; var green = imageData.data[i * 4 + 1]; var blue = imageData.data[i * 4 + 2]; var gray = 0.3 * red + 0.59 * green + 0.11 * blue; imageData.data[i * 4] = gray; imageData.data[i * 4 + 1] = gray; imageData.data[i * 4 + 2] = gray; &#125; postMessage(imageData);&#125; 第二次点击start没有对图片进行处理是因为子第一遍处理完毕后，主线程关闭了worker线程，所以后面无法对图形进行处理]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG详细总结]]></title>
    <url>%2F2018%2F06%2F19%2Fe02_html5%2F</url>
    <content type="text"><![CDATA[引入SVG是什么123456- SVG 指可伸缩矢量图形 (Scalable Vector Graphics)- SVG 用来定义用于网络的基于矢量的图形- SVG 使用 XML 格式定义图形- SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失- SVG 是万维网联盟的标准- SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体 SVG 和 canvas 的区别 canvas svg 依赖分辨率（位图） 不依赖分辨率（矢量图） 单个HTML元素 每一个图形都是一个DOM元素 只能通过脚本绘制图形 可以通过css也可以通过脚本绘制图形 不支持事件处理程序 支持事件处理程序 弱的文本渲染能力 最适合带有大型渲染区域的应用程序（比如谷歌地图） 图面较小，对象数量较大（&gt;10k）时性能较佳 对象数量较小（&lt;10k）、图片更大时性能较佳 svg 本质上是一种使用 XML 描述 2D 图形的语言。 svg 创建的每一个元素都是一个独立的 DOM 元素，既然是独立的 DOM 元素，那么我们就可以通过 css 和 JavaScript 来操控 dom，可以对每一个 DOM 元素进行监听，并且因为每一个元素都是一个 DOM 元素，所以修改 svg 中的 DOM 元素，系统会自动进行 DOM 重绘。 Canvas 通过 JavaScript 来绘制 2D 图形，Canvas 只是一个 HTML 元素，其中的图形不会单独创建 DOM 元素。因此我们不能通过 JavaScript 操控 Canvas 内单独的图形，不能对其中的具体图形进行监控。 在 Canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象 实际上 Canvas 是基于像素的即时模式图形系统，绘制完对象后不保存对象到内存中，当再次需要这个对象时，需要重新绘制；svg 是基于形状的保留模式图形系统，绘制完对象后会将其保存在内存中，当需要修改这个对象信息时，直接修改就可以了。这种根本的区别导致了很多应用场景的不同. 应用场景 https://zhuanlan.zhihu.com/p/33093211 使用方法 创建 svg 根标签，并声明命名空间 123&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;&lt;/svg&gt; 设置svg元素的大小 三种方法（属性设置，css设置，JS设置效果相同），默认大小是300 * 150 1234&lt;!-- 属性设置 --&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300"&gt;&lt;/svg&gt; 1234&lt;!-- css设置 --&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="width: 500px;height: 300px"&gt;&lt;/svg&gt; 12345678&lt;!-- JS设置 --&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;&lt;/svg&gt;&lt;script&gt; document.getElementsByTagName('svg')[0].style.width = '500px'; document.getElementsByTagName('svg')[0].style.height = '300px';&lt;/script&gt; 在 &lt;svg&gt; 标签下，添加图形元素 svg中的图形使用标签定义的，根据需要将合适的标签填入 &lt;svg&gt;标签下，svg中的图形元素有很多，这里只简单的举个例子 123&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300"&gt; &lt;rect x="100" y="100" width="200" height="100"&gt;&lt;/rect&gt;&lt;/svg&gt; 绘制图形总览再开始绘制图形之前，我们先来了解一下有哪些基本图形，以及他们是怎么定义的，属性该怎样设置，为后续的介绍做铺垫 基本图形123456- rect 矩形- circle 圆形- ellipse 椭圆形- line 直线- polyline 折线- polygon 多边形 html属性(或css属性)(常用)1234567891011- stroke 边框颜色- stroke-width 边框宽度- stroke-opacity 边框透明度- stroke-dasharray 虚线边框- stroke-dashoffset 缩进- stroke-linecap 线段两边样式- stroke-linejoin 线段连接处的样式- fill 填充颜色- fill-opacity 填充透明度- transform 变形- filter 滤镜 图形定义的方法123&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300"&gt; &lt;rect x="100" y="100" width="200" height="100"&gt;&lt;/rect&gt;&lt;/svg&gt; 在 &lt;svg&gt;根标签下定义图形元素，并设置该图形对应的必须的属性值（如这里的x、y、width、height，不同图形对应不同的属性，后面详细给出） html属性（或css属性）设置方法这里讲的属性不同于图形定义中提到的属性，这里要设置的是图形的样式属性（如颜色，宽度等），他可能不是必须的，有两种设置方法 在html属性中设置 123&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300"&gt; &lt;rect x="100" y="100" width="200" height="100" fill="orange"&gt;&lt;/rect&gt;&lt;/svg&gt; 在css样式中设置 123&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300"&gt; &lt;rect x="100" y="100" width="200" height="100" style="fill: orange"&gt;&lt;/rect&gt;&lt;/svg&gt; 这为了设置方便，使用了行间css 基本图形用法为了方便起见，下面的讲解不再列出根标签 &lt;svg&gt;，但是要知道这时必须的 矩形基本用法 12&lt;rect x="100" y="100" width="200" height="100"&gt;&lt;/rect&gt;&lt;!-- (x, y)：矩形左上角顶点坐标 width：矩形宽度 height：矩形高度 --&gt; 设置样式 12&lt;rect x="100" y="100" width="200" height="100" stroke="red" stroke-width="5px" stroke-opacity="0.5" fill="green" fill-opacity="0.5"&gt;&lt;/rect&gt; 12&lt;rect x="100" y="100" width="200" height="100" style="stroke: red;stroke-width: 5px;stroke-opacity: 0.5;fill: green;fill-opacity: 0.5"&gt;&lt;/rect&gt; 直线基本用法 12&lt;line x1="100" y1="100" x2="200" y2="200"&gt;&lt;/line&gt;&lt;!-- (x1, y1)：直线起点坐标 (x2, y2)：直线终点坐标 --&gt; 设置样式 123&lt;line x1="100" y1="100" x2="200" y2="200" stroke="red" stroke-width="5px" stroke-opacity="0.5"&gt;&lt;/line&gt;&lt;!-- 直线要在描边（stroke）以后才会显示出来 --&gt; 12&lt;line x1="100" y1="100" x2="200" y2="200" style="stroke: red; stroke-width: 5px;stroke-opacity: 0.5;"&gt;&lt;/line&gt; 圆形基本用法 12&lt;circle cx="250" cy="150" r="100"&gt;&lt;/circle&gt;&lt;!-- (cx, cy)：圆形的坐标 r：半径 --&gt; 设置样式 12&lt;circle cx="250" cy="150" r="100" stroke="red" stroke-width="5px" stroke-opacity="0.5" fill="green" fill-opacity="0.5"&gt;&lt;/circle&gt; 12&lt;circle cx="250" cy="150" r="100" style="stroke: red;stroke-width: 5px;stroke-opacity: 0.5;fill: green;fill-opacity: 0.5"&gt;&lt;/circle&gt; 椭圆基本用法 12&lt;ellipse cx="250" cy="150" rx="100" ry="50"&gt;&lt;/ellipse&gt;&lt;!-- (cx, cy)：圆心坐标 rx：x轴上的半径 ry：y轴上上的半径 --&gt; 设置样式 12&lt;ellipse cx="250" cy="150" rx="100" ry="50" stroke="red" stroke-width="5px" stroke-opacity="0.5" fill="green" fill-opacity="0.5"&gt;&lt;/ellipse&gt; 12&lt;ellipse cx="250" cy="150" rx="100" ry="50" style="stroke: red;stroke-width: 5px;stroke-opacity: 0.5;fill: green;fill-opacity: 0.5;"&gt;&lt;/ellipse&gt; 折线基本用法 123&lt;polyline points="50 50, 80 50, 80 80, 110 80, 110 110, 140 110, 140 140"&gt;&lt;/polyline&gt;&lt;!-- points：折线上点的坐标 --&gt;&lt;!-- 逗号不是必须的，但是建议写，这样便于区分不同的点 --&gt; 设置样式 1234&lt;polyline points="50 50, 80 50, 80 80, 110 80, 110 110, 140 110, 140 140" stroke="red" stroke-width="5px" stroke-opacity="0.5" fill="transparent"&gt;&lt;/polyline&gt;&lt;!-- 因为图形默认是填充为黑色，所以这里把填充颜色设置成透明色，以便看到折线的效果 --&gt;&lt;!-- 也可以将fill设置为none --&gt; 12&lt;polyline points="50 50, 80 50, 80 80, 110 80, 110 110, 140 110, 140 140" style="stroke: red;stroke-width: 5px;stroke-opacity: 0.5;fill: none;"&gt;&lt;/polyline&gt; 多边形基本用法 12&lt;polygon points="50 50, 80 50, 80 80, 110 80, 110 110, 140 110, 140 140"&gt;&lt;/polygon&gt;&lt;!-- points：多边形的顶点 --&gt; 设置样式 12&lt;polygon points="50 50, 80 50, 80 80, 110 80, 110 110, 140 110, 140 140" stroke="red" stroke-width="2px" fill="green" fill-opacity="0.5"&gt;&lt;/polygon&gt; 12&lt;polygon points="50 50, 80 50, 80 80, 110 80, 110 110, 140 110, 140 140" style="stroke:red; stroke-width: 2px;fill: green;"&gt;&lt;/polygon&gt; path简介路径也是用来绘制图形的，与基本图形相比，path具有更加强大的能力，使用一系列命令来实现画图操作 基本语法1&lt;path d="" /&gt; 引号中的部分填写命令 命令 命令 参数 功能 M (x, y) 移动到 L (x, y) 画直线到 H x 画水平线到 V y 画竖直线到 Z 无 关闭路径 Q (x1, y1, x, y) 画二次贝塞尔曲线到 T (x, y) 画光滑二次贝塞尔曲线到 C (x1, y1, x2, y2, x, y) 画三次贝塞尔曲线到 S (x2, y2, x, y) 画光滑三次贝塞尔曲线到 A (rx ry x-axis-rotation large-arc-flag sweep-flag x y) 圆弧 备注：指令是区分大小写的，大写命令表示绝对位置，小写命令表示相对位置，Z指令不区分大小写 1234567M 100 100 L 200 100// M：起始点移动到(100, 100)// L：画直线到(100, 100)m 100 100 l 200 100// m：起始点相对上一个点，向x轴正方向移动了100，向y轴正方向移动了100，如果没有上一个点，则默认为(0, 0)// l：相对于上一个点，向x轴正方向增加了100，y轴正方向增加了100的点画直线 1&lt;path d="M 100 100 L 200 100 z" stroke="#000" /&gt; 1&lt;path d="m 100 100 l 200 100 z" stroke="#000" /&gt; 示例二次贝塞尔曲线 123456&lt;path d="M 50 100 Q 125 300 200 100" stroke="#000" fill="none" /&gt;&lt;!-- Q x1 y1 x y (x1, y1)：控制点坐标 (x, y)：终止点坐标--&gt; 光滑二次贝塞尔曲线 123456789&lt;path d="M 50 100 Q 125 300 200 100 T 375 100" stroke="#000" fill="none" /&gt;&lt;!-- T：x y (x, y): 新结束点坐标 整个过程是：Q 命令控制点(x1, y1) 以 Q 命令结束点 (x, y) 为对称点 做对称点 (x', y')，以 Q 命令结束点 (x, y) 为起始点， 对称点 (x', y') 为控制点，T 命令结束点 (x, y) 为结束点 三点再做一条二次贝塞尔曲线，以此绘成整条光滑二次贝塞尔曲线--&gt; 三次贝塞尔曲线 1234567&lt;path d="M 50 100 C 100 200 150 100 200 200" stroke="#000" fill="none" /&gt;&lt;!-- C x1 y1 x2 y2 x y (x1, y1): 控制点1 (x2, y2): 控制点2 (x, y): 结束点--&gt; 12345678910&lt;path d="M 50 100 C 100 200 150 100 200 200 S 250 100 300 200" stroke="#000" fill="none" /&gt;&lt;!-- S x2 y2 x y (x2, y2): 新控制点2 (x, y): 新结束点 整个过程是：Q 命令控制点 (x2, y2) 以 Q 命令结束点 (x, y) 为对称点做对称点 (x', y'), 以 Q 命令结束点 (x,y) 为起始点，对称点 (x', y') 为控制点1，T 命令控制点 (x2, y2) 为控制点2，T 命令结束点 (x, y) 为结束点，四点再做一条三次贝塞尔 曲线，以此绘成整条光滑三次贝塞尔曲线--&gt; 圆弧 12345678910&lt;path d="M 100 100 A 70 120 90 1 1 150 200" stroke="#000" fill="none" /&gt;&lt;!-- A rx ry x-deg large-arc sweep-flag x y rx: x轴上半径 ry：y轴上半径 x-deg：x轴旋转角度 large-arc：圆弧的角度大于还是小于180度(0表示小于，1表示大于) sweep-flag：表示弧线方向(0沿逆时针，1沿顺时针) (x, y): 终点坐标--&gt; 因为(椭)圆弧参数较多，所以这里再附一张图讲解一下参数 图中共有四条弧线，分别标号为1、2、3、4，设A为起始点，B为终止点，且x轴方向没有旋转，则 弧线1：顺时针(sweep-flag=1)大弧(large-arc=1) 弧线2：顺时针(sweep-flag=1)小弧(large-arc=0) 弧线3：逆时针(sweep-flag=0)小弧(large-arc=0) 弧线4：逆时针(sweep-flag=0)大弧(large-arc=1) 其他属性如半径、终点坐标等很好理解 文本基本用法12345&lt;text x="250" y="150"&gt;Hello World!&lt;/text&gt;&lt;!-- x: 文本最左侧在坐标系中的坐标 y: 文本的baseline在坐标系中的坐标--&gt; 对齐text-anchor 12345&lt;path d="M 200 10 200 200" style="stroke: gray; fill: none;" /&gt;&lt;text x="200" y="30" style="text-anchor: start"&gt;Start&lt;/text&gt;&lt;text x="200" y="90" style="text-anchor: middle"&gt;Middle&lt;/text&gt;&lt;text x="200" y="150" style="text-anchor: end"&gt;End&lt;/text&gt;&lt;!-- text-anchor 属性可以设置文本竖直轴线的位置 --&gt; tspan12345&lt;text x="200" y="150" text-anchor="middle"&gt; Hello &lt;tspan fill="none" stroke="deeppink" font-size="20px"&gt;World!&lt;/tspan&gt;&lt;/text&gt;&lt;!-- &lt;tspan&gt;&lt;/span&gt;用来包裹文本中样式不同的部分 --&gt; dx、dydx、dy可以设置文本中每一个字符相对于自身在x轴方向和在y轴方向上的偏移量，默认是0 1234&lt;text x="200" y="150" text-anchor="middle"&gt; Hello &lt;tspan fill="none" stroke="deeppink" font-size="20px" dx="10" dy="-5"&gt;World!&lt;/tspan&gt;&lt;/text&gt; 上面的代码给 “World1” 文本的第一个字符设置了x轴和y轴方向上的偏移量，现在以dy为例讨论下面的问题，即代码中 dy=&quot;-5&quot; 说明只给 “World!” 文本的第一个字符 ‘W’ 设置了偏移量，其他的字符没有设置偏移量默认是0，那么怎么 “World!” 中所有的字符都跟着一起偏移了呢，原因是文本中的字符默认会与前一个字符保持对齐，所以只设置了第一个字符的偏移量，那么后面的字符会默认与前一个元素保持对齐，想要达到不同偏移量的效果，要给每个字符都设置偏移量 1234&lt;text x="200" y="150" text-anchor="middle"&gt; &lt;tspan fill="deeppink" font-size="20px" dx="10" dy="-5"&gt;Hello&lt;/tspan&gt; &lt;tspan fill="none" stroke="deepskyblue" font-size="30px" dx="1 2 3 4 5" dy="5 4 3 2 1"&gt;World&lt;/tspan&gt;&lt;/text&gt; rotate123456789&lt;text x="200" y="150" text-anchor="middle"&gt; Hello &lt;tspan fill="none" stroke="deepskyblue" font-size="30px" dx="5 10 15 20 40" dy="0" rotate="30 45 60 90 180"&gt;World&lt;/tspan&gt;&lt;/text&gt;&lt;!-- rotate可控制文本中字符的旋转 当rotate只有一个参数时，文本每一个字符均以自身中心点为旋转中心，旋转指定的角度，正值顺时针 当rotate参数个数与文本中字符对应时，每个字符的旋转角度由相应的参数决定--&gt; 角标1234567&lt;text x="200" y="150" text-anchor="middle" font-size="20px"&gt; Hello &lt;tspan font-size="10px" baseline-shift="sub"&gt;[1]&lt;/tspan&gt; World &lt;tspan font-size="10px" baseline-shift="super"&gt;[2]&lt;/tspan&gt;&lt;/text&gt;&lt;!-- 也可以直接使用baseline-shift属性设置上下角标 --&gt; 123456&lt;text x="200" y="150" text-anchor="middle" font-size="20px"&gt; Hello &lt;tspan font-size="10px" dx="-3" dy="8"&gt;[2]&lt;/tspan&gt; World&lt;/text&gt;&lt;!-- 利用dx、dy属性来调整文字的位置，以达到角标的效果 --&gt; 最好使用第一种方法，因为如果使用dx、dy，将某一段文本移动后，因为后面的文字会与它对齐，如上图中的World与[2]对齐，导致后面的文本偏离原来的位置 文本长度及字符间隔默认情况下无法获得 &lt;text&gt; 文本长度，但是我们可以通过 textLength 属性设置文本的长度，文本会根据 textLength 的值自适应变化，变化的规则可用通过 lengthAdjust 属性来设置 lengthAdjust 有两个可选的值： spacing spacingAndGlyphs spacing只调整字符之间的间隔，spacingAndGlyphs则会根据一定的比例同时调整间距和字符的大小 123456789101112&lt;path d="M 100 50 L 100 140 M 350 50 L 350 140" stroke="#000"&gt;&lt;/path&gt;&lt;text x="100" y="80" font-size="20px" textLength="250" lengthAdjust="spacing"&gt;Hello world&lt;/text&gt;&lt;text x="100" y="130" font-size="20px" textLength="250" lengthAdjust="spacingAndGlyphs"&gt;Hello world&lt;/text&gt;&lt;text x="110" y ="180" font-size="20px"&gt; Hello world &lt;tspan font-size="16px"&gt;(normal)&lt;/tspan&gt;&lt;/text&gt;&lt;path d="M 180 200 L 180 290 M 270 200 L 270 290" stroke="#000"&gt;&lt;/path&gt;&lt;text x="180" y="230" font-size="20px" textLength="90" lengthAdjust="spacing"&gt;Hello world&lt;/text&gt;&lt;text x="180" y="280" font-size="20px" textLength="90" lengthAdjust="spacingAndGlyphs"&gt;Hello world&lt;/text&gt; 垂直文本方法一: writing-mode + rotate + letter-spacing 方法二: transform=&quot;rotate()&quot; + rotate + letter-spacing 12&lt;text x="200" y="100" writing-mode="tb" letter-spacing="5" rotate="-90"&gt;hello world&lt;/text&gt;&lt;text x="220" y="100" transform="rotate(90, 220, 100)" letter-spacing="5" rotate="-90"&gt;hello world&lt;/text&gt; 垂直文本有些字符不在竖直轴线上（如上图的 “l”），可以利用dx，dy进行微调 12&lt;text x="200" y="100" writing-mode="tb" letter-spacing="7" rotate="-90" dx="0 0 2 0 -2 0 0 0 2 0 -2" dy="0"&gt;hello world&lt;/text&gt;&lt;text x="220" y="100" transform="rotate(90, 220, 100)" letter-spacing="7" rotate="-90"&gt;hello world&lt;/text&gt; textPath内嵌于 &lt;text&gt; 中的 &lt;textPath&gt; 元素，通过 xlink:href 属性指向一个 &lt;path&gt; 元素，可以将文本的baseline设置成指定的path，即文本沿path排列 123456&lt;path id="arc" d="M 100 100 A 100 100 0 1 0 400 100" stroke="#000" fill="none" /&gt;&lt;text font-size="20"&gt; &lt;textPath xlink:href="#arc"&gt; I Love SVG! &lt;/textPath&gt;&lt;/text&gt; &lt;text&gt; 元素的坐标轴改变 text原本是相对于坐标轴定位的，其属性值x,y设置text元素再坐标系中的位置，当时用textPath后，text的坐标系不再是它原理的坐标系，而变成了path路径，即path路径作为text元素的x轴，y轴是不固定的，它满足的条件是与x轴上每一个点的切线垂直 123456789101112&lt;path id="arc" d="M 100 100 A 100 100 0 1 0 400 100" stroke="#000" fill="none" /&gt;&lt;text x="100" y="10" font-size="20"&gt; &lt;textPath xlink:href="#arc"&gt; I Love SVG! &lt;/textPath&gt;&lt;/text&gt;&lt;!-- 此时text元素的坐标原点应该在path路径的起点，这里设置了x和y的值 x应该是沿path路径偏移path起点的距离，y应该是沿垂直于path路径， 偏离path路径的距离，但是这里x的值符合预期，y的值却不生效，没有 搞懂是为什么?--&gt; 超出path路径长度的文本将被隐藏 1234567&lt;path id="arc" d="M 100 100 A 100 100 0 1 0 400 100" stroke="#000" fill="none" /&gt;&lt;text font-size="35" fill="none" stroke="deepskyblue"&gt; &lt;textPath xlink:href="#arc" &gt; ABCSEFGHIJKLMNOPQRSTUVWXYZ &lt;/textPath&gt;&lt;/text&gt;&lt;!-- U以后的字母超出路径长度，被隐藏 --&gt; &lt;textPath&gt; 的 startOffset 属性 startOffset 属性可以调整 &lt;text&gt; 元素再path路径上的位置，它表示 &lt;text&gt; 元素再path路径上偏离path起点的距离，可以是具体的数字或者百分比，配合 text-anchor 属性可以实现 &lt;text&gt; 元素再path路径上的居中显示 123456&lt;path id="arc" d="M 100 100 A 100 100 0 1 0 400 100" stroke="#000" fill="none" /&gt;&lt;text font-size="20" fill="none" stroke="deepskyblue" text-anchor="middle"&gt; &lt;textPath xlink:href="#arc" startOffset="50%"&gt; ABCSEFGHIJKLMNOPQRSTUVWXYZ &lt;/textPath&gt;&lt;/text&gt; 空白符svg没有换行符！svg默认会把所有单个或连续多个空格、tabs、换行符转成单个空格。即使在css中将white-space设置为pre，换行符依然会被转换成空格！ 渐变线性渐变使用预览 123456789101112&lt;!-- 在defs中定义渐变 --&gt;&lt;defs&gt; &lt;!-- 从左到右--&gt; &lt;linearGradient id="linearGra" x1="0%" y1="0%" x2="100%" y2="0%"&gt; &lt;stop offset="0%" stop-color="red" /&gt; &lt;stop offset="50%" stop-color="green" /&gt; &lt;stop offset="100%" stop-color="blue" stop-opacity="0.5" /&gt; &lt;/linearGradient&gt;&lt;/defs&gt;&lt;!-- 应用渐变样式 --&gt;&lt;rect x="100" y="50" width="200" height="50" fill="url(#linearGra)" /&gt; stop 元素的属性 offset ​ 表示渐变矢量的位置，可以是0~1之间的值，也可以是0%~100%之间的值 stop-color ​ 定义颜色在offset节点的位置 stop-opacity ​ 定义颜色的透明度 linearGradient的属性 (x1, y1)、(x2, y2) 定义渐变的起始位置、终止位置，决定了渐变的方向 xlink:href 再一个渐变中引用另一个渐变，被引用的渐变是可继承的，也可以进行修改 12345678910111213141516&lt;defs&gt; &lt;linearGradient id="linearGra1" x1="0%" y1="0%" x2="100%" y2="0%"&gt; &lt;stop offset="0%" stop-color="red" /&gt; &lt;stop offset="50%" stop-color="green" /&gt; &lt;stop offset="100%" stop-color="blue" stop-opacity="0.5" /&gt; &lt;/linearGradient&gt; &lt;linearGradient id="linearGra2" x1="0%" y1="0%" x2="0%" y2="100%" xlink:href="#linearGra1"&gt;&lt;/linearGradient&gt;&lt;/defs&gt;&lt;!-- 应用渐变样式 --&gt;&lt;rect x="100" y="50" width="200" height="50" fill="url(#linearGra1)" /&gt;&lt;!-- 应用渐变样式 --&gt;&lt;rect x="100" y="150" width="200" height="100" fill="url(#linearGra2)" /&gt; gradientUnits gradientUnits（渐变单元）的属性，它描述了用来描述渐变的大小和方向的单元系统。该属性有两个值：userSpaceOnUse 、objectBoundingBox。默认值为objectBoundingBox，我们目前看到的效果都是在这种系统下的，它大体上定义了对象的渐变大小范围，所以你只要指定从0到1的坐标值，渐变就会自动的缩放到对象相同大小。userSpaceOnUse使用绝对单元，所以你必须知道对象的位置，并将渐变放在同样地位置上 123456789101112&lt;!-- 在defs中定义渐变 --&gt;&lt;defs&gt; &lt;!-- 从左到右，绝对位置坐标--&gt; &lt;linearGradient id="linearGra" x1="100" y1="0" x2="300" y2="0" gradientUnits="userSpaceOnUse"&gt; &lt;stop offset="0%" stop-color="red" /&gt; &lt;stop offset="50%" stop-color="green" /&gt; &lt;stop offset="100%" stop-color="blue" stop-opacity="0.5" /&gt; &lt;/linearGradient&gt;&lt;/defs&gt;&lt;!-- 应用渐变样式 --&gt;&lt;rect x="100" y="50" width="200" height="50" fill="url(#linearGra)" /&gt; 明显 objectBoundingBox 属性要更方便，只需要定义相对值 gradientTransform 给渐变添加变化效果 123456789101112131415161718&lt;defs&gt; &lt;linearGradient id="linearGra1" x1="0%" y1="0%" x2="100%" y2="0%"&gt; &lt;stop offset="0%" stop-color="red" /&gt; &lt;stop offset="50%" stop-color="green" /&gt; &lt;stop offset="100%" stop-color="blue" stop-opacity="0.5" /&gt; &lt;/linearGradient&gt; &lt;linearGradient id="linearGra2" x1="0%" y1="0%" x2="100%" y2="0%" xlink:href="#linearGra1" gradientTransform="rotate(45)"&gt;&lt;/linearGradient&gt; &lt;!-- 旋转角最好在0~90度之间 --&gt;&lt;/defs&gt;&lt;!-- 应用渐变样式 --&gt;&lt;rect x="100" y="50" width="200" height="50" fill="url(#linearGra1)" /&gt;&lt;!-- 应用渐变样式 --&gt;&lt;rect x="100" y="150" width="200" height="100" fill="url(#linearGra2)" /&gt; spreadMethod spreadMethod=&quot;pad(默认) | reflect | repeat&quot; 1234- pad:使用渐变的颜色结点来填充剩余的空间。例如，如果第一个结点是20%，那么0%到20%这部分就是相同的颜色- reflect:映射渐变图案，从&apos;start-to-end&apos;，再从&apos;end-to-start&apos;，然后&apos;start-to-end&apos;，直到空间都填满- repeat:重复渐变图案，从起点-&gt;终点，直到空间填满- 后两个属性的兼容性很不好，不建议使用 12345678910&lt;defs&gt; &lt;!-- 默认情况下就是 pad 的效果，"reflect" 和 "repeat" 的兼容性都很不好，不建议使用 --&gt; &lt;linearGradient id="linearGra" x1="0%" y1="0%" x2="100%" y2="0%" spreadMethod="pad"&gt; &lt;stop offset="20%" stop-color="red" /&gt; &lt;stop offset="50%" stop-color="green" /&gt; &lt;stop offset="70%" stop-color="blue" stop-opacity="0.5" /&gt; &lt;/linearGradient&gt;&lt;/defs&gt;&lt;rect x="100" y="100" width="200" height="50" fill="url(#linearGra)" /&gt; 径向渐变(未完善)使用预览 12 滤镜高斯滤镜 12345678&lt;defs&gt; &lt;!-- 高斯滤镜 --&gt; &lt;filter id="Gaussian_Blur"&gt; &lt;feGaussianBlur in="SourceGraphic" stdDeviation="20" /&gt; &lt;/filter&gt;&lt;/defs&gt;&lt;rect x="100" y="100" width="200" height="100" fill="red" filter="url(#Gaussian_Blur)"&gt;&lt;/rect&gt; 其他滤镜 使用时将 &lt;filter&gt; 标签下的 &lt;feGaussianBlur&gt;标签替换成相应的标签即可 12345678910111213141516171819- feBlend- feColorMatrix- feComponentTransfer- feComposite- feConvolveMatrix- feDiffuseLighting- feDisplacementMap- feFlood- feGaussianBlur- feImage- feMerge- feMorphology- feOffset- feSpecularLighting- feTile- feTurbulence- feDistantLight- fePointLight- feSpotLight transformtransform用于svg图形的形变，与css3中的transform属性有所相同 强调，所有的变形操作都是基于元素所在的坐标系进行变化的 translate 功能 改变变形元素所在坐标系原点的位置 语法 transform=&quot;transform(x, y)&quot; 参数 x: 元素所在坐标系在x轴方向上的偏移量 y: 元素所在坐标系在y轴方向上的偏移量 图解 1&lt;rect x="0" y="0" width="50" height="50" transform="translate(100, 100)"&gt;&lt;/rect&gt; 如图，一个宽高50的矩形所在的坐标系，被向右、向下平移了100px，即由A点平移到了B点，坐标系的原点移动了位置，但它还是坐标原点，坐标系中元素的坐标不变；因为坐标系被平移了，所以坐标系中的元素也跟着一起平移了 rotate 功能 改变变形元素所在坐标系坐标轴的方向 语法 transform=&quot;rotate(angle [, x, y])&quot; 参数 angle： 元素所在的坐标系旋转的角度（正值顺时针） (x, y)：元素所在的坐标系的旋转中心点（此值可以省略，默认为(0, 0)） 图解 1&lt;rect x="200" y="0" width="50" height="50" transform="rotate(45)"&gt;&lt;/rect&gt; 只设置了旋转的角度，则旋转的中心点默认是(0, 0)点，上图表示黑色元素所在的坐标系以(0, 0)为旋转中心，旋转了45度，我们改变旋转中心再转一次 12&lt;rect x="200" y="0" width="50" height="50" transform="rotate(45, 225, 25)"&gt;&lt;/rect&gt;&lt;!-- 旋转中心在矩形元素的中心点 --&gt; 可以看到，发生旋转的依然是矩形区域所在的坐标系，但是因为旋转中心是矩形的中心点，所以也相当于矩形区域自身进行了旋转，所以如果我们的需求是元素相对于自身发生旋转时，可以使用这种方法 scale 功能 改变变形元素所在的坐标系的单位长度 语法 transform=&quot;scale(x-value, y-value)&quot; 参数 x-value：x轴方向上的缩放因子 y-value：y轴方向上的缩放因子 单位长度 默认一个单位代表一个像素，如果我们改变缩放因子，使一个单位表示像素多余或者少于一个，就起到了放大或者是缩小的效果 图解 12&lt;path d="M 100 150 L 200 150" stroke="#000" fill="none" transform="scale(2, 1)"&gt;&lt;/path&gt;&lt;!-- x轴缩放因子扩大两倍，y轴缩放因子不变 --&gt; 在这个例子中，我们将x轴方向上的缩放因子设置为2，也就是说x轴由原来的一个单位一个像素在缩放后一个单位两个像素，所以缩放前由x=100到x=200的直线（红色部分），缩放后变成了图中绿色部分（坐标不变，视觉上变成了两倍） skew 功能 改变变形元素所在的坐标系坐标网格在x轴方向或在y轴方向的倾斜程度 语法 transform: skewX(angle) skewY(angle) 参数 angle表示倾斜的角度 说明 skewX(angle) 表示变形元素所在坐标系坐标网格沿x轴方向倾斜，角度为angle(正值向x轴正方向倾斜) skewY(angle) 表示变形元素所在坐标系坐标网格沿y轴方向倾斜，角度为angle(正值向y轴正方向倾斜) 图解 12&lt;path d="M 100 100 L 300 100 M 100 100 L 100 200 z" stroke="red"&gt;&lt;/path&gt;&lt;path d="M 100 100 L 300 100 M 100 100 L 100 200 z" stroke="green" transform="skewX(45)"&gt;&lt;/path&gt; 红色是没有倾斜前的图形，绿色是经过倾斜变心之后的图形，我们来看看在这个过程中坐标网格发生了什么变化 以上两图分别表示倾斜前后的坐标系，可以看到，在设置 skewX(45) 之后，整个坐标网格向x轴正方向倾斜了45度，每一个单独的坐标网格由原来的正矩形变成了菱形，其他元素均保持不变，我们将图形的坐标分别填入两个坐标系中并连线，得到两个形状不同的折线，这也就是上述图形变化中红色图形到绿色图形的变化过程 居中变化处理(未完善)在上述所有的变形操作中，都是以变形元素的坐标系为单位进行整体变化的，这同时也强调了另一件事情，变形操作的中心点是坐标原点，但是有时我们不想以原点为中心点对图形进行变形操作，而是以图形自身的中心点为变形操作的中心点进行变化，那该怎么实现呢？（旋转操作比较特殊，他可以自己设置旋转的中心点，所以这里的方法主要针对其他几种变形操作） “平移 -&gt; 变形 -&gt; 平移” 三部曲 1transform="translate(centerX，centerY) doTransform translate(-centerX, -centerY)"; 12345- (centerX, centerY)： 变形元素自身中心点的坐标- doTransform： 变形操作- (-centerX, centerY)： 变形元素自身中心点的坐标的负值 以缩放变形为例 12&lt;rect x="200" y="100" width="100" height="100" transform="translate(250, 150) scale(2, 1) translate(-250, -150)"&gt;&lt;/rect&gt;&lt;!-- 这里矩形元素自身的中心点为(250, 150) --&gt; 公式计算 这种计算方式仅针对缩放操作 1transform="translate(-centerX * (fX - 1)， -centerY * (fY - 1)) scale(fX, fY)"; 123- (centerX, centerY)：变形元素自身的中心点坐标- fX：x轴方向的缩放因子- fY：y轴方向的缩放因子 1 “调整位置 -&gt; 平移 -&gt; 变形” 1x="-width * 1 / 2" y="-height * 1 / 2" transform="translate(centerX, centerY) doTransform"; 12345- 调整位置： 在定义变形元素位置的时候，将变形元素的中心点放在原点- -width * 1 / 2： 变形元素自身宽度一半的负值- -height * 1 / 2： 变形元素自身高度一半的负值- (centerX, centerY)： 变形元素自身的中心点的坐标- doTransform： 变形操作 以倾斜举例 1&lt;rect x="-50" y="-50" width="100" height="100" transform="translate(250, 150) skewX(45)"&gt;&lt;/rect&gt; viewBox svg transform 与 css transform两者在基本功能上是相似的，但有一些细节之处不相同，这里列举一些 单位 在css中绝大多数属性的长度单位默认都是px，而在svg中不写单位，因为一个单位对应的长度不固定 语法 两者语法基本相同，但是有不同之处 中心点 css中使用 transform 变化图形，其中心点默认就在图形的中心点；而svg中图形变化的中心点默认是坐标原点 辅助标签g &lt;g&gt; 元素通常用来对相关图形元素进行分组，以便统一操作，比如旋转，缩放或者添加相关样式等 看一组同心圆的实例 123&lt;circle cx="250" cy="150" r="30" fill="none" stroke="#000"&gt;&lt;/circle&gt;&lt;circle cx="250" cy="150" r="50" fill="none" stroke="#000"&gt;&lt;/circle&gt;&lt;circle cx="250" cy="150" r="70" fill="none" stroke="#000"&gt;&lt;/circle&gt; 可以看到，设置中很多属性都是重复的，每一个圆都要写的话会写很多重复代码，而且如果要对圆进行修改的话，还有去修改每一个圆的属性值，下面使用 &lt;g&gt; 标签来定义这组同心圆，效果是一样的，但省了很多代码 123456&lt;!-- 不设置圆心坐标，默认在(0, 0), 使用平移操作将一组元素全部平移到相应的坐标，并给他们设置样式 --&gt;&lt;g transform="translate(250, 150)" fill="none" stroke="#000"&gt; &lt;circle r="30"&gt;&lt;/circle&gt; &lt;circle r="50"&gt;&lt;/circle&gt; &lt;circle r="70"&gt;&lt;/circle&gt;&lt;/g&gt; defs 定义以要重复使用的元素，可以增加SVG内容的易读性和可访问性；需要注意的是在 &lt;defs&gt; 标签中定义的元素，其内容不会直接显示，需要其他元素引用它进行实例化才能显示 &lt;defs&gt; 中定义的内容不会直接显示，需要其他元素引用它才会显示，这样大大增加了开发的灵活性，我们可以在&lt;defs&gt; 中指定义基本的框架而不定义样式，在其他元素引用它时再给他设置需要的样式，这样代码语义性好，可读性强，应用更加灵活 1234567891011121314151617&lt;defs&gt; &lt;linearGradient id="linearGra" x1="0%" y1="0%" x2="100%" y2="0%"&gt; &lt;stop offset="0%" stop-color="yellowgreen" /&gt; &lt;stop offset="50%" stop-color="deeppink" /&gt; &lt;stop offset="100%" stop-color="deepskyblue" /&gt; &lt;/linearGradient&gt; &lt;radialGradient id="radialGra" fx="50%" fy="50%" cx="50%" cy="50%" r="50%"&gt; &lt;stop offset="0%" stop-color="yellowgreen" /&gt; &lt;stop offset="50%" stop-color="deeppink" /&gt; &lt;stop offset="100%" stop-color="deepskyblue" /&gt; &lt;/radialGradient&gt;&lt;/defs&gt;&lt;!-- 上面&lt;defs&gt;中定义的渐变属于一种样式，需要具体的元素应用它以达到实例化的效果 --&gt;&lt;rect x="100" y="50" width="300" height="50" fill="url(#linearGra)" /&gt;&lt;circle cx="250" cy="200" r="50" fill="url(#radialGra)" /&gt; 123456&lt;defs&gt; &lt;rect id="rectDefs" x="100" y="100" width="200" height="100" /&gt;&lt;/defs&gt;&lt;!-- 上面&lt;defs&gt;中定义的&lt;rect&gt;属于具体的元素，需要使用&lt;use&gt;进行实例化，实例化时可以设置不同的样式 --&gt;&lt;use fill="purple" fill-opacity="0.5" stroke="deepskyblue" stroke-width="5" xlink:href="#rectDefs" /&gt; use &lt;use&gt; 元素在SVG文档内取得目标节点，并在别的地方复制它们。它的效果等同于这些节点被深克隆到一个不可见的DOM中，然后将其粘贴到 &lt;use&gt;元素的位置 需要注意的是： 因为克隆的节点是不可见的，所以当使用CSS样式化一个 &lt;use&gt; 元素以及它的隐藏的后代元素的时候，隐藏的、克隆的DOM不能保证继承CSS属性，除非明文设置使用CSS继承 出于安全原因，一些浏览器可能在use元素上应用同源策略，还有可能拒绝载入xlink:href属性内的跨域URL 1234567&lt;defs&gt; &lt;circle id="circleDefs" cx="250" cy="50" r="30" /&gt;&lt;/defs&gt;&lt;use id="orange" fill="orange" xlink:href="#circleDefs" /&gt;&lt;use id="pink" fill="deeppink" transform="translate(0, 100) rotate(45, 250, -50)" xlink:href="#circleDefs" /&gt;&lt;use id="pink" fill="deepskyblue" transform="translate(0, 100) rotate(-45, 250, -50)" xlink:href="#circleDefs" /&gt; symbol &lt;symbol&gt; 兼具 &lt;g&gt;的分组功能和 &lt;defs&gt;初始不可见的特性，&lt;symbol&gt; 能够创建自己的视窗，所以能够应用viewBox和preserveAspectRatio属性 1234567&lt;symbol id="sym" viewBox="0 0 150 110"&gt; &lt;circle cx="50" cy="50" r="40" stroke-width="8" stroke="red" fill="red" /&gt; &lt;circle cx="90" cy="60" r="40" stroke-width="8" stroke="green" fill="white" /&gt;&lt;/symbol&gt;&lt;use xlink:href="#sym" x="200" y="70" width="100" height="50" /&gt;&lt;use xlink:href="#sym" x="200" y="120" width="75" height="38" /&gt;&lt;use xlink:href="#sym" x="200" y="170" width="50" height="25" /&gt; a 在SVG中，可以使用超链接 &lt;a&gt;，超链接可以添加到任意的图形上 123- xlink:href 指定链接的地址- xlink:title 指定链接的标题- target 指定打开的方式 123&lt;a xlink:title="百度一下" xlink:href="https://www.baidu.com" target="_blank"&gt; &lt;text x="250" y="150" text-anchor="middle" fill="none" stroke="deepskyblue" font-size="30" cursor="pointer" &gt;百度一下&lt;/text&gt;&lt;/a&gt; image SVG有一个 &lt;image&gt; 元素，可以利用它嵌入任意光栅（以及矢量）图像。它的规格要求应用至少支持PNG、JPG和SVG格式文件 嵌入的图像变成一个普通的SVG元素。这意味着，可以在其内容上用剪切、遮罩、滤镜、旋转等操作 12345678&lt;defs&gt; &lt;filter id="gs"&gt; &lt;feGaussianBlur in="SourceGraphic" stdDeviation="1" /&gt; &lt;/filter&gt;&lt;/defs&gt;&lt;image x="100" y="20" height="100" xlink:href="https://ws1.sinaimg.cn/large/006eYMu7ly1ftopu9hgs2j30zk0k0jv7.jpg" /&gt;&lt;image x="100" y="150" height="100" xlink:href="https://ws1.sinaimg.cn/large/006eYMu7ly1ftopu9hgs2j30zk0k0jv7.jpg" filter="url(#gs)" /&gt; 元素的坐标系 建议看完 transform 和 辅助标签，再看这个知识点 以一个矩形的平移操作为例 1&lt;rect x="0" y="0" width="50" height="50" transform="translate(50, 50)" /&gt; 经过前面的讲解我们知道，这段代码的含义是将矩形所在的坐标系的坐标原点由(0, 0)的位置，平移到了(50, 50)的位置，如下图所示 接下来我们在这个操作的基础上，在(0, 0)的位置上在画一个矩形，宽高为20，填充颜色为红色 12&lt;rect x="0" y="0" width="50" height="50" transform="translate(50, 50)" /&gt;&lt;rect x="0" y="0" width="20" height="20" fill="red" /&gt; 预期结果如下图 实际结果如下图 咦，不是坐标系已经被平移了么？怎么第二个矩形的原点坐标又回到了平移前的位置？其实原因很简单，svg中不同元素不共享统一坐标系，可以理解为每一个图形元素都已自己独立的坐标系，自己坐标系的变化不会影响到其他元素的坐标系不会影响到其他元素的坐标系，那么问题来了，如果每个元素都拥有自己独立的坐标系，如果我们想让一些元素共同在一个坐标系下进行图形变化该怎么办呢，这就要用到上一个知识点讲到的辅助标签，举个例子 1234&lt;g transform="translate(50, 50)"&gt; &lt;rect x="0" y="0" width="50" height="50" /&gt; &lt;rect x="0" y="0" width="20" height="20" fill="red" /&gt;&lt;/g&gt; 我们只需要将共同变化的元素放在带有分组性质的标签中，然后对分组标签统一变换即可 svg动画首先要有一个svg图形，且该图形具有 stroke 属性 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; svg &#123; border: 1px solid #000; &#125; #heart &#123; stroke: red; stroke-width: 1.5; fill: none; fill-opacity: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300"&gt; &lt;g&gt; &lt;title&gt;Loving heart&lt;/title&gt; &lt;path stroke="red" id="heart" d="m 243 103 c 57 -116 282 0 0 149 c-282 -149 -57 -265 0 -149 z" /&gt; &lt;/g&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 给图形线条设置虚线样式 1234#heart &#123; .....; stroke-dasharray: 15; /* 设置规则同canvas中虚线的设置规则相同 */&#125; 给虚线设置偏移量，让线条产生动的效果 12345#heart &#123; .....; stroke-dasharray: 15; /* 设置规则同canvas中虚线的设置规则相同 */ stroke-dashoffset: -100;&#125; 给动的效果设置动画，让它持续动起来 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; svg &#123; border: 1px solid #000; &#125; #heart &#123; stroke: red; stroke-width: 1.5; stroke-dasharray: 15; /* 设置规则同canvas中虚线的设置规则相同 */ stroke-dashoffset: -100; fill: none; fill-opacity: none; animation: move 0.5s linear infinite; &#125; @keyframes move &#123; to &#123; stroke-dashoffset: 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300"&gt; &lt;g&gt; &lt;title&gt;Loving heart&lt;/title&gt; &lt;path stroke="red" id="heart" d="m 243 103 c 57 -116 282 0 0 149 c-282 -149 -57 -265 0 -149 z" /&gt; &lt;/g&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 以上便有了动画基本的模型，接下来我们重新设置 stroke-dasharray 的值，使 stroke-dasharray 超过路径的长度，路径的长度要用js获取 12345678// 获取路径的总长度dom.getTotalLength// 获取路径上距离起始点长度x的点的坐标dom.getPointAtLength(x)// 严格来说，dom元素只能是path元素，即上面两方法只适用于path元素，但各个浏览器实现起来都会有一点区别// 例如谷歌浏览器也能获取到line元素的路径长度 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; svg &#123; border: 1px solid #000; &#125; #heart &#123; stroke: red; stroke-width: 1.5; fill: none; fill-opacity: none; animation: move 2s linear infinite; &#125; @keyframes move &#123; to &#123; stroke-dashoffset: 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300"&gt; &lt;g&gt; &lt;title&gt;Loving heart&lt;/title&gt; &lt;path stroke="red" id="heart" d="m 243 103 c 57 -116 282 0 0 149 c-282 -149 -57 -265 0 -149 z" /&gt; &lt;/g&gt; &lt;/svg&gt; &lt;script&gt; var oHeart = document.getElementById('heart'); var len = oHeart.getTotalLength(); oHeart.style.strokeDasharray = len; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 咦这样不是不动了？别急，将 stroke-dashoffset 的值设置成路径长度的相反数 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; svg &#123; border: 1px solid #000; &#125; #heart &#123; stroke: red; stroke-width: 1.5; fill: none; fill-opacity: none; animation: move 2s linear infinite; &#125; @keyframes move &#123; to &#123; stroke-dashoffset: 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300"&gt; &lt;g&gt; &lt;title&gt;Loving heart&lt;/title&gt; &lt;path stroke="red" id="heart" d="m 243 103 c 57 -116 282 0 0 149 c-282 -149 -57 -265 0 -149 z" /&gt; &lt;/g&gt; &lt;/svg&gt; &lt;script&gt; var oHeart = document.getElementById('heart'); var len = oHeart.getTotalLength(); oHeart.style.strokeDasharray = len; oHeart.style.strokeDashoffset = -len; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 取消无限次播放，将动画停留在最后的关键帧上 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; svg &#123; border: 1px solid #000; &#125; #heart &#123; stroke: red; stroke-width: 1.5; fill: none; fill-opacity: none; animation: move 3s linear forwards; &#125; @keyframes move &#123; to &#123; stroke-dashoffset: 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300"&gt; &lt;g&gt; &lt;title&gt;Loving heart&lt;/title&gt; &lt;path stroke="red" id="heart" d="m 243 103 c 57 -116 282 0 0 149 c-282 -149 -57 -265 0 -149 z" /&gt; &lt;/g&gt; &lt;/svg&gt; &lt;script&gt; var oHeart = document.getElementById('heart'); var len = oHeart.getTotalLength(); oHeart.style.strokeDasharray = len; oHeart.style.strokeDashoffset = -len; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; viewBoxviewport12&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300"&gt;&lt;/svg&gt; 这里的 500 * 300 便是 viewport的大小 viewBox使用预览 123456&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300" viewBox="0, 0, 50, 30"&gt;&lt;/svg&gt; viewBox表示一个矩形区域，(0, 0) 表示矩形左上角的坐标，(50, 30) 表示矩形区域的宽高 功能展示 1234567&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300" viewBox="0, 0, 50, 30"&gt;&lt;rect x="10" y="10" width="20" height="10" /&gt;&lt;/svg&gt; 预期效果 实际效果 注意这里矩形元素的设置，起点在(10, 10)，宽高为 20 10，但是实际效果却不是这样，实际效果是起点(100, 100)，宽高 200 100的矩形，为什么会这样呢？因为viewBox的缘故，它的作用是将它作用区域剪切下来，然后在整个viewport区域中显示，也就是说，上面的代码中，viewBox将起点为(0, 0)，宽高为50 * 30 的区域剪切了下来然后放到了整个viewport区域中显示，因为viewport和viewBox的宽高比例是相同的，所以viewBox可以完美的展示在viewport中，可参照下图理解 preserveAspectRatio上述的viewBox与viewport比例相同的情况是一种最好的情况，viewBox裁剪下来的区域正好能在viewport中显示，但如果他们的比例不一致呢，viewBox应该怎么在viewport中展示 先来看一下 preserveAspectRatio 长什么样子 1preserveAspectRatio=&quot;xMidYMid meet&quot;; 共分为两部分属性，中间由空格分开 前半部分：设置viewBox与viewport的对齐方式 值 含义 xMin viewport和viewBox左边对齐 xMid viewport和viewBox x轴中心对齐 xMax viewport和viewBox右边对齐 YMin viewport和viewBox上边缘对齐。注意Y是大写 YMid viewport和viewBox y轴中心点对齐。注意Y是大写 YMax viewport和viewBox下边缘对齐。注意Y是大写 后半部分：设置viewBox在viewport中的填充方式 值 含义 meet 保持横纵比，缩放使viewBox尽可能小的适应viewport slice 保持横纵比，缩放是viewBox尽可能大的适应viewport none 扭曲横纵比以适应viewport 备注 因为 “meet” 和 “slice” 都是在保持横纵比的前提下进行缩放，所以这两个属性的变化只能以一条边(宽或高)为准，另一条边的缩放由这条边决定 当属性值为none时，前半部分对齐方式不能再设置，只写一个none meet 首先来讲解 “meet”，接下俩将以三个实例来充分理解 “保持横纵比，缩放使viewBox尽可能小的适应viewport” 这句话的含义 实例1 viewBox的宽为250， 高为300 123456789&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300" viewBox="0 0 250 300" preserveAspectRatio="xMinYMin meet"&gt; &lt;rect x="0" y="0" width="200" height="100" fill="#B4C7E7" /&gt;&lt;/svg&gt; 效果如上图，矩形区域没有进行缩放，下面我们画一些辅助线来解释一下 1234- 图示- 黑色实线区域：500 * 300 viewport区域- 红色虚线区域：350 * 300 viewBox区域- 深紫矩形区域：200 * 100 矩形区域 1234567- 计算符号(缩放前)- viewportW: viewport的宽- viewportH: viewport的高- viewBoxW: viewBox的宽- viewBoxH： viewBox的高- scaleX = viewportW / viewBoxW: 以宽为基准的缩放因子- scaleY = viewportH / viewBoxH：以高为基准的缩放因子 1234- 计算过程scaleX = viewportW / viewBoxW = 500 / 250 = 2;scaleY = viewportH / viewBoxH = 300 / 300 = 1;scaleX &gt; scaleY 计算结果的解释： 如果以宽为基准进行缩放，则要将viewBox的宽扩大两倍，高也随之扩大两倍； 如果以高为基准进行缩放，则不需要对viewBox区域进行缩放； 在两者都能适应viewport区域的情况下，为了满足 “尽可能小” 条件，选择以高为基准，这里比例是1所以不缩放，与之对应的viewBox区域内的矩形区也不会缩放 实例2 接下来我们修改viewBox区域的宽高，我们把 viewBox的高度由原来的300改成200 12345678&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300" viewBox="0 0 250 200" preserveAspectRatio="xMinYMin meet"&gt; &lt;rect x="0" y="0" width="200" height="100" fill="#B4C7E7" /&gt;&lt;/svg&gt; 实际效果如上图，矩形的宽高扩大了1.5倍，加一些辅助线讲解（辅助线好像有点多，没关系，一点一点来看） 123456- 图示- 黑色实线区域：500 * 300 viewport区域- 红色虚线区域：250 * 200 缩放前viewBox区域- 绿色虚线区域：375 * 300 缩放后viewBox区域- 浅紫矩形区域：200 * 100 缩放前矩形区域- 深紫矩形区域：300 * 150 缩放后矩形区域 1234567- 计算符号(缩放前)- viewportW: viewport的宽- viewportH: viewport的高- viewBoxW: viewBox的宽- viewBoxH： viewBox的高- scaleX = viewportW / viewBoxW: 以宽为基准的缩放因子- scaleY = viewportH / viewBoxH：以高为基准的缩放因子 1234- 计算过程- scaleX = viewportW / viewBoxW = 500 / 200 = 2.5;- scaleY = viewportH / viewBoxH = 300 / 200 = 1.5;- scaleX &gt; scaleY 计算结果的解释： 如果以宽为基准进行缩放，则需要将viewBox的宽扩大2.5倍，高也随之扩大2.5倍； 如果以高为基准进行缩放，则需要将viewBox的高扩大1.5倍，宽也随之扩大1.5倍； 在两种情况都能适应viewport的情况下，为了保证 “尽可能小”，选择以高为基准，宽高均扩大为原来的1.5倍，相应的，viewBox中的矩形区域的宽高也扩大1.5倍 实例3 接下来我们再做一些修改，将viewBox的宽由原来的250改为1000，高由原来的300改为450 实际效果如上图，矩形区域宽高均缩小了2倍，添加辅助线理解 123456- 图示- 黑色实线区域：500 * 300 viewport区域- 红色虚线区域：1000 * 450 缩放前viewBox区域- 绿色虚线区域：500 * 225 缩放后viewBox区域- 浅紫矩形区域：200 * 100 缩放前矩形区域- 深紫矩形区域：100 * 50 缩放后矩形区域 1234567- 计算符号(缩放前)- viewportW: viewport的宽- viewportH: viewport的高- viewBoxW: viewBox的宽- viewBoxH： viewBox的高- scaleX = viewportW / viewBoxW: 以宽为基准的缩放因子- scaleY = viewportH / viewBoxH：以高为基准的缩放因子 1234- 计算过程- scaleX：viewportW / viewBoxW = 500 / 1000 = 0.5;- scaleY: viewportH / viewBoxH = 300 / 450 = 0.67;- scaleX &lt; scaleY 计算结果解释： 如果以宽为基准进行缩放，则需要将viewport的宽放大0.5倍，高也随之放大0.5倍； 如果以高为基准进行缩放，则需要将viewport的高放大0.67倍，高也随之放大0.67倍； 在两种情况都能适应viewport的情况下，为了保证 “尽可能小”，选择以宽为基准，宽高均扩大为原来的0.5倍，相应的，viewBox中的矩形区域的宽高也扩大0.5倍（放大0.5倍就是缩小两倍） 结论： 对于设置了 “meet” 属性的viewBox，缩放的倍数由 viewport 与 viewBox 宽的比值或者高的比值决定，谁小取谁 公式： scaleX = viewportW / viewBoxW scaleY = viewportH / viewBoxH scale = scaleX &lt; scaleY ? scaleX : scaleY slice 同样以三个实例（就用meet讲解中的三个实例）来讲解 “保持横纵比，缩放是viewBox尽可能大的适应viewport” 的含义（其实就是与meet确定宽高的方法相反，meet取小的，slice取大的） 实例1 viewBox宽250，高300 123456789&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;500&quot; height=&quot;300&quot; viewBox=&quot;0 0 250 300&quot; preserveAspectRatio=&quot;xMinYMin slice&quot;&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;100&quot; fill=&quot;#B4C7E7&quot; /&gt;&lt;/svg&gt; 实际效果如上图，矩形区域宽高均放大了2倍 123456- 图示- 黑色实线区域：500 * 300 viewport区域- 红色虚线区域：250 * 300 缩放前viewBox区域- 绿色虚线区域：500 * 600 缩放后viewBox区域- 浅紫矩形区域：200 * 100 缩放前矩形区域- 深紫矩形区域：400 * 200 缩放后矩形区域 1234567- 计算符号(缩放前)- viewportW: viewport的宽- viewportH: viewport的高- viewBoxW: viewBox的宽- viewBoxH： viewBox的高- scaleX = viewportW / viewBoxW: 以宽为基准的缩放因子- scaleY = viewportH / viewBoxH：以高为基准的缩放因子 1234- 计算过程- scaleX = viewportW / viewBoxW = 500 / 250 = 2- scaleY = viewportH / viewBoxH = 300 / 300 = 1- scaleX &gt; scaleY 计算结果的解释： 如果以宽为基准进行缩放，则要将viewBox的宽扩大两倍，高也随之扩大两倍； 如果以高为基准进行缩放，则不需要对viewBox区域进行缩放； 在两者都能适应viewport区域的情况下，为了满足 “尽可能大” 条件，选择以宽为基准，viewBox的宽扩大两倍，高也随之扩大两倍，相应的viewBox内的矩形区域的宽高也扩大两倍 实例2 接下来我们修改viewBox区域的宽高，我们把 viewBox的高度由原来的300改成200 12345678&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300" viewBox="0 0 250 200" preserveAspectRatio="xMinYMin slice"&gt; &lt;rect x="0" y="0" width="200" height="100" fill="#B4C7E7" /&gt;&lt;/svg&gt; 实际效果如上图，矩形区域的宽高均扩大了2倍，图解如下 123456- 图示- 黑色实线区域：500 * 300 viewport区域- 红色虚线区域：250 * 300 缩放前viewBox区域- 绿色虚线区域：500 * 400 缩放后viewBox区域- 浅紫矩形区域：200 * 100 缩放前矩形区域- 深紫矩形区域：400 * 200 缩放后矩形区域 1234567- 计算符号(缩放前)- viewportW: viewport的宽- viewportH: viewport的高- viewBoxW: viewBox的宽- viewBoxH： viewBox的高- scaleX = viewportW / viewBoxW: 以宽为基准的缩放因子- scaleY = viewportH / viewBoxH：以高为基准的缩放因子 1234- 计算过程- scaleX = viewportW / viewBoxW = 500 / 250 = 2- scaleY = viewportH / viewBoxH = 300 / 200 = 1.5- scaleX &gt; scaleY 计算结果的解释： 如果以宽为基准进行缩放，则要将viewBox的宽扩大两倍，高也随之扩大两倍； 如果以高为基准进行缩放，则要将viewBox的高扩大1.5倍，高也随之扩大1.5倍； 在两者都能适应viewport区域的情况下，为了满足 “尽可能大” 条件，选择以宽为基准，viewBox的宽扩大两倍，高也随之扩大两倍，相应的viewBox内的矩形区域的宽高也扩大两倍 实例3 接下来我们再做一些修改，将viewBox的宽由原来的250改为1000，高由原来的300改为450 实际效果如上图，矩形区域的宽高均放大了0.67倍，图解如下 123456- 图示- 黑色实线区域：500 * 300 viewport区域- 红色虚线区域：450 * 1000 缩放前viewBox区域- 绿色虚线区域：666.7 * 450 缩放后viewBox区域- 浅紫矩形区域：200 * 100 缩放前矩形区域- 深紫矩形区域：133.3 * 66.7 缩放后矩形区域 1234567- 计算符号(缩放前)- viewportW: viewport的宽- viewportH: viewport的高- viewBoxW: viewBox的宽- viewBoxH： viewBox的高- scaleX = viewportW / viewBoxW: 以宽为基准的缩放因子- scaleY = viewportH / viewBoxH：以高为基准的缩放因子 1234- 计算过程- scaleX：viewportW / viewBoxW = 500 / 1000 = 0.5;- scaleY: viewportH / viewBoxH = 300 / 450 = 0.67;- scaleX &lt; scaleY 计算结果解释： 如果以宽为基准进行缩放，则需要将viewport的宽放大0.5倍，高也随之放大0.5倍； 如果以高为基准进行缩放，则需要将viewport的高放大0.67倍，高也随之放大0.67倍； 在两种情况都能适应viewport的情况下，为了保证 “尽可能大”，选择以高为基准，宽高均扩大为原来的0.67倍，相应的，viewBox中的矩形区域的宽高也扩大0.67倍 结论： 对于设置了 “slice” 属性的viewBox，缩放的倍数由 viewport 与 viewBox 宽的比值或者高的比值决定，谁大取谁 公式： scaleX = viewportW / viewBoxW scaleY = viewportH / viewBoxH scale = scaleX &gt; scaleY ? scaleX : scaleY none “none” 属性不要维持viewBox的横纵比，所以设置了 “none” 属性的viewBox不需要以宽或者高中的一个为基准，他们可以各自基准，即宽高同时适应viewport 12345678&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="300" viewBox="0 0 250 200" preserveAspectRatio="xMinYMin slice"&gt; &lt;rect x="0" y="0" width="200" height="100" fill="#B4C7E7" /&gt;&lt;/svg&gt; 实际效果如上图，矩形区域宽度放大了2倍，高度放大了1.5倍，图解如下 123456- 图示- 黑色实线区域：500 * 300 viewport区域- 红色虚线区域：250 * 300 缩放前viewBox区域- 绿色虚线区域：500 * 400 缩放后viewBox区域- 浅紫矩形区域：200 * 100 缩放前矩形区域- 深紫矩形区域：400 * 200 缩放后矩形区域 1234567- 计算符号(缩放前)- viewportW: viewport的宽- viewportH: viewport的高- viewBoxW: viewBox的宽- viewBoxH： viewBox的高- scaleX = viewportW / viewBoxW: 以宽为基准的缩放因子- scaleY = viewportH / viewBoxH：以高为基准的缩放因子 123- 计算过程- scaleX = viewportW / viewBoxW = 500 / 250 = 2- scaleY = viewportH / viewBoxH = 300 / 200 = 1.5 计算结果解释： 因为没有保持横纵比的要求，所以viewBox在宽度和高度上均适应viewport，宽度扩大2倍，高度扩大1.5倍，相应的viewBox内的矩形区域宽也扩大2倍，高扩大1.5倍，这样的结果会是矩形发生形变 结论： 对于设置了 “none” 属性的viewBox，缩放的倍数由 viewport 与 viewBox 宽的比值或者高的比值决定，各自缩放适应，互不影响 公式： scaleX = viewportW / viewBoxW scaleY = viewportH / viewBoxH 对齐 前面讲的填充方式没有提到对齐，实例中都是 “xMinYMin” 的对齐方式，其实这个很简单，这里的对齐指的是缩放后的vieWBox怎么与viewport区域进行对齐，即上面实例中的绿色区域怎么与黑色区域进行对齐，对比对齐属性的表格理解即可 JS 生成 SVG 元素创建svg标签并指定命名空间 12var char = 'http://www.w3.org/2000/svg';var svg = document.createElementNS(char, 'svg'); 用 setAttribute 方法设置属性 123svg.setAttribute('width', 500);svg.setAttribute('height', 300);svg.setAttribute('viewBox', '0 0 50 30'); 添加图形元素 1234567var rect = document.createElementNS(char, 'rect');rect.setAttribute('x', 10);rect.setAttribute('y', 10);rect.setAttribute('width', 20);rect.setAttribute('height', 10);rect.setAttribute('fill', 'deepskyblue'); 添加dom结构 12svg.appendChild(rect);document.body.appendChild(svg); 全部代码如下 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; svg &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; var char = 'http://www.w3.org/2000/svg'; var svg = document.createElementNS(char, 'svg'); svg.setAttribute('width', 500); svg.setAttribute('height', 300); svg.setAttribute('viewBox', '0 0 50 30'); var rect = document.createElementNS(char, 'rect'); rect.setAttribute('x', 10); rect.setAttribute('y', 10); rect.setAttribute('width', 20); rect.setAttribute('height', 10); rect.setAttribute('fill', 'deepskyblue'); svg.appendChild(rect); document.body.appendChild(svg); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas详细总结]]></title>
    <url>%2F2018%2F06%2F16%2Fe01_html5%2F</url>
    <content type="text"><![CDATA[canvas是什么 &lt;canvas&gt; 是HTML5新增的元素，可用于通过使用 JavaScript 中的脚本来绘制图形。例如他可以用来绘制图形、制作照片、创建动画、甚至可以进行实时的视频处理和渲染 需要强调的是，&lt;canvas&gt; 只是一个画布，本身并不具有画图能力，绘图必须使用 JavaScript 等脚本语言。 我们可以认为 canvas 是画布，JavaScript 是画笔 相关概念canvas元素定义 1&lt;canvas id='demo' width='500' height='500'&gt;&lt;/canvas&gt; 属性 width 和 height 属性用来设置 &lt;canvas&gt; 元素的大小，单位默认是像素；如果没有设置 width 和 height 值，其默认大小是 300 * 150；除了使用HTML标签中的 width 和 height 属性来设置大小，还可以通过CSS中的 width 和 height 以及JS中的 width 和 height 来设置 设置大小 前面我们了解了为 &lt;canvas&gt; 元素设置大小的方法有三种，接下来就看一下这三种设置方法到底有什么区别我们以在400 * 400 的画布上画一个半径为50px的圆为例，以此来观察用不同的方法设置画布的大小绘制图案造成什么影响 HTML设置大小 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #demo &#123; background-color: lightsalmon; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="demo" width="400" height="400"&gt;&lt;/canvas&gt; &lt;script&gt; var oCanvas = document.getElementById('demo'); var ctx = oCanvas.getContext('2d'); ctx.arc(100, 100, 50, 0, Math.PI * 2, true); ctx.fillStyle = 'lightgreen'; ctx.fill(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS设置大小 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #demo &#123; background-color: lightsalmon; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="demo"&gt;&lt;/canvas&gt; &lt;script&gt; var oCanvas = document.getElementById('demo'); var ctx = oCanvas.getContext('2d'); oCanvas.width = 400; oCanvas.height = 400; ctx.arc(100, 100, 50, 0, Math.PI * 2, true); ctx.fillStyle = 'lightgreen'; ctx.fill(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; CSS设置大小 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #demo &#123; width: 400px; height: 400px; background-color: lightsalmon; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="demo"&gt;&lt;/canvas&gt; &lt;script&gt; var oCanvas = document.getElementById('demo'); var ctx = oCanvas.getContext('2d'); ctx.arc(100, 100, 50, 0, Math.PI * 2, true); ctx.fillStyle = 'lightgreen'; ctx.fill(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，利用HTML标签和JS方法设置 &lt;canvas&gt; 元素的大小，结果都复合我们的预期，然而用CSS设置的情况下，圆竟然变形了，这是为什么呢？ 以CSS方法设置画布的大小，在绘制时图像会伸缩以适应它的框架尺寸：如果CSS的尺寸与初始画布的比例不一致，它会出现扭曲。 画布初始的大小（即默认大小）是 300px 150px，相当于HTML标签设置的大小是300 150，当用CSS属性设置画布的大小为 400px 400px时，画布会在HTML标签设置的大小的基础上进行缩放以适应后面设置的这个大小，换句话说就是将 300px 150px 大小的画布放在 400px * 200px 的容器中显示，在这个过程中，所以画布上的图像会发生扭曲变形，所以一般都采用HTML或者JS的方法来为画布设置大小，但是用CSS方法设置画布大小在解决 “canvas高分屏模糊” 的问题上有重要作用，后面会讲 渲染上下文定义 &lt;canvas&gt; 元素创造了一个固定大小的画布，它公开了一个或多个渲染上下文，其可以用来绘制和处理要展示的内容 获取方法 利用JavaScript中的 getContext() 方法，该方法接受一个参数：上下文格式 上下文格式可以是 2d、或者 webGL 等，这里我们只讨论二维平面，所以我们只需要将其参数设置为 2d 即可 兼容虽然现在主流的浏览器都已经较好的支持了 &lt;canvas&gt; 标签，但是有些老版本的浏览器，尤其是IE9以下的浏览器并不支持，所以考虑到使用 &lt;canvas&gt; 的友好性，提供两种方法 替换内容 在 canvas 的开始标签和闭合标签之间写入要替代的内容，这样，不支持 &lt;canvas&gt; 标签的浏览器会忽略容器，并在其中渲染后备内容；而支持 &lt;canvas&gt; 的标签则会忽略容器中的内容，只是正常的渲染 &lt;canvas&gt;元素 比如我们可以把文本或者图片当做替换内容 12345678&lt;body&gt; &lt;canvas id="demo" width="500" height="500"&gt; 如果不支持canvas元素就显示这段文字hhhhhhh &lt;/canvas&gt; &lt;canvas id="demo2"&gt; &lt;img src="http://ww1.sinaimg.cn/large/006eYMu7ly1ftgky0ok92j30g103ot8j.jpg" alt="如果不支持canvas就显示这张图片"&gt; &lt;/canvas&gt;&lt;/body&gt; PS：也正是因为canvas替换内容的这种机制，使canvas的闭合标签（&lt;/canvas&gt;）不可省略，因为如果省略的话，文档的其余部分都会被认为是替代内容导致canvas无法正常使用 检查支持性 通过简单的测试 getContext() 方法的存在，检查其可编程的支持性 123456var oCanvas = document.getElementById('demo');if (oCanvas.getContext()) &#123; // 绘图&#125; else &#123; // 如果不存在的操作&#125; 使用canvas准备步骤创建canvas元素1&lt;canvas id="myCanvas" width="500" height="500"&gt;&lt;/canvas&gt; 获取渲染上下文1234// 获取canvas元素var oCanvas = document.getElementById('myCanvas');// 获取该canvas元素的渲染上下文var ctx = oCanvas.getContext('2d'); 了解画布栅格的概念 在我们开始画图之前，我们需要了解一下画布栅格（canvas grid）以及坐标空间。 如下图所示，canvas元素默认被网格所覆盖。通常来说网格中的一个单元相当于canvas元素中的一像素。栅格的起点为左上角（坐标为（0,0））。所有元素的位置都相对于原点定位。所以图中蓝色方形左上角的坐标为距离左边（X轴）x像素，距离上边（Y轴）y像素（坐标为（x,y））。 绘制形状移动笔触想象真实环境中绘图的过程，在落笔开始绘制之前，我们是不是要先想好在哪落笔？canvas绘图也是一样，在绘图之前要现将画笔移动到开始绘制的地方 123var oCanvas = document.getElementById('myCanvas');var ctx = oCanvas.getContext('2d');ctx.moveTo(100, 100); // 把笔触移动到坐标为（100，100）的位置 绘制直线功能 绘制一条直线路径 语法 lineTo(x, y) 参数 含义 x 终止点的x坐标 y 终止点y的坐标 demo 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas class="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var oCanvas = document.getElementsByClassName('myCanvas')[0]; var ctx = oCanvas.getContext('2d'); ctx.moveTo(100, 100); ctx.lineTo(200, 200); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 预想中的结果：画布上有一条从（100,100）位置到（200， 200）位置的一条倾斜的直线 实际运行结果：画布上一片空白，什么都没有 出现这样结果的原因是，lineTo() 方法并不是直接绘制一条直线出来，而是绘制了一条直线路径，那什么是路径呢，接线来我们来仔细的讲解一下关于路径的概念 开始的位置 直线路径开始的位置有三种情况 当前路径下，起笔位置默认从上一次绘图结束的地方开始 如果使用了 moveTo() 方法，则从 moveT() 方法设定的位置开始 如果开启了一段新的路径，如果不用 moveTo() 方法设置其实点，则当前路径第一个 lineTo() 方法，会被当成 moveTo() 方法 路径概念 路径是图形的基本元素，从绘制起点到绘制终点所经历的这些点，就成为路径 使用路径绘图canvas中所有的基本图形，包括线段、矩形、圆弧、贝塞尔曲线等都时基于路径绘制的，简单地说就是我们要先绘制出路径，然后给这些路径添加颜色和样式，才有了我们能看到的图形，也就是说在给路径添加样式和颜色之前，我们是看不到它的。打个比方，以一张神秘的寻宝图为例，一般寻宝图不会直接将地图画在上面然我们看到，而是有一些 ”隐形“的路径，需要我们泼上墨汁等才能 “显形” ，我们才能看到所谓的寻宝路线，这里隐形的路线就相当于是我们的 “路径”，他确实存在但是我们还看不到，墨汁就相当于是我们要给路径添加的 “颜色和样式” 一个路径可以包含多个子路径，子路径也是由多个点组成的，在某一时刻，canvas中只能包含一条路径，canvas规范把它称为 当前路径 使用路径绘图的一般步骤为 调用 beginPath() 方法开始一条新的路径 使用 moveTo(x, y) 方法以（x，y）为起点开始一条新的子路径，并把画笔移动到该起点 定义子路径的内容（比如画一条直线路径、圆弧路径等） 调用 closePath() 方法封闭当前子路径（一定要注意是封闭路径，而不是关闭路径） 调用 stroke() 或 fill() 方法显示路径 （描边、填充） 说明： beginPath() 方法不是必须的 比如画布的初始状态默认就是一条新的路径，如果是第一次在画布上作图，不需要开启新的路径；同样，如果所有绘制的图形都在一条路径下，那也不需要开启新的路径 moveTo(x, y) 方法不是必须的 第一条路径默认是画布的原点，其他子路径的起点是上一次路径的终点，因此，再不需要重新指定子路径起点的情况先，他不是必须的 定义子路径的内容 以绘制直线中我们demo为例，从（100,100）到（200,200）绘制了一条直线路径，这个过程就是定义子路径的内容 closePath() 方法不是必须的 closePath() 方法是用来封闭当前路径的，在我们的绘制中，往往一条子路径就是一个图形，所以也可以把它的功能理解为闭合图形的，它的作用是将当前子路径的终点与当前子路径的起点相连，如果我们的图形原本就是封闭的或者我们不希望图形被封闭，那就不需要调用这个方法 使用 stroke() 或 fill() 方法显示路径 这里 stroke() 方法相是给路径描边，fill() 方法是填充路径，这两个方法的作用就是让路径显示出来能被我们看到，至于以什么样式和颜色显示出来，是颜色和样式要讲的内容，这里不提 每调用一次 beginPath() 方法，会定义一条新的路径，会把当前路径列表清空重置，注意这里的清空不是说之前绘制图形就从画布上消失了，它们不会消失，这里清空的是路径，这意味着我们可以开始新的图形绘制，使新的绘制不会与之前的图形有相互影响 每使用 beginPath() 开启新的路径，一般都要使用 moveTo(x, y) 方法设置起始位置，所以这两个方法一般是成对出现的 五个方法 beginPath()：开启一条新的路径 moveTo(x, y)：移动笔触，开启一条子路径 closePath()：封闭（闭合）当前子路径 stroke()：描边 fill()：填充，自动闭合所有的子路径 举例 绘制一条直线 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas class="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var oCanvas = document.getElementsByClassName('myCanvas')[0]; var ctx = oCanvas.getContext('2d'); ctx.beginPath(); ctx.moveTo(100, 100); ctx.lineTo(200, 200); ctx.stroke(); // 给路径描边 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 绘制一个三角形，用stroke描边 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas class="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var oCanvas = document.getElementsByClassName('myCanvas')[0]; var ctx = oCanvas.getContext('2d'); ctx.beginPath(); ctx.moveTo(100, 100); ctx.lineTo(200, 100); ctx.lineTo(200, 200); ctx.closePath(); ctx.stroke(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这个例子我们只用 lineTo(x, y) 方法画了两条直角边，斜边是调用 closePath() 方法，闭合当前路径自动连上的，假如说我们在 closePath() 语句的位置写了 lineTo(100, 100) ，就不需要 closePath() 方法了，效果是一样的（PS: 线比较细时效果是一样的，但是当线条变粗是效果就明显不一样了，这里买个伏笔，后买讲到样式的时候再解释） 绘制一个三角形，用fill填充 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas class="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var oCanvas = document.getElementsByClassName('myCanvas')[0]; var ctx = oCanvas.getContext('2d'); ctx.beginPath(); ctx.moveTo(100, 100); ctx.lineTo(200, 100); ctx.lineTo(200, 200); ctx.fill(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 看代码，这里我们并没有使用 closePath() 方法闭合路径，因为当我们使用 fill() 的时候，所有没有闭合的图形都会自动闭合，所以不需要使用 closePath() 方法 绘制两个三角形，一个用红色填充，一个用绿色填充 为了实现这个demo，这里先提示一下设置填充颜色的方法，即在使用 fill() 方法前，给 fill() 方法设置样式，利用 fillStyle = color 的方法，颜色值可以是任何形式 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas class="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var oCanvas = document.getElementsByClassName('myCanvas')[0]; var ctx = oCanvas.getContext('2d'); // 绘制第一个三角形 ctx.beginPath(); ctx.moveTo(100, 100); ctx.lineTo(200, 100); ctx.lineTo(200, 200); ctx.fillStyle = 'rgba(255, 0, 0)'; ctx.fill(); // 绘制第二个三角形 ctx.moveTo(250, 100); ctx.lineTo(350, 100); ctx.lineTo(350, 200); ctx.fillStyle = 'rgba(0, 255, 0)'; ctx.fill(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 看完代码，在没有看运行结果前，你一定以为结果是这样的 然后结果却是 是不是心态爆炸，其实这就是我们之前一直强调的路径问题，再开代码，我们先用 beginPath() 方法开启一条新的路径，然后用 moveTo(100, 100) 方法开启一条新的子路径，在这个子路径上绘制了第一个三角形路径，填充为红色；接着我们又用 moveTo(350, 100) 开启了另一条子路径，在这个子路径上绘制了第二个三角形路径，填充为绿色；需要强调的是，这两个子路径都在同一条路径下，同一路径下的不同子路径之间的样式颜色等会产生相互影响，比如我们这个例子中，两个路径上的三角形都显示了第二条路径上的颜色，所以如果我们要设置不同的颜色，就要让他们之间无关联不会相互影响，方法很简单，就是为每一个图形都开启一条新的路径，而不是子路径 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas class="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var oCanvas = document.getElementsByClassName('myCanvas')[0]; var ctx = oCanvas.getContext('2d'); // 开启一条路径（可省略，因为画布初始状态就是一条新的路径），绘制第一个三角形 ctx.beginPath(); ctx.moveTo(100, 100); ctx.lineTo(200, 100); ctx.lineTo(200, 200); ctx.fillStyle = 'rgba(255, 0, 0)'; ctx.fill(); // 开启一条新的路径，绘制第二个三角形 ctx.beginPath(); ctx.moveTo(250, 100); ctx.lineTo(350, 100); ctx.lineTo(350, 200); ctx.fillStyle = 'rgba(0, 255, 0)'; ctx.fill(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 不同子路径之间是怎么相互影响的上面两个画两个三角形的例子说明了不同子路径之间会相互影响，那他们之间到底是怎么影响的呢？看了三角形的例子，你可能会这样想，第二条路径设置了绿色，然后第一条路径上得三角形也变成绿色，那不就是后面路径上的样式覆盖掉了前面路径上的样式么？这么说可能不太准确，下面用两句话来说明他们之间的影响，后续的解释也将围绕这两句话展开 样式生效即存在 子路径上的颜色或样式，会作用在当前的整个路径上 样式生效即存在 首先看下面一个例子 12345var a;a = 1;console.log(a);a = 2;console.log(a); 因为JS是顺序执行的，所以这里第一次打印结果是1，第二次打印结果是2，类比到画三角形的例子 1234ctx.fillStyle = 'rgba(255, 0, 0)';ctx.fill();ctx.fillStyle = 'rgba(0, 255, 0)';ctx.fill(); ctx.fillStyle = &#39;rgba(255, 0, 0)&#39;; 相当于 a = 1 ，第一个 ctx.fill() 相当于第一个 console.log(a)，这里的样式应用成功即生效，生效即存在，就是说第一个三角形已经被填充为红色且存在于画布上，那为什么最终只看到了绿色而没有红色的区域呢？别急，我们只看了一半（第一个子路径），剩下的一半（第二个子路径）我们结合第二句话来看 子路径上的颜色样式，会作用在当前的整个路径上 两个三角形分别代表当前路径下的一个子路径，设置在子路径上的样式，都会作用在当前的整个路径上，我们一步一步来看，在开启第二条路径之前，只有第一个三角形所在的一条子路径，所以它也就是当前的整个路径，所以样式作用在整个路径上就是作用在第一个三角形所在的子路径上，这是第一个三角形所在的子路径变成红色；然后开启第二条子路径，这时当前的整个路径是第一条子路径加上第二条子路径，所以给第二条子路径设置的样式会作用在整个路径上也就是第一条子路径加第二条子路径上，这时两条子路径上的三角形都会应用绿色样式，那么问题来了，对于第二条子路径，本来就没什么样式，现在给他应用绿色的样式，他肯定是绿色没有问题，那对于第一条子路径呢，在这之前它是红色，难道在他应用了绿色的样式以后红色的样式就不存在了么？答案是否定的，上一句话就说过，生效即存在，他已经生效了那他就存在于画布上，那他去哪了呢？ 还是画两个三角形的例子，这次我们给每个三角形添加上0.5的透明度 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas class="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var oCanvas = document.getElementsByClassName('myCanvas')[0]; var ctx = oCanvas.getContext('2d'); // 开启一条路径（可省略，因为画布初始状态就是一条新的路径），绘制第一个三角形 ctx.beginPath(); ctx.moveTo(100, 100); ctx.lineTo(200, 100); ctx.lineTo(200, 200); ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; ctx.fill(); // 开启一条新的路径，绘制第二个三角形 ctx.moveTo(250, 100); ctx.lineTo(350, 100); ctx.lineTo(350, 200); ctx.fillStyle = 'rgba(0, 255, 0, 0.5)'; ctx.fill(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果是这样的 很明显，这两个绿色不太一样，第一个绿色要深一些，原因是绿色底下还有红色，在没有设置透明度之前绿色把红色区域给挡住了，所以好像看起来红色没有了，但其实红色依然存在于画布上，只是被绿色区域给挡住了，现在我们设置了透明度，看到的就是两种颜色叠加在一起的颜色了 至此，我们搞清楚了不同路径之间是怎么相互影响的：当前路径下，每一条子路径的样式都会作用在当前的整个路径下，已经生效的样式即存在于画布上，不会消失 矩形四种绘制方法 rect(x, y, width, height) strokeRect(x, y, width, height) fillRect(x, y, width, height) clearRect(x, y, width, height) rect(x, y, width, height) 功能 绘制一个矩形路径 参数 x, y：矩形左上角在坐标轴上的坐标 width：矩形的宽度 height：矩形的高度 说明 方法需要选择（x，y）的坐标，说明该方法会开启一条新的路径 因为是绘制一条路径，所以如果想要看到，需要给它描边或者填充 练习 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var oCanvas = document.getElementById('myCanvas'); var ctx = oCanvas.getContext('2d'); ctx.rect(100, 100, 200, 100); ctx.stroke(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; strokeRect(x, y, width, height) 功能 绘制一条矩形路径并描边 参数 同上 练习 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var oCanvas = document.getElementById('myCanvas'); var ctx = oCanvas.getContext('2d'); ctx.strokeRect(100, 100, 200, 100); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; fillRect(x, y, width, height) 功能 绘制一条矩形路径并填充 参数 同上 练习 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var oCanvas = document.getElementById('myCanvas'); var ctx = oCanvas.getContext('2d'); ctx.fillRect(100, 100, 200, 100); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; clearRect(x, y, width, height) 功能 清除一块矩形区域 参数 同上 练习 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var oCanvas = document.getElementById('myCanvas'); var ctx = oCanvas.getContext('2d'); ctx.fillRect(100, 100, 200, 100); ctx.clearRect(150, 125, 100, 50); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 圆弧 arc(x, y, raidus, startAngle, endAngle, anticlockwise) arcTo(x1, y1, x2, y2, radius) arc(x, y, radius, startAngle, endAngle, direction） 功能 以给定的点连接当前点，(下面有解释)，并按要求绘制圆弧路径 参数 (x, y)：圆心在坐标轴上的位置 radius：圆弧路径的半径 startAngle：圆弧路径的起始位置 endAngle：圆弧路径的终止位置 direction：圆弧路径绘制的方向 说明 如果绘制圆弧子路径前开启了新的路径，那么当前点就是(x, y) 如果绘制圆弧子路径前没有开启新的路径，那么当前点为上一子路径的终点或者是使用 moveTo(x, y) 方法设置的点 起始弧度和终止弧度必须用 弧度（Math.PI） 来描述，比如 45度应该用 Math.PI * 1 / 4 来描述 路径绘制的方向有顺时针和逆时针两种，true 为逆时针（默认），false 为顺时针 练习 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var oCanvas = document.getElementById('myCanvas'); var ctx = oCanvas.getContext('2d'); ctx.arc(100, 100, 50, 0, Math.PI, false); ctx.stroke(); // ctx.beginPath(); ctx.arc(300, 100, 50, 0, -Math.PI, true); ctx.stroke(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开注释前 打开注释后 arcTo(x1, y1, x2, y2, radius) 功能 绘制的弧线路径与当前点和(x1,y1)连线，(x1,y1)和(x2,y2)连线都相切 参数 (x1, y1)：与当前点进行连接的点 (x2, y2)：与(x1, y1)进行连接的点 radius：与两条直线相切的圆的半径 说明 这里的当前点和上一个当前点不太一样，这里的当前点要通过 moveTo(x, y) 方法进行设置，如果不设置的话，他会找当前路径下上一个子路径的终点作为当前点，如果没有这个值的话，就不能绘制出图形，也就是说只要使用了 beginPath() 开启路径，就要先用 moveTo(x, Y) 方法设置当前点，然后才能开始使用这个方法（因为新开启的路径中肯定没有上一个路径的终点） 练习 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var oCanvas = document.getElementById('myCanvas'); var ctx = oCanvas.getContext('2d'); ctx.moveTo(100, 100); ctx.arcTo(200, 100, 200, 200, 50); ctx.stroke(); // ctx.moveTo(300, 100); ctx.arcTo(400, 100, 400, 200, 50); ctx.stroke(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开注释前： 打开注释后： 贝塞尔曲线 介绍 N次贝塞尔曲线有一个开始点，一个结束点，N-1个控制点 二次贝塞尔曲线 三次贝塞尔曲线 四次贝塞尔曲线 五次贝塞尔曲线 以上时二次~五次贝塞尔曲线的运动轨迹，其中二次和三次使用较多，这里了解一下二次贝塞尔曲线的运动轨迹 P0和P2分别称为开始点和结束点，P1称为控制点，假设有两点分别从P0和P1同时出发，要求从P0出发的的点到达P1的时间，和从P1出发的点到达P2的时间相同，运动过程中，过P0作两个运动的点的连线（绿线）的切线（红线），这个切线就是二次贝塞尔曲线 三次、四次、五次贝塞尔曲线同理 语法（二次） quadraticCurve(x1, y1, endX, endY); 功能 以当前点为开始点，与参数中的控制点和结束点一起构成二次贝塞尔曲线 参数（二次贝塞尔曲线） (x1, y1)：控制点的坐标 (endX, endY)：结束点的坐标 说明 当前点的含义与 arcTo() 方法中当前点的含义相同 练习 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); // 二次贝塞尔曲线 ctx.beginPath(); ctx.moveTo(75, 25); ctx.quadraticCurveTo(25, 25, 25, 62.5); ctx.quadraticCurveTo(25, 100, 50, 100); ctx.quadraticCurveTo(50, 120, 30, 125); ctx.quadraticCurveTo(60, 120, 65, 100); ctx.quadraticCurveTo(125, 100, 125, 62.5); ctx.quadraticCurveTo(125, 25, 75, 25); ctx.stroke(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); //三次贝塞尔曲线 ctx.beginPath(); ctx.moveTo(75, 40); ctx.bezierCurveTo(75, 37, 70, 25, 50, 25); ctx.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5); ctx.bezierCurveTo(20, 80, 40, 102, 75, 120); ctx.bezierCurveTo(110, 102, 130, 80, 130, 62.5); ctx.bezierCurveTo(130, 62.5, 130, 25, 100, 25); ctx.bezierCurveTo(85, 25, 75, 37, 75, 40); ctx.fill(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Path2D对象（没搞懂，等待补充）颜色和填充样式颜色我们之前了解了使用 stroke() 方法和 fill() 方法可以显示路径，stroke() 相当于是画笔，fill() 相当于是刷子，通过改变这些 “工具”的颜色，可以让路径显示不同的颜色 strokeStyle 语法 strokeStyle = color color color可以是颜色名(re)、rgb(255, 0, 0),、rgba(255, 0, 0, 1)、颜色代码(#FF0000) fillStyle 语法 fillStyle = color color 颜色名、rgb、rgba、颜色代码 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ctx.beginPath(); ctx.strokeStyle = 'red'; ctx.strokeRect(100, 100, 200, 100); ctx.beginPath(); ctx.fillStyle = 'green'; ctx.fillRect(350, 100, 100, 100); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 透明度全局透明度 功能 给画布中所有元素设置透明度，使用以下语法 语法 globalAlpha = value value的取值：0.0~1.0 demo 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ctx.globalAlpha = 0.2; ctx.beginPath(); ctx.fillStyle = 'red'; ctx.fillRect(100, 100, 200, 100); ctx.beginPath(); ctx.fillStyle = 'green'; ctx.fillRect(350, 100, 100, 100); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 局部透明度 功能 给指定的元素设置透明度 语法 要给那个元素单独设置透明度，就要在给这个元素设置颜色时，采用rgba的方法设置 demo 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ctx.beginPath(); ctx.fillStyle = 'rgba(255, 0, 0, 0.2)'; ctx.fillRect(100, 100, 200, 100); ctx.beginPath(); ctx.fillStyle = 'green'; ctx.fillRect(350, 100, 100, 100); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 线型可以通过一系列属性来设置线的样式 lineWidth 功能 设置线的宽度 语法 lineWidth = value value是正整数，默认值是1 线宽 线宽是指给定路径的中心到两边的粗细。换句话说就是在路径的两边各绘制线宽的一半。 图像不能精确呈现的问题 首先一个实例来说明要讲的问题，我们在画布的两个不同的位置各画一条 lineWidth = 1 的直线 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ctx.moveTo(100, 100); ctx.lineWidth = 1; ctx.lineTo(200, 100); ctx.moveTo(100, 110.5); ctx.lineTo(200, 110.5); ctx.strokeStyle = 'deepskyblue'; ctx.stroke(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 很明显，虽然我们给这两条直线设置了相同的线宽，但是他们显示出来的宽度确不一样，下面那条比较标准，上面那条变宽了，这是为什么呢？要解决这个问题，我们需要先了解坐标网格中的一些概念 坐标网格中的一些概念 坐标点 坐标网格中坐标轴相交的点。如上图所示的(0, 0)点、(5, 5)点 像素 坐标网格中一个单元格代表一像素。上图画出了两个像素（紫色区域） 半像素 坐标网格中一个单元格的一部分，半像素不一定必须是像素的一半，只要是一个完整像素的一部分，都可以称为是半像素。上图画出了两个半像素（粉色区域） 半像素的渲染方式 如果给半像素指定了渲染颜色，则该像素单元格中的其余部分会以指定渲染颜色一半的色调来填充满整个区域 解释线宽不准确的原因 了解了以上的概念后就很好理解为什么同样是1单位的线宽呈现结果会不同了 左图在坐标网格(3,1)到(3,5)的区域绘制了一条直线路径，线宽为1单位所以向左右各延展0.5单位，这时问题来了，因为只想左右延展了0.5个单位，那么就存在半像素，半像素的剩余部分会渲染颜色一半的色调来填充，所以我们最后看到的其实是2单位线宽的直线 右图在坐标网格(3.5,1)到(3.5,5)的区域绘制了一条直线路径，线宽为1单位向左右两侧延展0.5单位，这时左右两侧的渲染区域就正好是1个单位的像素，不存在半像素，所以直线的线宽是准确的 结论 图像能否精确展示，和路径的定义的位置有关，最终着色的部分的边缘落在坐标网格的轴线上，那么就不存在半像素的问题，可以精确展示；最终着色部分的边缘落在坐标网格内，那么久存在半像素的问题，展示结果就会不精确 图形闭合处锯齿问题 还是先来看一个例子，绘制一个三角形，线宽为10 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ctx.moveTo(100, 100); ctx.lineTo(200, 100); ctx.lineTo(100, 200); ctx.lineTo(100, 100); ctx.lineWidth = 10; ctx.stroke(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果如图，将直线练回起点想要封闭图形时，发现不能完全封闭，存在类似锯齿的小缺口，解决这样的问题很简单，使用 closePath() 方法封闭路径即可 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ctx.moveTo(100, 100); ctx.lineTo(200, 100); ctx.lineTo(100, 200); // 如果使用closePath()方法封闭路径，那么这条语句就没什么必要了 // ctx.lineTo(100, 100); ctx.lineWidth = 10; ctx.closePath(); ctx.stroke(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; lineCap 功能 决定线段端点显示的样子 语法 lineCap = &#39;butt&#39;(默认) | &#39;round&#39; | &#39;square&#39;; butt：与辅助线平齐 round：端点处加上了直径为线宽的半圆 square：端点处加上了宽高为线宽的矩形 lineJoin 功能 定义了线段在连接处所显示的样子 语法 lineJoin = &#39;round&#39; | &#39;bevel&#39; | &#39;miter&#39;(默认); round：接口处是圆角。圆的半径等于线宽 bevel：接口处是斜线。 miter：线段在连接处外侧延伸直至交于一点 miterLimit 针对 lineJoin = &#39;miter&#39;，为了防止线段连接处延伸过远，使用 miterLimit 属性可以限制其延伸，当lineJoin是miter时，用于控制斜接部分的长度 PS：实际运算是大于limit*lineWidth/2的值，了解就好 练习 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ctx.moveTo(100, 100); ctx.lineTo(200, 100); ctx.lineTo(100, 120); ctx.closePath(); ctx.lineWidth = 10; ctx.lineJoin = 'miter'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(250, 100); ctx.lineTo(350, 100); ctx.lineTo(250, 120); ctx.closePath(); ctx.lineJoin = 'miter'; ctx.miterLimit = 20; ctx.stroke(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 虚线 功能 如题 语法 setLineDash(prop); 参数 参数prop是一个数组，用来制定线段与间隙的交替 如：[10, 5] ———————- [线长是10，线之间的间隙是5，…….] 如此反复交替 ​ [40, 30, 20, 10] ———- [线长40，间隙30，线长20，间隙10，线长40，……] 如此反复交替 ​ [40, 30, 20] ————— 如果参数是奇数个，数组会先复制一次，变成偶数个参数，然后同上 练习 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ctx.beginPath(); ctx.moveTo(0, 100); ctx.setLineDash([40, 30]); ctx.lineTo(500, 100); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, 150); ctx.setLineDash([40, 30, 20, 10]); ctx.lineTo(500, 150); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, 200); ctx.setLineDash([40, 30, 20]); ctx.lineTo(500, 200); ctx.stroke(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果想要变回直线，可以利用这个巧妙地方法：ctx.setLineDash([]); 渐变 功能 可以利用渐变来进行填充或者描边 使用方法 创建 canvasGradient 对象 线性渐变 creatLinearGradient(x1, y1, x2, y2) (x1, y1)：渐变的起点 (x2, y2)：渐变的终点 径向渐变 createRadialGradient(x1, y1, r1, x2, y2, r2) (x1, y1, r1)：渐变开始的圆 (x2, y2, r2)：渐变结束的圆 给 canvasGradient 对象添加渐变色 方法 canvasGradient.addColorStop(position, color) 参数 position：0.0~1.0之间的数值，表示渐变颜色的相对位置 color：必须是一个有效的CSS颜色值 将 canvasGradient 对象赋给 strokeStyle 或者 fillStyle 使用 练习 线性渐变 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); var linearGradient = ctx.createLinearGradient(100, 100, 100, 200); ctx.beginPath(); linearGradient.addColorStop(0, 'red'); linearGradient.addColorStop(0.3, 'green'); linearGradient.addColorStop(0.4, 'blue'); linearGradient.addColorStop(1.0, 'transparent'); ctx.fillStyle = linearGradient; ctx.fillRect(100, 100, 200, 100); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 径向渐变 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); var radialGradient = ctx.createRadialGradient(200, 150, 10, 250, 150, 100); ctx.beginPath(); radialGradient.addColorStop(0, 'red'); radialGradient.addColorStop(0.3, 'green'); radialGradient.addColorStop(0.6, 'blue'); radialGradient.addColorStop(1.0, 'transparent'); ctx.fillStyle = radialGradient; ctx.arc(250, 150, 100, 0, Math.PI * 2, true); ctx.fill(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 填充图案 功能 与渐变功能相似，只不过填充的是图案 使用方法 创建 pattern 对象 语法 pattern = createPattern(image, type) 参数 image：img元素、canvas元素、video元素（有图形的） type：repeat | repeat-x | repeat-y | no-repeat 注意 如果参数是img元素，那么这个方法要等到图片加载完成之后才能使用 将 pattern 对象赋给 strokeStyle 或者 fillStyle 使用 练习 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); var oImg = new Image(); oImg.src = 'http://ww1.sinaimg.cn/large/006eYMu7ly1ftioar0jtnj308w050jv1.jpg'; oImg.onload = function () &#123; ctx.fillStyle = ctx.createPattern(oImg, 'repeat'); ctx.fillRect(0, 0, 500, 300); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 阴影 功能 如题 使用方法 设置阴影半径 shadowBlur = float 设置横纵偏移量 shadowOffsetX = float shadowOffsetY = float 设置阴影颜色 shadowColor = color 练习 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ctx.beginPath(); ctx.shadowBlur = 10; ctx.shadowOffsetX = 10; ctx.shadowOffsetY = 10; ctx.shadowColor = '#ccc'; ctx.fillStyle = '#999'; ctx.fillRect(100, 100, 200, 100); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 绘制文本storkeText() 功能 在指定区域描绘文本 语法 strokeText(text, x, y [, maxWidth]) 参数 text 文本内容 (x, y) 文本起点坐标 maxWidth 可选项，表示绘制的最大宽度，如果指定了该值，并且经过计算字符串的值比最大宽度还要宽，字体为了适应会水平缩放（如果通过水平缩放当前字体，可以进行有效的或者合理可读的处理）或者使用小号的字体。 fillText() 功能 在指定区域填充文本 语法 fillText(text, x, y [, maxWidth]) 参数 同 strokeText() 设置文本样式在绘制文本之前我们可以通过一些属性来设置要绘制的文本的样式 字体样式 功能 设置字体的大小、风格等，同CSS种 font 用法相同 语法 font = &quot;font-style font-variant font-width font-size font-family&quot; 参数 默认值是：”10px sans-serif” 其他的不解释了，不懂先去学css 文本对齐选项引入 前面绘制本文的样式语法中提到，要绘制文本需要文本内容和起始点的坐标，现在我们把关注点放在起始点的坐标上，抛出一个问题，这个起始点的坐标是文本内容区域的哪一个点呢？（以绘制矩形为例，绘制矩形的起始点是矩形的左上角顶点在坐标轴中的位置）为了解决这个问题，我们来看下面两个属性 textAlign 功能 文本在水平方向的对齐选项 语法 textAlign = &#39;start&#39;(默认) | &#39;end&#39; | &#39;left&#39; | &#39;right&#39; | &#39;center&#39;; 图解参数 起始点x的坐标在蓝色的线上，蓝色的线与文本展示了不同对齐方式水平上的差别 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ctx.strokeStyle = "blue"; ctx.moveTo(250, 20); ctx.lineTo(250, 280); ctx.stroke(); ctx.font = "15px Arial"; ctx.textAlign = "start"; ctx.fillText("textAlign=start", 250, 50); ctx.textAlign = "end"; ctx.fillText("textAlign=end", 250, 100); ctx.textAlign = "left"; ctx.fillText("textAlign=left", 250, 150); ctx.textAlign = "center"; ctx.fillText("textAlign=center", 250, 200); ctx.textAlign = "right"; ctx.fillText("textAlign=right", 250, 250); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; textBaseLine 功能 文本在竖直方向上的对齐选项 语法 textBaseline = &#39;top&#39; | &#39;hanging&#39; | &#39;middle&#39; | &#39;alphabetic&#39;(默认) | &#39;ideagrophic&#39; | &#39;bottom&#39;; 图解参数 起始点y的坐标在蓝色的线上，蓝色的线与文本展示了不同对齐方式在竖直方向上的差别 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); //在位置 y=150 绘制蓝色线条 ctx.strokeStyle = "blue"; ctx.moveTo(5, 150); ctx.lineTo(495, 150); ctx.stroke(); ctx.font = "20px Arial" //在 y=200 以不同的 textBaseline 值放置每个单词 ctx.textBaseline = "top"; ctx.fillText("Top", 25, 150); ctx.textBaseline = "bottom"; ctx.fillText("Bottom", 80, 150); ctx.textBaseline = "middle"; ctx.fillText("Middle", 180, 150); ctx.textBaseline = "alphabetic"; ctx.fillText("Alphabetic", 280, 150); ctx.textBaseline = "hanging"; ctx.fillText("Hanging", 400, 150); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 下面的图片展示了textBaseline属性支持的不同的基线情况 变形我们之前学习的坐标网格和画布，都是默认情况下的状态。通过变形，我们可以将原点移动到另外一点，可以对网格进行旋转和缩放等操作 状态保存和恢复状态保存 save() 方法，和状态恢复 restore() 方法是用来保存和恢复canvas状态的。canvas状态就是当前画面应用的所有样式和变形的一个快照 一个canvas状态包括： 当前应用的变形（即移动、旋转和缩放） strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值 当前的裁切路径（后面会讲到） Canvas状态存储在栈中，每当 save() 方法被调用后，当前的状态就被推送到栈中保存；每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复 移动 功能 用来移动canvas和坐标原点到另外一个位置 语法 translate(x, y) 参数 x：左右偏移量 y：上下偏移量 注意 在进行移动之前先保存状态是一个好习惯 练习 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'), oImg = new Image(); oImg.src = 'https://ws1.sinaimg.cn/large/006eYMu7ly1ftiw9x8975j30dw08cwnv.jpg'; oImg.onload = function ()&#123; ctx.beginPath(); ctx.save(); ctx.translate(50, 50); ctx.fillStyle = ctx.createPattern(oImg, 'no-repeat'); ctx.fillRect(0, 0, 500, 300); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 图片是充满整个canvas的，所以图片的变换就能体现canvas的变化 如果我们要接着在画布上移动前的(0, 0) 的位置填充一个边长为50的正矩形，如果不用 restore() 方法的话，就要用 restore()方法先恢复到平移前的状态 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'), oImg = new Image(); oImg.src = 'https://ws1.sinaimg.cn/large/006eYMu7ly1ftiw9x8975j30dw08cwnv.jpg'; oImg.onload = function ()&#123; ctx.beginPath(); ctx.save(); ctx.translate(50, 50); ctx.fillStyle = ctx.createPattern(oImg, 'no-repeat'); ctx.fillRect(0, 0, 500, 300); ctx.restore(); ctx.fillStyle = 'yellow'; ctx.fillRect(0, 0, 50, 50); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 旋转 功能 以原点为中心，旋转canvas 语法 rotate(angle) 参数 angle：旋转的角度值，顺时针方向，以弧度为单位值 练习 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'), oImg = new Image(); oImg.src = 'https://ws1.sinaimg.cn/large/006eYMu7ly1ftiw9x8975j30dw08cwnv.jpg'; oImg.onload = function ()&#123; ctx.beginPath(); ctx.save(); ctx.rotate(Math.PI * 1 / 10); ctx.fillStyle = ctx.createPattern(oImg, 'no-repeat'); ctx.fillRect(0, 0, 500, 300); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 图片是充满整个canvas的，所以图片的变换就能体现canvas的变化 如果我们要接着在画布上旋转前的(200, 0) 的位置填充一个边长为50的正矩形，如果不用 restore() 方法的话，就要用 restore()方法先恢复到平移前的状态 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'), oImg = new Image(); oImg.src = 'https://ws1.sinaimg.cn/large/006eYMu7ly1ftiw9x8975j30dw08cwnv.jpg'; oImg.onload = function ()&#123; ctx.beginPath(); ctx.save(); ctx.rotate(Math.PI * 1 / 10); ctx.fillStyle = ctx.createPattern(oImg, 'no-repeat'); ctx.fillRect(0, 0, 500, 300); ctx.restore(); ctx.fillStyle = 'yellow'; ctx.fillRect(200, 0, 50, 50); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 缩放 功能 我们用它来增减图形在 canvas 中的像素数目，对形状，位图进行缩小或者放大 语法 scale(x, y) 参数 x：横轴上的缩放因子 y：纵轴上的缩放因子 默认情况下，canvas 的 1 单位就是 1 个像素。举例说，如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。同理，设置为 2.0 时，1 个单位就对应变成了 2 像素，绘制的结果就是图形放大了 2 倍。 练习 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'), oImg = new Image(); oImg.src = 'https://ws1.sinaimg.cn/large/006eYMu7ly1ftiw9x8975j30dw08cwnv.jpg'; oImg.onload = function ()&#123; ctx.beginPath(); ctx.save(); ctx.scale(0.5, 0.5); ctx.fillStyle = ctx.createPattern(oImg, 'no-repeat'); ctx.fillRect(0, 0, 500, 300); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; transform 功能 将移动、旋转、缩放功能合到了一起 语法 setTransform(a, b, c, d, e, f) transform(a, b, c, d, e, f) 两种方法不同 第一种是先重置之前画布上进行的变形操作，然后再进行自己的变形操作，及不受前面操作的影响 第二种是在之前画布变形操作的基础上进行操作，受前面操作的影响，一般不使用这种方法 参数 a：水平缩放 b：水平倾斜 c：垂直倾斜 d：垂直缩放 e：水平移动 f：垂直移动 练习 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;button style="display: block;"&gt;setTransform&lt;/button&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'), btn = document.getElementsByTagName('button')[0]; if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ctx.beginPath(); ctx.font = '20px arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('Hello World', 250, 150); function sovle() &#123; ctx.clearRect(0, 0, 500, 300); ctx.setTransform(1, -0.12, 0.2, 1, 0, 12); ctx.fillText('Hello World', 250, 150); &#125; &#125; btn.onclick = function () &#123; sovle(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 合成与剪裁裁剪 功能 将当前绘制的路径裁剪下来，裁剪区域外的区域不能继续绘制 语法 clip() 说明 如果在裁剪完之后还想在画布上裁剪区域以外的区域绘制，需要利用 save() 方法保存裁剪前的画布状态，然后利用 restore() 方法恢复保存的状态 练习 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ctx.beginPath(); ctx.arc(250, 150, 100, 0, Math.PI * 2, true); ctx.stroke(); // ctx.save(); ctx.clip(); ctx.font = '20px arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("被裁减的区域", 250, 150); // ctx.restore(); ctx.moveTo(0, 0); ctx.fillRect(0, 0, 100, 100); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 裁剪了一个圆形区域后，我想在画布上圆形区域以外在填充一个矩形，发现没有效果，因为被裁减区域以外的区域无法继续绘制，所以需要使用 save() 和 resotre() 方法（将上述代码的注释打开） 合成 功能 当两个图形重合时，控制他们该以什么样的形式合成 语法 globalCompositeOperation = value value 11种值，默认是 “source-over” 练习 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ctx.beginPath(); ctx.fillStyle = 'rgba(255, 0, 0)'; ctx.fillRect(100, 100, 150, 100); ctx.globalCompositeOperation = 'source-over'; ctx.globalCompositeOperation = 'source-atop'; ctx.globalCompositeOperation = 'source-in'; ctx.globalCompositeOperation = 'source-out'; ctx.globalCompositeOperation = 'destination-over'; ctx.globalCompositeOperation = 'destination-atop'; ctx.globalCompositeOperation = 'destination-in'; ctx.globalCompositeOperation = 'destination-out'; ctx.globalCompositeOperation = 'copy'; ctx.globalCompositeOperation = 'lighter'; ctx.globalCompositeOperation = 'xor'; ctx.beginPath(); ctx.fillStyle = 'rgba(0, 255, 0)'; ctx.fillRect(150, 150, 150, 100); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 逐行注释，观察效果 使用图片 canvas更有意思的一项特性就是图像操作能力。可以用于动态的图像合成或者作为图形的背景，以及游戏界面（Sprites）等等。浏览器支持的任意格式的外部图片都可以使用，比如PNG、GIF或者JPEG。 你甚至可以将同一个页面中其他canvas元素生成的图片作为图片源。 既然我们要利用canvas处理图片，那么首先我们要获取到图片，然后将图片绘制到canvas中，这时我们便可以利用canvas中提供的API对绘制的图片进行一系列的操作，紧接着我们还可以将处理完成的图片导出，这便是一个canvas处理图片比较完整的流程 获取图片图片类型 这里我们说的图片是泛指，它包括图片类型但是不限于图片类型，它的类型可以是下列几种类型 HTMLImageElement 由 Image()方法构造出来的，或者是用 JS 获取的 &lt;img&gt;类型的dom元素 HTMLCanvasElement 可以是另外一个canvas元素 HTMLVideoElement 用一个HTML的 &lt;video&gt; 元素作为你的图片源，可以从视频中抓取当前帧作为一个图像 ImageBitmap 这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成 获取图片 获取 HTMLImageElement 类型的图片 ！！！使用这种方法格外需要注意的一点就是要等图片加载完毕之后再进行对图片的操作 使用 Image() 方法创建一个img对象 使用这种方法是创建一个图片元素，需要指定image对象的 src 属性 12345var oImg = new Image();oImg.src = 'demo.jpg';oImg.onload = function () &#123; // 处理图片操作&#125; 使用 data:url 方法来引用图像 data:url 允许使用一串 base64 格式编码的字符串来定义一个图片 1img.src = 'data:image/gif;base64,R0lGODlhCwALAIAAAAAA3pn/ZiH5BAEAAAEALAAAAAALAAsAAAIUhA+hkcuO4lmNVindo7qyrIXiGBYAOw=='; 优点：图片内容即时可用，无需向服务器请求 缺点：图像没法缓存图片太大的话内嵌的url数据会过长 使用相同页面内的图片 使用同一个页面下的图片，我们可以通过JS获取dom的操作获取同一页面中的img元素，也可以使用 document.images 获取图片集合 跨域获取图片 在 HTMLImageElement 上使用 crossOrigin 属性，可以跨域请求图片，前提是被请求的图片服务器支持跨域访问，那么使用这个属性可以请求到图片且不污染canvas，如果不使用这个属性的话会污染canvas 获取 HTMLCanvasElement 类型的图片 即使用另外一个canvas类型来当做图片，我们可以用JS获取dom操作获取指定的canvas 1var newCanvas = document.getElementById('mycanvas'); 获取 HTMLVideoElement 类型的图片 可以使用 &lt;video&gt; 中的视频帧（即便视频是不可见的） 绘制图片当我们成功的获取到图片时，我们就可以把它绘制到canvas中了，利用 drawImage() 方法，drawImage() 方法共有三总形式 ，每一种的绘制方法都有所不同，下面我们来学习一下 普通绘制 功能 将获取到的图片绘制到canvas中 参数 image：上一步获取到的图片资源 (x, y)：是图片要绘制到canvas中的起始坐标 练习 引入一张坐标图纸，利用canvas在图纸上图表 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas');; if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); var oImg = new Image(); oImg.src = 'https://ws1.sinaimg.cn/large/006eYMu7ly1ftjy0y6iymj309q078q2p.jpg'; oImg.onload = function () &#123; ctx.beginPath(); ctx.drawImage(oImg, 50, 10); ctx.moveTo(88, 255); ctx.lineTo(140, 209); ctx.lineTo(250, 167); ctx.lineTo(330, 40); ctx.stroke(); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 缩放 功能 与 drawImage(image, x, y, width, height) 不同的是，他增加了图片的缩放功能 语法 drawImage(image, x, y, width, height) 参数 image：获取到的图片 (x, y)：图片在canvas中的起始位置 width：图片被引入canvas中的宽度 height：图片被引入canvas中的height 注意 图像可能会因为大幅度的缩放而变得起杂点或者模糊。如果您的图像里面有文字，那么最好还是不要进行缩放，因为那样处理之后很可能图像里的文字就会变得无法辨认了 练习 在一个canvas中引入另一个canvas元素，并把他的宽高都缩小为原来的一半 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; #myCanvas1 &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;Don't support canvas.&lt;/canvas&gt; &lt;canvas id="myCanvas1" width="500" height="320"&gt;Don't support canvas.&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'), canvas1 = document.getElementById('myCanvas1'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); var linearGrad = ctx.createLinearGradient(0, 0, 500, 0); ctx.beginPath(); linearGrad.addColorStop(0.2, 'rgba(255, 0, 0)'); linearGrad.addColorStop(0.5, 'rgba(0, 255, 0)'); linearGrad.addColorStop(0.8, 'rgba(0, 0, 255)'); linearGrad.addColorStop(1.0, 'transparent'); ctx.fillStyle = linearGrad; ctx.fillRect(0, 0, 500, 300); &#125; if (canvas1.getContext) &#123; var ctx1 = canvas1.getContext('2d'); ctx1.beginPath(); ctx1.drawImage(canvas, 0, 0, 250, 150); ctx1.drawImage(canvas, 250, 0, 250, 150); ctx1.drawImage(canvas, 0, 170, 250, 150); ctx1.drawImage(canvas, 250, 170, 250, 150); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 切片 功能 从源图片上裁剪一块区域下来，绘制到canvas中 语法 drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) 参数 image：获取的源图片 (sx, sy)：在源图片上裁剪的起始点坐标 sWidth, sHeight：在源图片上裁剪的图片的宽高 (dx, dy)：将裁剪下的图片放在canvas中的起始点坐标 dWidth, dHeight：将裁减下图片放在canvas中的宽高 图解参数 第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。其它8个参数最好是参照右边的图解，前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小 练习 将图片中的文字部分 “往往” 裁剪下来，以canvas画布的大小绘制canvas中 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;img src="https://ws1.sinaimg.cn/large/006eYMu7ly1ftiw9x8975j30dw08cwnv.jpg" alt=""&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'), oImg = document.getElementsByTagName('img')[0]; if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); oImg.onload = function () &#123; ctx.beginPath(); ctx.drawImage(oImg, 150, 0, 200, 100, 0, 0, 500, 300); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 左侧是canvas，右侧是源图片 处理图片前面的步骤已经帮我们把图片放到了canvas画布中，接下来我们就可以按照自己的需求去处理图片，但处理这个说法好像说的有些抽象，什么叫处理图片？是针对图片裁裁剪剪么？我们一步一步来分析 我们都知道，canvas画布排列着一行行的像素点，我们看到的不同图形就是因为像素点的着色不同导致的，既然每个像素点的着色可以不同，那么他们身上一定记录着不同的信息，那有没有一个东西记录着这些不同像素点的信息呢？答案是肯定的 ImageData对象 功能 存储着canvas对象真实的像素数据 属性值 ImageData 对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性 width 图片的宽度，单位是像素 height 图片的高度，单位是像素 data Unit8ClampedArray 类型的一维数组，包含着RGBA格式的整型数据，范围是 [0, 255] 大概了解了 ImageData 对象以后我们肯定立马会有下一个问题，我们该怎么拿到这个对象呢？ 获取像素数据 目的 获取画布指定矩形范围内的像素数据 方法 getImageData(x, y, width, height) 参数 (x, y)：要获得的像素区域在画布上的起始点坐标 width, height：要获得的像素区域的宽高 注意 使用这个方法要满足同源策略，或者服务器允许你进行跨域读取图片数据 说明 这个方法的返回值，就是我们想获得的保存着像素数据 ImageData 对象，它包含了我们获取的区域每个像素点的像素数据，我们可以通过改变这些数据，改变其像素值，像素值不一样了，他所对应的图片也就会产生相应的变化，这个过程就是处理图片的过程，也就是我们一开始抛出的问题 处理像素数据 比如现在我们想把一个黑色的矩形变成灰色的，我们可以把这个矩形的像素数据拿到，然后修改其像素数据，然后再放回到画布上，就实现了这一需求，但是还有一个问题就是，怎么把修改后的数据放回去呢？ 创建ImageData对象 目的 除了用 getImageData() 方法获取一个 imageData 对象外，我们还可以自己创造一个 imageData 对象（这一点不常用，可以选择性跳过） 方法 createImageData(width, height) createImageData(anotherData) 参数 有两种方法可以实现这一功能，第一种是创建一个特定尺寸的 imageData 对象，所有像素被预设为透明黑；第二种方法可以创建一个被 anotherData 对象指定的相同像素的 imageData 对象，这个新的对象的像素全部被预设为透明黑，所以这种方法并非是复制了图片数据 重写像素数据 目的 将图像数据重写至Canvas画布中 方法 putImageData(ImageData, x, y) 参数 ImageData：要放回画布中的像素数据对象 (x, y)：ImageData对象左上角的坐标 导出图片图片处理完成后，我们可以将图片从canvas中导出，使用以下方法 语法 HTMLCanvasElement.toDataURL(type, encoderOptions) 参数 type：可选，图片格式，默认为 image/png，可能的值还有 image/jpeg，image/webp encoderOptions：可选，在制定图片格式为 image/jpeg 或者 image/webp 的情况下，可以该值从0到1表示图片的质量，值越大质量越高，默认值是0.92，如果设置的值超过了范围，也会按默认值处理 返回值 返回一个包含被类型参数规定的图像表现格式的数据连接（url） 注意 需要格外注意的是，这个和之前的方法不同，不属于上下文格式对象，它是canvas对象的方法，我们调用的时候要是用canvas对象调用 练习 针对使用图片的四个步骤做一个完整的练习，将一张彩色图片处理成黑白图片，并导出为jpeg格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; button &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;img src=""&gt; &lt;button&gt;start&lt;/button&gt; &lt;script type="text/javascript"&gt; var oImg = new Image(); oImg.src = './xiaohei.png'; oImg.onload = function () &#123; var canvas = document.getElementById('myCanvas'), canvasWidth = canvas.width, canvasHeight = canvas.height; var btn = document.getElementsByTagName('button')[0]; btn.onclick = function () &#123; sovle(); &#125; function sovle() &#123; if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); var imageData, imageDataLen; ctx.drawImage(oImg, 0, 0, canvasWidth, canvasHeight); imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight); imageDataLen = imageData.data.length / 4; for (var i = 0; i &lt; imageDataLen; i++) &#123; var red = imageData.data[i * 4]; var green = imageData.data[i * 4 + 1]; var blue = imageData.data[i * 4 + 2]; var gray = 0.3 * red + 0.59 * green + 0.11 * blue; imageData.data[i * 4] = gray; imageData.data[i * 4 + 1] = gray; imageData.data[i * 4 + 2] = gray; &#125; ctx.putImageData(imageData, 0, 0); var url = canvas.toDataURL('image/jpeg', 0.5); document.getElementsByTagName('img')[0].src = url; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 左侧是canvas元素，右侧是导出的图片，可以看到导出的图片不是很清晰，是因为我设置的导出的品质是0.5， 提高这个值可以提高图片的品质 更多处理实例看这里 命中检测 isPointInStroke(x, y) 检测坐标点(x, y)是否在当前路径上，返回值是true/false 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #myCanvas &#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="500" height="300"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById('myCanvas'); if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); var a, b; ctx.beginPath(); ctx.rect(100, 100, 200, 100); a = ctx.isPointInStroke(100, 100); ctx.stroke(); ctx.beginPath(); ctx.rect(350, 50, 100, 200); b = ctx.isPointInStroke(100, 100); ctx.stroke(); console.log(a + ' ' + b); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，两次命中检测都是检查(100, 100)这个点是否在当前路径上，很明显第一次检测时在，第二次检测时开启了新的路径，所以不在 isPointInPath(x, y) 检测坐标点(x, y)是否在当前路径区域内 像素点 还可以通过检测当前像素点的值，如果透明（RGBA中的A为0），则该点不在路径上 非零绕数准则https://blog.csdn.net/itpinpai/article/details/50412260 解决canvas高分屏模糊的问题在分辨率比较高的屏幕，例如 iPhone6/6s/max等机器上，因为canvas绘制的是位图，所以会导致模糊，解决方法是根据屏幕分辨率修改canvas样式代码（CSS）中宽和高的与canvas的width 和 height属性（html）的比例，要让两者在等比例的情况下，css中的宽高小于canvas属性中的宽高 canvas性能优化 离屏canvas 避免浮点数坐标 使用多层画布 使用css设置大背景图 使用 moz-opaque 属性 将画布的函数调用集合到一起 避免不必要的画布状态改变 渲染画布中的不同点，而非整个新状态 尽可能避免 shadowBlur 属性 尽可能避免 text render 使用不同的方法去清理画布(clearRect()、fillRect()、调整canvas大小) 有动画使用 window.requestAnimationFrame() 而非 window.setInterval() 谨慎使用大型物理库 可以使用 JSPerf测试性能 离屏canvas 如果你发现你的在每一帧里有好多复杂的画图运算，请考虑创建一个离屏canvas，将图像在这个画布上画一次（或者每当图像改变的时候画一次），然后在每帧上画出视线以外的这个画布 对比文档碎片节点理解 避免浮点数坐标 当你画一个没有整数坐标点的对象时会发生子像素渲染（之前提到的半像素问题）,所以最好对浮点数坐标取整再渲染样式 使用多层画布 你可能会发现，你有些元素不断地改变或者移动，而其它的元素，例如外观，永远不变。这种情况的一种优化是去用多个画布元素去创建不同层次 使用css设置大背景图 如果像大多数游戏那样，你有一张静态的背景图，用一个静态的 &lt;div&gt; 元素，结合background特性，以及将它置于画布元素之后。这么做可以避免在每一帧在画布上绘制大图 使用CSS transform 属性缩放画布 CSS transform 特性由于调用GPU，因此更快捷。最好的情况是，不要将小画布放大，而是去将大画布缩小 使用 moz-opaque 属性（仅 Gecko） 如果你的游戏使用画布而且不需要透明，请在画布上设置moz-opaque属性。这能够用于内部渲染优化 1&lt;canvas id="mycanvas" moz-opaque&gt;&lt;/canvas&gt; 参考MDN canvas图像处理总汇 canvas非零绕数规则]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3响应式布局]]></title>
    <url>%2F2018%2F06%2F14%2Fd08_css3%2F</url>
    <content type="text"><![CDATA[定义 随着越来越多的用户使用移动设备来浏览网站和应用，Web设计人员和开发人员需要确保他们的作品在移动设备上同样能正常运作，并且看上去和在传统台式电脑上一样好，这种方法被称为“响应式 Web 设计”。 优劣势优势 无需为不同的设备维护不同的网站，节省了时间和成本 响应式设计为每一个页面提供了一个单独且独有的URL 社会化分享统计不会被割离开，因为移动端和PC端用的是一个URL 响应式设计无需考虑用户代理检测 劣势 兼容各种设备时所需工作量大、效率低下、代码累赘，会隐藏无用的元素，加载时间延长，其实这是一种折中性质的十设计解决方案，由于多方面元素影响而达不到最佳效果，在一定程度上改变了网站原有的布局结构，会出现用户混淆的情况。 策略 流式布局 按照浏览器视窗的百分比来设定所有容器的宽度，从而使容器在浏览器窗口大小变化时自动缩放。 媒体查询 基于显示设备的物理特性（例如：尺寸、分辨率、宽高比、颜色位深等）来调用不同的样式表。 流式图片 设置图像所占宽度至多为设备的最大宽度 技术 Media Query（媒体查询） 用于查询设备是否满足某一个特定的条件，这些特定条件包括屏幕尺寸，是否可触摸，屏幕精度，横屏竖屏信息等 使用 em 或者 rem 做尺寸单位 用于文字大小的响应和弹性布局 禁止页面缩放 &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, width=device-width, maximum-scale=1, user-scalable=no&quot; /&gt; 屏幕尺寸响应 固定布局 页面居中，两边留白，他能适应大于某个值一定范围的宽度，但是如果太宽就会有很多留白，太窄会出现滚动条，在PC页面上很常见 流动布局 屏幕尺寸在一定范围内变化时，不改变模块布局，只改变模块尺寸比例。比固定布局更具响应能力，两边不留白，但是也只能适应有限的宽度变化范围，否则模块会被挤（拉）得不成样子 自定义布局 上面几种布局方式都无法跨域大尺寸变化，所以适当时候我们需要改变模块的位置排列或者隐藏一些次要元素 栅格布局 这种布局方式使得模块之间非常容易对齐，易于模块位置的改变用于辅助自定义布局 注意 宽度不固定可以使用百分比 图片处理 图片的宽度和高度设置等比缩放，可以设置图片的width为百分比，height:auto;背景图片可以使用background-size 指定背景图片的大小 meta标签meta标签用来规定内容视区大小与设备大小的关系，下面简单介绍用法及含义，详细讲解参考文章 如果要做不同设备的响应式设计，要在程序\标签中加入\标签 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt; name name=”viewport” 代表内容可视区 content viewport代表内容可视区，其大小可以大于或者小于设备可视区的大小，在做响应式设计时，要规定他们之间的大小关系，通过content中的属性 content 含义 width 内容可视区的宽度，其值可以是关键词”device-width”或者一个具体的数字 height 内容可视区的高度，其值可以是关键词”device-width”或者一个具体的数字 initial-scale 页面首次被显示时内容可视区的缩放级别，取值为1.0时将使页面按照实际尺寸显示，无任何缩放 minimum-scale 内容可视区最小的缩放级别，表示用户可以将页面缩小的程度，取值为1.0时将禁止用户缩小到实际尺寸以下 maximum-scale 内容可视区最大的缩放级别，表示用户可以将页面放大的程度，取值为1.0时将禁止用于放大尺寸至实际尺寸以上 user-scalable 指用户是否可以对页面进行缩放，设置 “yes” 允许缩放，设置 “no” 禁止缩放 Media Query（媒体查询）简介 媒体查询是向不同设备提供不同样式的一种方式，它为每种类型的用户提供了最佳的体验 CSS2 中提供了 “media type” 媒体类型，我们可以对不同的设备指定不同的样式，但通过媒体类型我们只能简单的区分设备，功能单一，所以在CSS3中对提供了”media query”，它是对”media type”的增强，等于 “media type” + “media features”(媒体特性) 语法media=&quot;(逻辑操作符) 媒体类型 逻辑操作符 零个或多个表达式&quot; 媒体类型 媒体类型 所有设备 all 所有设备 braille 盲文 embossed 盲文打印 handheld 手持设备 print 文档打印或者打印预览模式 projection 项目演示，比如幻灯片 screen 彩色电脑屏幕 speech 演讲 tty 固定字母间距的网格的媒体，比如电传打字机 tv 电视 一般用 screen 和 all 比较多一点 逻辑操作符 你可以使用逻辑操作符，包括not、and和only等，构建复杂的媒体查询。and操作符用来把多个媒体属性组合成一条媒体查询，对成链式的特征进行请求，只有当每个属性都为真时，结果才为真。not操作符用来对一条媒体查询的结果进行取反。only操作符仅在媒体查询匹配成功的情况下被用于应用一个样式，这对于防止让选中的样式在老式浏览器中被应用到。若使用了not或only操作符，必须明确指定一个媒体类型 你也可以将多个媒体查询以逗号分隔放在一起；只要其中任何一个为真，整个媒体语句就返回真。相当于or操作符。 not 和 only 应用于整个语法，所以要写在最开头 1&lt;link rel=&quot;stylesheet&quot; media=&quot;not screen and (color)&quot; href=&quot;example.css&quot; /&gt; 1&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (color)&quot; href=&quot;example.css&quot; /&gt; 样式表达式 表达式需要用圆括号。没有使用的会引起错误 用来描述一系列媒体特性，常用的媒体特性如下 使用link标签引入 &lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (max-width: 800px)&quot; href=&quot;./index.css&quot;&gt; “screen” 代表 “media type”，”(max-width: 800px)” 代表 “media features” ，整个媒体查询意为 “类型是screen，且设备的宽度不超过800px的媒体”，整个link标签意为 “当满足媒体查询的要求时，才引入 index.css 文件” @import引入 样式文件中通过@import调用别一个样式文件 1@import url("example.css") screen and (max-width: 800px); 标签中调用 12345&lt;head&gt; &lt;style&gt; @import url("example.css") sreen and (max-width: 800px); &lt;/style&gt;&lt;/head&gt; @media引入 在\的\标签中使用 123456789&lt;head&gt; &lt;style&gt; @media not screen and (max-width: 800px) &#123; div &#123; display: none; &#125; &#125; &lt;/style&gt;&lt;/head&gt; css文件中使用 123@media all and (max-width: 800px) and (min-width: 600px) &#123; ......&#125; 实际开发中，最后一种是最常用的 demo 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;link rel="stylesheet" href="./index.css"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; index.css文件 1234567891011121314151617181920212223.demo &#123; width: 100px; height: 100px; background-color: #000;&#125;@media all and (max-width: 500px) &#123; .demo &#123; background-color: green; &#125;&#125;@media all and (min-width: 501px) and (max-width: 700px) &#123; .demo &#123; background-color: red; &#125;&#125;@media all and (min-width: 900px) &#123; .demo &#123; background-color: orange; &#125;&#125;]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3多列布局]]></title>
    <url>%2F2018%2F06%2F12%2Fd07_css3%2F</url>
    <content type="text"><![CDATA[简介 CSS多栏布局 扩展块布局模式，以便更容易地定义多列文本。如果 一行太长，人们阅读文本很麻烦; 如果眼睛从一行的终点移动到下一个行的开始需要太长时间，它们就会丢失它们所在的行。因此，为了最大限度地利用大屏幕，作者应该将宽度不等的文本列并排放置，就像报纸一样。 不幸的是，这是不可能的，使用CSS和HTML，而不是在固定位置强制列分栏，或严重限制文本中允许的标记，或使用英雄脚本。 糟糕的是如果不使用CSS和HTML在特定的位置强制换行，或者严格限制文本中允许的标记，或者夸张地使用脚本的话，这是不可能实现的。该限制通过从传统的块级布局模块中延伸出来的新的CSS属性得以解决 属性总览 列数和列宽 column-count、column-width、columns 列的间距和分列样式 column-gap、column-rule-width、column-rule-style、column-rule-color、column-rule 跨越列 column-span 填充列 column-fill 分栏符 column-break-before、column-break-after、column-break-inside 列数和列宽column-count定义 属性 column-count 设置特定数量的列数 语法 column-count: auto || number; auto 是该属性默认值，当设置为auto时，元素分栏由其他元素决定，比如 column-width；number 是我们要设置的列数，用正整数表示 demo 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #demo1 &#123; width: 500px; border: 1px solid #000; column-count: 2; &#125; #demo2 &#123; width: 500px; border: 1px solid #000; column-count: 3; margin-top: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo1"&gt; &lt;p&gt;自己填充文本&lt;/p&gt; &lt;/div&gt; &lt;div id="demo2"&gt; &lt;p&gt;自己填充文本&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; column-width定义 属性 column-width 设置期望的最小宽度。如果 column-count 没有设置，那么浏览器就会以合适的宽度尽量显示更多的列 这里来解释一下 “尽量展示更多的列”：假设父元素的宽度为 W，我们设置的列宽为 w，W 不一定能被 w整除，所以我们可能会想，W / w 向下取整就是浏览器能展示的最多的列，但实际情况是这样么？先来看一个例子 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #demo1 &#123; width: 500px; border: 1px solid #000; column-width: 250px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo1"&gt; &lt;p&gt;自己填充文本&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在这个demo中，W = 500px，w = 250px，W / w = 500 / 250 = 2，按照我们的预想，这里会显示两列布局，但实际效果是 可以看到，只显示了一列布局，这是为什么呢？我们保持W = 500px 不变，逐渐的缩小 w 的值，当缩小到242px的时候，发现呈现了两列布局 仔细观察这个效果，发现除了我们预期的两列文字外，中间还有一列空白区域 就是这个空白区域占据了一定的宽度，导致结果与我们预想的效果不同，我们来计算一下这个空白区域的宽度：W / (w * 2) = 16px，有没有感觉这个16px很眼熟，没错是浏览器默认的字体大小，所以结论是：浏览器能显示的列数除了要看列宽之外，还要考虑列之间的间距，这个间距的大小取决于字体的大小 PS：即使是准确的算好了每一列的width，Opera下最好再减1个px，当然如果你是中文的话也最好这样做，减1-2px，至于为什么，只有opera能解释清楚。 语法 column-width: auto || length; 默认值是auto，当设置为 auto时，列宽由其他属性决定，比如 column-count；length 代表我们要设置的列宽，单位可以是 px 或者 em demo 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #demo1 &#123; width: 500px; border: 1px solid #000; column-width: 156px; /* (500 - 16*2) / 3 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo1"&gt; &lt;p&gt;自己填充文本&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; columns定义 多数时候，网页设计者都会使用 column-count 和 column-width 的一个. 由于它们的值没有重叠，一般使用简写属性 columns 语法 12345columns: 2; /* column-count */ columns: 100px; /* column-width */ columns: 2 100px; /* column-count column-width */ 如果使用了第三种语法，则要注意，因为同时使用了两个属性，对于属性的复合效果要注意，即要知道最终的分栏效果是由哪个属性决定的，分为三种情况： 这里以一个具体的例子说明，不列公式了， 假设父元素的宽度为 500px，字体为默认大小16px columns: 2 100px; 意为分成两栏，每栏的宽度是 100px，经过计算（2 100 + 16 1 &lt;= 500）结果有效，则可以分栏；我们让 column-width: 100px; 属性暂时固定，当 column-count 的值取 3、4时计算结果依然是有效的（3 100 + 16 2 &lt; 500、4 100 + 16 3 &lt;= 500），结果分别显示 3、4栏；同理，我们让 column-count: 2; 固定，当column-width 的值在有效范围内逐渐变换（经过计算，有效值范围在1px — 242px），这时显示的栏数始终是2栏；所以结论是 当 column-count 与 column-width 的计算结果在有效范围内时，结果的分栏数取决于 column-count 属性 columns: 3 242px; 意为分为三栏，每栏的宽度是242px，经过计算（3 242 + 16 2 &gt; 500）结果无效，但是依然可以分栏，原因是虽然整体的计算结果无效，但是对于column-width: 242px; 属性来说，可以分为两栏（242 2 + 16 1 = 500），当我们逐渐的缩小 column-width 属性时，他会逐渐分成三栏、四栏…；所以结论是 当 column-count 与 column-width 的计算结果不在有效范围内，且这个无效的结果是因为 column-count 的值太大导致的（即仅看column-width 属性的话，至少可以分为两栏），那么依然可以分栏，且分栏的结果取决于 column-width，与 column-count 无关 columns: 3 250px; 意为分为三栏，每栏的宽度为250px，经过计算（250 3 + 16 2）结果无效，不能分栏；原因是这里整体结果无效，且根据 columns-width 属性也无法将结果至少分为两栏，所以整个属性无效，结果不能分栏 demo 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #demo1 &#123; width: 500px; border: 1px solid #000; columns: 2 100px; /* columns: 3 100px; */ /* columns: 4 100px; */ /* columns: 5 100px; */ /* columns: 3 242px; */ /* columns: 3 250px; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo1"&gt; &lt;p&gt;自己填充文本&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 列的间距和分列样式column-gap定义 列之间的间距 语法 column-gap: normal || length; 默认值为normal，W3C建议值1em。length表示任何非负整数，单位可以是px、em、vw等 demo 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #demo1 &#123; width: 500px; border: 1px solid #000; columns: 242px; column-gap: normal; /* 16px */ /* column-gap: 17px; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo1"&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; column-rule定义 用来设置列与列之间边框的宽度、样式、颜色 语法 column-rule: column-rule-width column-rule-style column-rule-color; 其中 column-rule-width、column-rule-style、column-rule-color 代表三种不同的属性，可以单独设置 column-rule-width 边框的宽度，默认值为none，类似于border-width属性 column-rule-style 边框的样式，默认值为none，可以设置的值还有 hidden || dotted || dashed || solid || double || groove || ridge || inset || outset column-rule-color 边框的颜色，类似于border-color属性，可以设置为透明色（transparent） 注意，column-rule 所设置的边框不会占用空间位置 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #demo1 &#123; width: 500px; border: 1px solid #000; columns: 242px; column-gap: normal; column-rule: 2px dashed red; /* column-rule: 30px dashed red; */ /* 并没有把盒子撑开，不占据空间位置 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo1"&gt; &lt;p&gt;自己填充文本&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 跨越列column-span定义 指定某个子元素跨越多少列 语法 column-span: none/1 || all; none 元素不跨多个列 all 元素横跨所有列。元素出现之前，出现在元素之前的正常流中的内容在所有列之间自动平衡。该元素建立一个新的块格式上下文 demo 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #demo1 &#123; width: 500px; border: 1px solid #000; columns: 242px; column-gap: normal; column-rule: 2px dashed red; &#125; h1 &#123; /* column-span: none; */ /* 不跨列 */ column-span: all; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo1"&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt;文本自己填充&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 填充列column-fill分栏符column-break-beforecolumn-break-aftercolumn-break-inside兼容性注意不是所有的浏览器都支持不带前缀的属性名。为了在大多数现代浏览器中应用这种特性，每个属性必须写三次： 一次用 -moz 前缀，一次用 -webkit前缀，一次不使用前缀 12345&#123; -moz-column-count: 2; -webkit-column-count: 2; column-count: 2;&#125; 参考MDN 浅谈CSS3多列布局]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3弹性盒子]]></title>
    <url>%2F2018%2F06%2F11%2Fd06_css3%2F</url>
    <content type="text"><![CDATA[弹性盒子简介 CSS3弹性盒子是一种用于在页面上布置元素的布局模式，使得当页面布局必须使用不同的屏幕尺寸和不同的显示设备时，元素可预测的运行。对于许多应用程序，弹性盒子模型提供了对模型的改进，因为它不使元素浮动，flex容器的边缘也不会与其内容的边缘折叠 弹性布局基本概念 在定义方面来说，弹性布局是指通过调整其内元素的宽高，从而在任何显示设备上实现对可用显示空间最佳填充的能力。弹性容器扩展其内元素来填充可用空间，或将其收缩来避免溢出。 块级布局更侧重于垂直方向、行内布局更侧重于水平方向，与此相对的，弹性盒子布局算法是方向无关的。虽然块级布局对于单独一个页面来说是行之有效的，但其仍缺乏足够的定义来支持那些必须随用户代理(user agent)不同或设备方向从水平转为垂直等各种变化而变换方向、调整大小、拉伸、收缩的应用程序组件。 弹性盒子布局主要适用于应用程序的组件及小规模的布局，而（新兴的）栅格布局则针对大规模的布局。这二者都是 CSS 工作组为在不同用户代理、不同书写模式和其他灵活性要求下的网页应用程序有更好的互操作性而做出的更广泛的努力的一部分 弹性布局是一种一维布局模型，说它是一维布局模型是因为一个flexbox一次只能处理一个维度上的元素布局，一行或者一列。作为对比的是另外一个二维布局 网格布局，可以同时处理行和列上的布局 浮动布局的问题 难以控制 如果站点上存在一些不可预知的内容，则布局将难以维护 源码依赖性 浮动布局依赖HTML源码，在做响应式布局时难以为不同的媒体查询变更布局 列等高问题（这个问题用column解决不就行了？） 如果容器中有两到三列不同的内容，并且在任意内容的条件下，都需要设置为相同的高度。浮动布局难以实现这个要求 内容居中 浮动布局中元素的居中方法繁多，相较繁琐 弹性盒子如何处理 通过将弹性元素拉伸或者缩小充满可用空间或者溢出，这种方式解决了新内容的溢出问题并且以开发者期望的情况实施布局 给与弹性盒子元素成比例的尺寸 弹性容器内的弹性元素可以从横、纵方向布局；可以解决在不同媒体查询中元素顺序问题，使得可见内容的顺序独立于HTML的渲染顺序，有利于站点的相应设计 相关词汇在学习弹性盒子强大的功能之前，我们先来了解一下该怎样描述弹性盒子，下图以一个 flex-direction: row; 的弹性容器为例进行描述 弹性容器包含弹性项目的父元素。通过设置 display: flex; 或者 display: inline-flex 来定义弹性容器 弹性项目弹性容器中的每一个子元素称为弹性项目。弹性容器中直接包含的文本元素被包覆成匿名弹性单元。 轴每个弹性框布局包含两个轴：弹性项目沿其一次排列的那一根叫做主轴；垂直于主轴的轴叫做侧轴或者交叉轴 方向弹性项目的主轴起点/主轴终点和测轴起点/侧轴终点描述了弹性项目排布的起点与终点。它们具体取决于弹性容器的主轴与侧轴中由 writing-mode 确立的方向 行根据 flex-wrap 属性，弹性项目可以排布在单个行或者多个行中 尺寸根据弹性容器的主轴与侧轴，弹性项目的宽和高中，对应主轴的称为主轴尺寸，对应侧轴的称为侧轴尺寸 定义一个弹性盒子语法如果要指定一个盒子为弹性盒子，则需要给他指定CSS样式，按以下方式设置 display 属性 display: flex; 或者 display: inline-flex; 这样将元素定义为弹性容器，其子元素称为弹性项目。值 flex 使弹性容器称为块级元素，值 inline-flex 使弹性容器单个不可分的行内元素 兼容现代浏览器能够很好的支持flexbox，并且大多数浏览器不需要前缀，2个需要注意浏览器兼容的浏览器是： Internet Explorer 10：使用 -ms- 前缀； UC浏览器：使用 -webkit- 前缀 现在IE11已经支持 display: flex; 但是在使用时会有一些bug（不太清楚是什么bug） 所以一般考虑兼容只需要加上 -webkit- 前缀即可，如果要支持非常旧的浏览器，则在css中加入： 12345678&lt;style&gt; .wrapper &#123; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; &#125;&lt;/style&gt; 不影响弹性盒子的属性由于弹性盒子采用了不同的布局算法，所以某些属性在弹性盒子上无效 多栏布局模块的 column-* 属性对弹性项目无效 float 与 clear 属性对弹性项目无效。使用 float 将使元素的 display 属性记为 block vertical-align 对弹性项目的对齐无效 弹性容器123456+ flex-direction+ flex-wrap+ flex-flow+ justify-content+ align-items+ align-content flex-direction定义 flex-direction 属性通过设置容器主轴来定义弹性元素如何在容器内排列。这个属性确定了弹性元素的排列方向 语法 flex-direction: row(默认) | row-reverse | column | column-reverse; 主轴方向 侧轴方向 书写方向 起始线 终止线 元素排列方向 row 水平反向 竖直方向 左-&gt;右 主轴左侧 主轴右侧 左-&gt;右 row 水平方向 竖直方向 右-&gt;左 主轴右侧 主轴左侧 右-&gt;左 row-reverse 水平方向 竖直方向 左-&gt;右 主轴右侧 主轴左侧 右-&gt;左 row-reverse 水平方向 竖直方向 右-&gt;左 主轴左侧 主轴右侧 左-&gt;右 column 竖直方向 水平方向 上-&gt;下 主轴上方 主轴下方 上-&gt;下 column 竖直方向 水平方向 下-&gt;上 主轴下方 主轴上放 下-&gt;上 column-reverse 竖直方向 水平方向 上-&gt;下 主轴下方 主轴上方 下-&gt;上 column-reverse 竖直方向 水平方向 下-&gt;上 主轴上方 主轴现房 上-&gt;下 表格解释 如果选择了 row 或者 row-reverse ，主轴方向将沿水平方向延伸 此时的侧轴垂直于主轴，方向沿竖直方向 如果选择 column 或者 column-reverse ，主轴方向沿竖直方向延伸 此时侧轴垂直于主轴，方向沿水平方向 以上描述只是说明了元素再什么方向上排列（水平方向或者竖直方向），但元素具体的排列方向是怎么样的呢？比如如果设置了 flex-direction: row; ，即主轴方向沿水平方向延伸，那元素是从左向右排列呢还是从右向左排列呢？这个就要取决于我们设置的书写方向了：书写方向是从左到右，则元素排列方向是从左到右；书写方向是从右到左，则元素排列方向是从右到左；flex-direction: row-reverse; 与之相反；flex-direction: column; 和 flex-direction: column-reverse; 道理相同 默认的排列方向是从左到右，从上到下 -&gt; 改变元素的排列方向：参考链接 flex-wrap定义 flex-wrap 属性控制了容器为单行还是多行 语法 flex-wrap: nowrap(默认) | wrap | wrap-reverse; no-wrap：单行显示 wrap：多行显示 wrap-reverse：多行显示，排列方向与 wrap 相反 设置了 wrap 值，如果项目太大而无法全部显示在一行中，则会换行显示；设置为 nowrap，如果项目过大，它们会缩小以适应容器，如果项目子元素无法缩小，使用 nowrap 会导致溢出，或者缩小的程度还不够 flex-flow定义 flex-direction 和 flex-wrap 属性的简写 语法 flex-flow: flex-direction || flex-wrap; 默认值是：row nowrap； justify-content定义 用于在主轴上对齐伸缩项目。这一行为会在所有可伸缩长度及所有自动边距均被解释后进行。当一行上的所有伸缩项目都不能伸缩或者可伸缩但是都已经达到其最大长度时，这一属性才会对多余的空间进行分配。当项目溢出某一行时，这一属性也会在项目的对其上施加一些控制 语法 justify-content: flex-start(默认) |flex-end | center | space-between | space-around | space-evenly; flex-start 伸缩项目向一行的起始位置靠齐，该行的第一个伸缩项目在起始线的外边距与起始线对齐，同时所有后续的伸缩项目与前一个项目对齐 flex-end 伸缩项目向一行的结束位置靠齐，该行的最后一个伸缩项目在终止线的外边距与终止线对齐，同时所有前面的伸缩项目与其后一个项目对齐 center 伸缩项目向一行的中间位置靠齐。该行的伸缩项目将相互对齐并在行中相互对齐。第一个项目距起始线的距离与最后一个项目距终止线的距离相同（如果剩余空间是负数，则保持两端溢出长度相等） space-between 伸缩项目会平均的分配在行里，如果剩余空间是负数或者该行只有一个伸缩项目，则此值等效于flex-start。在其他情况下，第一个项目在起始线的外边距与起始线对齐，最后一个项目在终止线的外边距与终止线对齐，而剩下的伸缩项目在确保两两之间的空白空间相等的情况下平均分布 space-around 伸缩项目会平均地分布在行里，两端保留一半的空间。如果剩余空间是负数，或该行只有一个伸缩项目，则该值等效于center。在其它情况下，伸缩项目在确保两两之间的空白空间相等，同时第一个元素前的空间以及最后一个元素后的空间为其他空白空间的一半下平均分布 space-evenly flex项都沿着主轴均匀分布在指定的对齐容器中。相邻flex项之间的间距，主轴起始位置到第一个flex项的间距,，主轴结束位置到最后一个flex项的间距，都完全一样 align-items定义 可以设置弹性元素在容器侧轴上的对齐方式，与 justify-content 功能相似但是方向垂直。它设置弹性盒子所有子元素的对齐方式，包括匿名弹性元素。元素可以通过单独设置 align-self (后面讲) 来覆盖该属性 对于匿名弹性元素，align-self 属性总是与 align-items 相同 对于没有文字的弹性子元素来说它的基准线是它dom结构的最下部 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .wrapper &#123; display: flex; width: 400px; height: 300px; border: 1px solid #000; align-items: baseline; &#125; .demo &#123; width: 200px; height: 100px; border: 1px solid red; box-sizing: border-box; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="demo"&gt;假装有字假装有字假装有字假装有字假装有字假装有字假装有字&lt;/div&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;div class="demo"&gt;假装有字假装有字假装有字&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 语法 align-items: flex-start | flex-end | center | baseline | stretch(默认); flex-start 所有弹性项目在侧轴起始线的外边距与起始线对齐 flex-end 所有弹性项目在侧轴终止线的外边距与终止线对齐 center 所有伸缩项目在侧轴方向上的外边距距离起始线、终止线的距离相等（如果伸缩项目尺寸大于伸缩行尺寸，则伸缩项目两个方向的溢出量相同） baseline 如果伸缩项目的行内轴与侧轴为同一条，则该值和flex-start等效。其它情况下，该值将参与基线对齐。所有参与该对齐方式的伸缩项目将按下列方式排列：首先将这些伸缩项目的基线进行对齐，随后其中基线至侧轴起点边的外边距距离最长的那个项目将紧靠住该行在侧轴起点的边 这里的基线指的是弹性项目内的第一行文本 stretch 如果侧轴长度属性值是auto，则此值会使项目外边距盒的尺寸在遵照 min/max-width/height 属性的限制下尽可能接近所在行尺寸 align-content定义 当伸缩容器的侧轴还有多余空间时，align-content属性可以用来调准伸缩行在伸缩容器里的对齐方式，这与调准伸缩项目在主轴上对齐方式的justify-content属性类似 注意：此属性在只有一行的伸缩容器上没有效果 语法 align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch(默认); flex-start 各行向伸缩容器的起点位置堆叠。伸缩容器中第一行在侧轴起点的边会紧靠住伸缩容器在侧轴起点的边，之后的每一行都紧靠住前面一行 flex-end 各行向伸缩容器的结束位置堆叠。伸缩容器中最后一行在侧轴终点的边会紧靠住该伸缩容器在侧轴终点的边，之前的每一行都紧靠住后面一行。 center 各行向伸缩容器的中间位置堆叠。各行两两紧靠住同时在伸缩容器中居中对齐，保持伸缩容器在侧轴起点边的内容边和第一行之间的距离与该容器在侧轴终点边的内容边与第最后一行之间的距离相等。（如果剩下的空间是负数，则行的堆叠会向两个方向溢出的相等距离。） space-between 各行在伸缩容器中平均分布。如果剩余的空间是负数或伸缩容器中只有一行，该值等效于flex-start。在其它情况下，第一行在侧轴起点的边会紧靠住伸缩容器在侧轴起点边的内容边，最后一行在侧轴终点的边会紧靠住伸缩容器在侧轴终点的内容边，剩余的行在保持两两之间的空间相等的状况下排列 space-around 各行在伸缩容器中平均分布，在两边各有一半的空间。如果剩余的空间是负数或伸缩容器中只有一行，该值等效于center。在其它情况下，各行会在保持两两之间的空间相等，同时第一行前面及最后一行后面的空间是其他空间的一半的状况下排列 stretch 各行将会伸展以占用剩余的空间。如果剩余的空间是负数，该值等效于flex-start。在其它情况下，剩余空间被所有行平分，扩大各行的侧轴尺寸 注意 只有多行的伸缩容器才会在侧轴上有多余的空间以供对齐，因为仅包含一行的伸缩容器中，唯一的一行会自动伸展填充全部的空间 align-items 和 align-content 的比较 align-content强调多行元素在侧轴方向上整体的布局，align-items强调侧轴上单行元素的布局方式是怎么样的 只有一行元素，align-content属性不起作用 对比下面两张图，图一代表align-items 属性值的效果，图二代表align-content属性值的效果，彩色部分代表弹性项目，可以看出图一每一个部分都在展示单独一行的对齐效果；而图二的每一部分在展示多行整体的对齐效果 弹性项目order order 属性通过将这些元素分配到序数分组来控制它们出现的顺序 排序规则：有最小值的项目排在第一个，若有多个相同的值，这些项目按照文件顺序排序 语法 order: number; 默认值：0 number值是整数（正、负、0） demo 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .wrapper &#123; display: flex; width: 300px; height: 100px; border: 1px solid #000; &#125; .demo &#123; width: 75px; height: 50px; border: 1px solid red; box-sizing: border-box; &#125; .wrapper .demo:nth-child(1) &#123; order: 2; &#125; .wrapper .demo:nth-child(2) &#123; order: -1; &#125; .wrapper .demo:nth-child(3) &#123; order: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="demo"&gt;1&lt;/div&gt; &lt;div class="demo"&gt;2&lt;/div&gt; &lt;div class="demo"&gt;3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; flex flex 是 flex-flow，flex-shrink，flex-basis 三个属性的简写 第二个和第三个参数是可选值，默认值是 flex: 0 1 auto flex: none 与 flex: 0 0 auto; 等效 注意 flex-grow 与 flex-basis 的初始值与它们在 flex 简写被省略时的默认值不同。这里的设计是为了让 flex 简写在最常见的情景下比较好用 在具体学习 flex-flow，flex-shrink，flex-basis 三个属性之前，先来了解一些概念 min-content / max-content https://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/ 正负自由空间 Flex 布局中有flex容器和flex子元素， flex子元素包含在flex容器中， 那么当flex子元素在主轴上的尺寸（大小）之和小于flex容器 的尺寸时， flex容器中就会有多余的空间没有被填充， 这些空间就被叫做 positive free space。当flex子元素在主轴上的尺寸之和大于flex容器的尺寸时， flex容器的空间就不够用，此时flex子元素的尺寸之和减去flex容器的尺寸（flex 子元素溢出的尺寸）就是negative free space, 这个negative free space加上flex容器的尺寸刚好可以容纳flex子元素 flex-grow当flex容器中存在 positive free space 时，如果想要消除这部分空间，则需要把这些空间转移到flex项目身上，而flex-grow 属性是用来确定每个flex项目所分配空间的比例 语法 flex-grow: number; number是非负整数，默认值是0 计算方法 某一flex项目负责消除positive free space空间的比例的计算方法： 该项目的flex-grow 属性值 除以 所有参与分配的flex项目的 flex-grow 值的总和 实例解释 图中的 positive free space 就是我们要分配给三个flex项目的空间，看以下几种情况： 三个flex项目都不设置flex-grow 属性 都不设置，按照默认值来，默认值是0，所以flex1，flex2，flex3分配到的负责消除的空间是 100px * (0 / (0 + 0 + 0)) 结果如下图： 因为他们分配到的空间都是0 ，所以默认情况下是不对剩余空间进行分配的 三个flex项目 flex-grow: 1; 三个flex的值相同，所以计算方法相同，每个flex项目负责分配的空间是 100px * (1 / (1 + 1 + 1)) 结果如下图 这种情况中，三个flex项目positive free space 均分了，注意如果这里三个 flex-grow 的值均为2或者均为100，结果和1是一样的，因为这个值是用来计算比例的，看的是他们之间的比例关系 三个flex项目分别是 flex-grow: 1; ，flex-grow: 2;，flex-grow: 3 flex1项目分配空间：100px * (1 / (1 + 2 + 3)) flex2项目分配空间：100px * (2 / (1 + 2 + 3)) flex3项目分配空间：100px * (3 / (1 + 2 + 3)) 结果如图： 在所有flex项目中，只要有一个flex项目的flex-grow 属性不为0，则positive free space就会被分配掉（没有剩余空间） flex-shrink当flex容器中存在 negative free space 时，如果想要消除这部分空间，则需要从每个flex项目身上减掉一些他们原来的空间，而flex-shrink 属性是用来确定每个flex项目所分配空间的比例 语法 flex-shrink: number; number是非负整数，默认值是1 默认值是1，也就是说，在默认情况下flex 项目不会溢出容器，因为按照默认情况，一旦溢出，negative free space这部分就被等比例的拆分成n份，n个flex项目各减掉一份的大小 实例解释 与 flex-shrink 的用法功能相同，对比理解即可 flex-basis flex-basis 属性在任何空间分配发生之前初始化flex子元素的尺寸 语法 flex-basis: auto(默认) | content | length; 此属性的初始值为 auto. 如果 flex-basis 设置为 auto , 浏览器会先检查flex子元素的主尺寸是否设置了绝对值再计算出flex子元素的初始值. 比如说你已经给你的felx子元素设置了200px 的宽，则200px 就是这个flex子元素的 flex-basis. 如果你的flex子元素 为自动调整大小， 则auto 会解析为其内容的大小. 此时你所熟知的min-content和max-content大小会变得有用, flexbox 会将flex子元素的 max-content 大小作为 flex-basis. 除了关键字 auto 以外, 你还可以使用关键字 content 作为 flex-basis的值. 这会导致 flex-basis 根据内容大小设置即使flex子元素 设置了宽度. 这是一个新关键字而且获得浏览器支持的比较少, 但是你还是可以通过设置flex-basis: auto并确保你的flex子元素没有设置宽度来达到相同的效果 , 以便它能自动调整大小. length代表整非负长度值，单位可以是px、em等 空间分配时， 如果你想flexbox 完全忽略flex子元素的尺寸就设置flex-basis 为 0. 这基本上告诉flexbox所有空间都可以抢占，并按比例分享. demo 继续使用前面flex-grow中的例子，对于第三种情况（ flex-grow: 1; ，flex-grow: 2;，flex-grow: 3），我们让每个盒子所承担的 positive free space 的比例是1:2:3，但是最终分配完成后他们的比例不是1:2:3（显然a+m: a+2m:a+3m 不是1:2:3），如果我们想让分配结果是1:2:3的关系，可以将flex-basis 属性设为0，这样分配的比例即为最终每个flex元素所占的比例 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .wrapper &#123; display: flex; width: 400px; height: 100px; border: 1px solid #000; &#125; .demo &#123; width: 200px; height: 50px; border: 1px solid red; box-sizing: border-box; flex-basis: 0px; &#125; .wrapper .demo:nth-child(1) &#123; flex-grow: 1;&#125; .wrapper .demo:nth-child(2) &#123; flex-grow: 2;&#125; .wrapper .demo:nth-child(3) &#123; flex-grow: 3;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="demo"&gt;1&lt;/div&gt; &lt;div class="demo"&gt;2&lt;/div&gt; &lt;div class="demo"&gt;3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实际 coding 中，建议使用 flex 简写 flex-grow，flex-shrink，flex-basis三个属性，而不是单独设置这些属性 algin-self定义 align-self 用来在单独的伸缩项目上覆写默认的对齐方式 语法 align-self: auto(默认) | flex-start | flex-end | center | baseline | stretch; 如果align-self的值为auto，则其计算值为元素的父元素的align-items值，如果该元素没有父元素，则计算值为stretch flex典型布局三栏布局 左右两栏固定，中间自适应 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html,body &#123; display: flex; width: 100%; height: 100%; margin: 0px; padding: 0px; &#125; .left, .right &#123; width: 200px; height: 100%; background-color: pink; &#125; .center &#123; min-width: 200px; height: 100%; background-color: orange; flex-grow: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 参考链接https://www.w3.org/TR/css-flexbox-1/#justify-content-property 使用CSS弹性盒子 flex布局的基本概念 使用弹性盒子进行高级布局 沿主轴控制Flex子元素的比例 https://www.w3cplus.com/css3/a-guide-to-flexbox-new.html]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 3D效果]]></title>
    <url>%2F2018%2F06%2F10%2Fd05_css3%2F</url>
    <content type="text"><![CDATA[3D变换利用transform: rotate(); 的一些列值可以实现3D变换的效果 rotate()以x轴，y轴，z轴或者某个合成的矢量轴为旋转轴进行指定角度的旋转，默认情况下是以z轴为旋转轴 rotate(deg) 这是默认情况，以z轴为旋转轴进行旋转。deg是旋转的角度，当角度值为正时，正视图顺时针旋转 rotateX(deg) 以x轴为旋转轴进行旋转。deg是旋转的角度，当角度值为正时，右视图顺时针旋转 rotateY(deg) 以y轴为旋转轴进行旋转。deg是旋转的角度，当角度值为正时，仰视图顺时针旋转 rotateZ(deg) 以z轴为旋转轴进行旋转。deg是旋转的角度，当角度值为正时，正视图顺时针旋转 rotate3d(x, y, z, deg) 以x，y，z三个轴方向上的矢量合成的矢量为旋转轴进行旋转。x，y，z均为number类型，可以是0到1之间的数值，表示x、y、z方向上的矢量；deg代表旋转的角度 注意 当元素进行旋转的同时，非旋转轴也会跟着元素一同进行旋转。比如 rotateX(90deg);，旋转结束后，旋转轴x方向不变水平向右，非旋转轴y轴和z轴分别垂直屏幕向外和竖直向上 transform: rotateX(45deg) rotateY(45deg) rotateZ(45deg); 和 transform: rotate3d(1, 1, 1, 45deg); 的效果是不一样的：前者是有先后顺序，先沿x轴旋转，再沿y轴旋转，再沿z轴旋转；后者直接沿合成的轴进行旋转 前者 后者 保留3D效果前面介绍了利用transform 可以实现一系列的3D变换效果，但是实际看来，好像并没有我们想象中的3D效果，都是一些平面效果，没错是这样的，因为虽然我们实现了3D变换的效果，但是在默认情况下，这个效果是展示在二维平面中的，如果想要看到3D的效果，就要设置保留3D效果，让元素再三维空间内展示，这就要用到下面的属性 transform-style: preserve-3d 定义 为进行3D变换的元素保留3D效果，让其在三维空间内展示 语法 transform-style: flat(默认) | preserve-3d; flat 是默认值，元素只能在二维平面内展示，看不到3D效果 注意 transform-style: preserve-3d; 要设置在实现了3D效果元素的父元素（即舞台元素）上使用 要与 transform 属性一同使用 设置了 transform-style: preserve-3d 的元素就不能为了防止子元素溢出而设置 overflow: hidden; 属性，该做法会导致 preserve-3d 失效 demo 12345678910&lt;style&gt; .wrapper &#123; ......; transform: preserve-3d; /* 这个属性在父元素上设置 */ &#125; .wrapper .demo &#123; .......; transform: rotateX(angle); &#125;&lt;/style&gt; 理解景深首先来看一组设置了 transform 属性的元素，在二维平面和在三维空间的效果 两组中三个子元素的3D变换操作分别是 transform: rotateX(45deg);，transform: rotateY(45deg);，transform: rotateZ(45deg);，但是很明显第一组看不出来3D效果，第二组才能看出来3D效果，那你可能想是不是第一组没有使用 transform-style 属性来保留3D效果，但可以明确说明的是，两组都设置了 transform-stye 属性来保留3D效果，那为什么第一组我们看不到3D效果呢，这就要介绍下一个属性景深 定义 景深（DOF），是指在摄影机镜头或其他成像器前沿能够取得清晰图像的成像所测定的被摄物体前后距离范围。 而光圈、镜头、及拍摄物的距离是影响景深的重要因素。 在聚焦完成后，焦点前后的范围内所呈现的清晰图像，这一前一后的距离范围，便叫做景深。 __百度百科 可以简单的把景深理解为人距离显示器的距离，此值的大小会决定你看物体的程度，比如距离100米和1米去看一个边长为1米的立方体的效果是不一样的（自行脑补） 语法 transform: perspective(length); 默认值是none，length代表景深的大小，单位是像素 demo 12345678910&lt;style&gt; .wrapper &#123; ......; transform: preserve-3d; &#125; .wrapper .demo &#123; .......; transform: perspective(length) rotateX(angle); &#125;&lt;/style&gt; 视点在理解了景深的后，介绍其语法之前我们先来了解另一个概念 “视点” 定义 简单的理解，视点就是我们观察物体的角度，默认位置在物体(x, y) (50%, 50%)的位置上，y的距离（即远近）可以自己调整 语法 perspective-origin: locX locY; locX, locY 表示视点在x轴，y轴上的距离，默认是50%，50% 这里的值可以是百分比、像素、关键词（center、top、left、bottom） demo 不同视点看到的3D效果是不一样的 以元素沿x轴旋转为例，默认视点下，我们让物体旋转45度，效果如下 改变旋转的角度为90度，效果如下 我们发现，元素消失了，其实不是元素消失了，而是在当前视点下，我们看不到它了，想想一下，你的视线与在x轴与z轴构成的平面上且与x轴垂直，那么当元素沿x轴旋转90度以后，是不是就看不到了，那么如果我们想要看到它，可以调整视点，比如我们把视点调整到（center，top）的位置，效果如下 景深的两种写法前面我们提到过一种设置景深的方法，是利用 transform: perspective(length); 来设置，除了这种方法外，还可以通过利用 perspective: length; 方法来设置景深，不同的是 transform: perspective(length); 设置在变换的子元素上，而 perspective: length; 设置在舞台元素上（形变元素的父元素），这两种设置方法所造成的不同，我们来讲解一下 现有一舞台元素，它有三个子元素均沿x轴旋转80度，默认视点 在舞台元素上设置景深 在子元素上设置景深 可以看到，元素发生的3D变换是相同的，但在舞台元素上设置景深和在子元素上设置景深的效果明显不一样，前者每一个子元素看起来好像都不一样，而后者所有子元素看起来都相同，其实这是视点不同而造成的问题 如果在舞台元素上设置景深，那么视点就只有一个，即在舞台元素（50%，50%）处，这个视点看第一个元素还正常，但是看下面的子元素就会是俯视的效果，所以看到的形状不同；而如果在子元素中设置景深，那么每一个元素都会拥有一个单独的视点，所以每一个看起来都是正视的效果 backface-visibility定义 在元素运动的过程中是否展示背面 语法 backface-visibility: visible | hidden; 性能优化3D动画很消耗页面的性能，所以使用3D动画时要进行一些性能优化 使用3D变形开启GPU加速 GPU加速属于系统硬件能力，使用3D变化能开启GPU加速，提高性能 12345678.demo &#123; ......; /* bad */ transform: rotateX(10deg); /* good */ transform: rotate3d(10deg, 0, 0);&#125; 但是一定要注意transform: rotateX(45deg) rotateY(45deg) rotateZ(45deg); 和 transform: rotate3d(1, 1, 1, 45deg); 的效果是不一样的，这一点之前就提到过 尽可能的少用box-shadow，text-shadow，gradient 这些很消耗行呢的属性，他们被称为性能杀手，所以尽量减少使用 尽可能让动画元素脱离文档流，以减少重排 注意点 当元素进行旋转的同时，非旋转轴也会跟着元素一同进行旋转。比如 rotateX(90deg);，旋转结束后，旋转轴x方向不变水平向右，非旋转轴y轴和z轴分别垂直屏幕向外和竖直向上 比如，现在有两个要进行3D变换的元素，两元素均沿x轴旋转，一个旋转90度，另一个旋转-90度，然后两元素均沿z轴平移100px，为了旋转90度以后能看到元素，我们把视点调到（center， top）的位置，想一下结果是什么效果 结果两个元素相差在竖直方向上相差了200px，此时的竖直方向是z轴的方向，因为元素进行西旋转的同时，坐标轴也跟着旋转了 如果动画有闪烁，通常发生在动画开始的时候，可以尝试以下解决方法 12345678-webkit-backface-visibility: hidden;-moz-backface-visibility: hidden;-ms-backface-visibility: hidden;backface-visibility: hidden;-webkit-perspective: 1000;-moz-perspective: 1000;-ms-perspective: 1000;perspective: 1000; demo3D透视旋转照片墙 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; list-style: none; &#125; @keyframes rotate &#123; from &#123; transform: rotate3d(0, 1, 0, 0); &#125; to &#123; transform: rotate3d(0, 1, 0, 360deg); &#125; &#125; .wrapper &#123; position: absolute; top: 50%; left: 50%; width: 800px; height: 500px; /* border: 1px solid #000; */ transform: translate(-50%, -50%); transform-style: preserve-3d; perspective: 1500px; perspective-origin: center top; &#125; .wrapper ul &#123; position: absolute; top: 50%; left: 50%; transform: translate3d(-50%, -50%, 0); transform-style: preserve-3d; animation: rotate 3s linear infinite; &#125; .wrapper ul li &#123; position: absolute; width: 350px; height: 150px; opacity: 0.5; font-size: 30px; text-align: center; line-height: 150px; &#125; .wrapper ul li:nth-child(1) &#123; background-color: deeppink; transform: translate(-50%, -50%) rotate3d(0, 1, 0, 0) translate3d(0, 0, 323px); &#125; .wrapper ul li:nth-child(2) &#123; background-color: deepskyblue; transform: translate(-50%, -50%) rotate3d(0, 1, 0, 60deg) translate3d(0, 0, 323px); &#125; .wrapper ul li:nth-child(3) &#123; background-color: greenyellow; transform: translate(-50%, -50%) rotate3d(0, 1, 0, 120deg) translate3d(0, 0, 323px); &#125; .wrapper ul li:nth-child(4) &#123; background-color: purple; transform: translate(-50%, -50%) rotate3d(0, 1, 0, 180deg) translate3d(0, 0, 323px); &#125; .wrapper ul li:nth-child(5) &#123; background-color: orange; transform: translate(-50%, -50%) rotate3d(0, 1, 0, 240deg) translate3d(0, 0, 323px); &#125; .wrapper ul li:nth-child(6) &#123; background-color: red; transform: translate(-50%, -50%) rotate3d(0, 1, 0, 300deg) translate3d(0, 0, 323px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 1.只要子元素要实现3d效果，就要给其直接父级设置 transform-style: preserve-3d; 属性 2.子元素要实现3d效果，不是要给每一个子元素的直接父级都设置 perspective，给最外层的那层父级设置即可--&gt; 旋转立方体 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; list-style: none; &#125; @keyframes rotate &#123; form &#123; transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg); &#125; to &#123; transform: rotateX(360deg) rotateY(360deg) rotateZ(360deg); &#125; &#125; .wrapper &#123; position: relative; width: 300px; height: 300px; border: 1px solid #000; margin: 100px; transform-style: preserve-3d; perspective: 800px; &#125; .wrapper ul &#123; position: absolute; top: 50%; left: 50%; width: 200px; height: 200px; margin-left: -100px; margin-top: -100px; transform-style: preserve-3d; animation: rotate 5s linear infinite; &#125; .wrapper ul li &#123; position: absolute; top: 0%; left: 0%; width: 200px; height: 200px; font-size: 30px; text-align: center; line-height: 200px; opacity: 0.5; transform-style: preserve-3d; &#125; .wrapper ul li:nth-child(1) &#123; background-color: deeppink; transform: rotate3d(0, 0, 0, 0deg) translate3d(0, 0, 100px); &#125; .wrapper ul li:nth-child(2) &#123; background-color: deepskyblue; transform: rotate3d(0, 1, 0, 90deg) translate3d(0, 0, 100px); &#125; .wrapper ul li:nth-child(3) &#123; background-color: greenyellow; transform: rotate3d(0, 1, 0, 180deg) translate3d(0, 0, 100px); &#125; .wrapper ul li:nth-child(4) &#123; background-color: purple; transform: rotate3d(0, 1, 0, 270deg) translate3d(0, 0, 100px); &#125; .wrapper ul li:nth-child(5) &#123; background-color: orange; transform: rotate3d(1, 0, 0, 90deg) translate3d(0, 0, 100px); &#125; .wrapper ul li:nth-child(6) &#123; background-color: red; transform: rotate3d(1, 0, 0, -90deg) translate3d(0, 0, 100px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3动效]]></title>
    <url>%2F2018%2F06%2F09%2Fd04_css3%2F</url>
    <content type="text"><![CDATA[transform可以实现元素的形状、角度、位置等的变换 rotate()以x轴，y轴，z轴或者某个合成的矢量轴为旋转轴进行指定角度的旋转，默认情况下是以z轴为旋转轴 rotate(deg) 这是默认情况，以z轴为旋转轴进行旋转。deg是旋转的角度，当角度值为正时，正视图顺时针旋转 rotateX(deg) 以x轴为旋转轴进行旋转。deg是旋转的角度，当角度值为正时，右视图顺时针旋转 rotateY(deg) 以y轴为旋转轴进行旋转。deg是旋转的角度，当角度值为正时，仰视图顺时针旋转 rotateZ(deg) 以z轴为旋转轴进行旋转。deg是旋转的角度，当角度值为正时，正视图顺时针旋转 rotate3d(x, y, z, deg) 以x，y，z三个轴方向上的矢量合成的矢量为旋转轴进行旋转。x，y，z均为number类型，可以是0到1之间的数值，表示x、y、z方向上的矢量；deg代表旋转的角度 这里数值的大小代表什么呢？不同的数值会导致什么不同？ 参考：https://blog.csdn.net/u010552788/article/details/51505152 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #demo &#123; width: 100px; height: 100px; margin: 100px; background-color: red; transform: rotate3d(1, 1, 0, 45deg); &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="demo"&gt;a&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 注意 当元素进行旋转的同时，非旋转轴也会跟着元素一同进行旋转。比如 rotateX(90deg);，旋转结束后，旋转轴x方向不变水平向右，非旋转轴y轴和z轴分别垂直屏幕向外和竖直向上 transform: rotateX(45deg) rotateY(45deg) rotateZ(45deg); 和 transform: rotate3d(1, 1, 1, 45deg); 的效果是不一样的：前者是有先后顺序，先沿x轴旋转，再沿y轴旋转，再沿z轴旋转；后者直接沿合成的轴进行旋转 前者 后者 scale()以x轴，y轴，z轴为轴进行指定比例的缩放 scale(x, y) x，y分别是在各自方向上，以该方向上元素尺寸大小为基准，放大或者缩小的倍数；如果第二值没有给出，则第二个值取第一个值 0 (0, 1) 1 >1 绝对值 尺寸变成0 缩小 尺寸不变 放大 >0 \&lt;0 值 直接按照比例缩放 先以轴为镜面做镜像对称，再按照比例缩放 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #wrapper &#123; width: 100px; height: 100px; background-color: #ccc; margin: 100px; &#125; #demo &#123; width: 100px; height: 100px; background-color: rgba(255, 0, 0, 0.5); font-size: 30px; /* transform: scale(0); */ /* transform: scale(1, 1); */ /* transform: scale(2, 1); */ /* transform: scale(1, 0.5); */ /* transform: scale(1, -2); */ /* transform: scale(-0.5, 1); */ /* transform: scale(-2, -2); */ &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="wrapper"&gt; &lt;div id="demo"&gt;a&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 依次打开注释观察效果，#wrapper是模拟元素原始效果，与变化之后的效果作比较 scaleX(m)、scaleY(m)、scaleZ(m) 分别以x、y、z轴为轴，进行缩放，括号中的值m表示倍数 scale3d(mx, my, mz) 在各自的方向上以各自的轴为轴，进行x、y、z倍数的缩放，等效于transform: scaleX(m) scaleY(m) scaleZ(m); skew()对元素进行倾斜扭曲 skew() 接受两个参数x，y，表示在y方向上以及x方向上倾斜的角度，角度为正向右倾斜，为负向左倾斜，为0不倾斜；如果不提供第二个参数，默认是0 skewX() 元素在x方向上的大小不变，y方向上进行倾斜 skewY() 元素在y方向上的大小不变，x方向上进行倾斜 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #wrapper &#123; width: 100px; height: 100px; background-color: #ccc; margin: 100px; &#125; #demo &#123; width: 100px; height: 100px; background-color: rgba(255, 0, 0, 0.5); font-size: 30px; transform: skew(20deg, 20deg); &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="wrapper"&gt; &lt;div id="demo"&gt;a&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; &lt;/html&gt; translate()平移产生位置变化，相对于自身的位置 translate(x, y) 接受两个参数x、y，分别代表沿x轴平移的x的距离、沿y轴移动y的距离，单位可以是px或者%（注意，如果是%，是相对于自身的大小）；如果不提供第二个参数，则默认为0 translateX(s)、translateY(s)、translateZ(s) 沿x轴、y轴、z轴平移指定的距离 translate3d(sx, sy, sz) 沿x轴、y轴、z轴平移指定的距离，等效于transform: translateX(s) translateY(s) translateZ(s); 利用这个属性的功能，可以实现元素的居中 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #wrapper &#123; position: relative; width: 200px; height: 200px; background-color: #ccc; &#125; #demo &#123; position: absolute; top: 50%; left: 50%; width: 40%; height: 40%; background-color: red; transform: translate(-50%, -50%); &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="wrapper"&gt; &lt;div id="demo"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 这里因为不知道#demo具体的宽高，所以不能用margin来调整位置，而translate是相对于元素自身的大小，利用%可以实现调整 transform-origin定义 任何元素都有一个中心点，默认情况下，其中心店居于x轴和y轴的50%处，可以通过transform-origin属性改变其原点；transform-origin有两个属性值，分别表示原点在x轴方向上的位置与原点在y轴方向的位置，这些属性值可以是以下几种形式： 关键字 百分比% 这个百分比的值是相对于元素自身的大小 像素值px 可以通过像素将元素的中心店设置在任意的位置 语法 现在主流的浏览器不仅支持 transition-origin 的2D属性，还支持他的3D属性，用来改变中心点在Z轴上的位置 transform-origin: x-axis y-axis z-axis; 值 取值 x-axis 关键字，length，% y-axis 关键字，length，% z-axis length 练习：画一个简易的钟表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; .clock &#123; width: 200px; height: 200px; border: 1px solid #000; border-radius: 50%; margin: 100px auto; &#125; .clock ul &#123; position: relative; width: 100%; height: 100%; font-size: 0px; &#125; .clock ul li &#123; position: absolute; top: 0px; left: 50%; width: 2px; height: 15px; background-color: #000; transform: translateX(-50%); transform-origin: 50% 100px; &#125; .clock ul li:nth-child(2) &#123; transform: rotateZ(90deg); &#125; .clock ul li:nth-child(3) &#123; transform: rotateZ(180deg); &#125; .clock ul li:nth-child(4) &#123; transform: rotateZ(270deg); &#125; .clock ul li span &#123; position: absolute; top: 14px; left: -9px; width: 20px; height: 20px; font-size: 16px; text-align: center; line-height: 20px; &#125; .clock ul li:nth-child(2) span &#123; transform: rotateZ(-90deg); &#125; .clock ul li:nth-child(3) span &#123; transform: rotateZ(-180deg); &#125; .clock ul li:nth-child(4) span &#123; transform: rotateZ(-270deg); &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class="clock"&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;12&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;3&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;6&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;9&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 当刻度旋转到指定位置时，数字也会跟着旋转，这时我们看到的效果是这样的 所以我们要把数字自身旋转到正面的位置，在数字外面包裹一层span，对span进行旋转 transition过渡动画，是CSS3的一个复合属性，只对block级元素生效，主要包括以下几个子属性 触发条件 单纯的代码不会触发任何过渡操作，需要通过用户的行为（如点击，悬浮等）触发，可以触发的方式有：:hover、:checked、:focus、媒体查询、JavaScript transition是实现元素从一种状态变到另一种状态时过渡动画的效果，所以很明显，要想让transition生效，就要产生元素状态的变化，比如说一个方块初始状态下宽高100px，当鼠标hover时，宽高变成了200px，这个过程就是方块状态改变的过程，正常情况下它的宽高瞬间就变成了200px，我们不想让这个过程变的太快，想让它慢慢的过渡到最终的状态，这就要使用transition来实现过渡效果 transition-property过渡或者模拟的css属性 语法：transition-property: all|none|property; 值 描述 none 没有属性会获得过渡效果。 all 所有属性都将获得过渡效果。 property 定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔。 不是所有的属性都可以参与过渡动画，需要属性具有中间状态，所有可以参与过渡属性动画的属性：点击这里 transition-duration值过渡所需要的时间，单位可以是s或者ms，如果时间为0，则过渡效果不能实现 transition-timing-function指过渡函数，规定过渡效果的速率曲线 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease（默认值） 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。 ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。 ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 可以用最后一个贝塞尔函数的不同取值来代替上述的的所有速率曲线 transition-delay指开始出现的延迟时间 demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; .demo1, .demo2, .demo3 &#123; display: inline-block; &#125; .hover &#123; width: 60px; height: 30px; background-color: #ccc; text-align: center; line-height: 30px; cursor: pointer; &#125; .item &#123; position: absolute; left: 0px; width: 100px; height: 100px; background-color: #f40; text-align: center; line-height: 100px; &#125; .demo1 .item1 &#123; top: 100px; transition: all 1500ms linear; &#125; .demo2 .item2 &#123; top: 210px; transition: left 1000ms, top 1000ms; &#125; .demo3 .item3 &#123; top: 320px; opacity: 1; transition: top 1000ms ease-in, background-color 1000ms linear, left 1500ms ease-out 1000ms, opacity 1500ms linear 1000ms; &#125; .demo1 .hover1:hover + .item1 &#123; width: 300px; height: 200px; &#125; .demo2 .hover2:hover + .item2 &#123; left: 300px; top: 0px; &#125; .demo3 .hover3:hover + .item3 &#123; left: 200px; top: 400px; background-color: green; opacity: 0.1; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class="demo1"&gt; &lt;div class="hover hover1"&gt;hover1&lt;/div&gt; &lt;div class="item item1"&gt;item1&lt;/div&gt; &lt;/div&gt; &lt;div class="demo2"&gt; &lt;div class="hover hover2"&gt;hover2&lt;/div&gt; &lt;div class="item item2"&gt;item2&lt;/div&gt; &lt;/div&gt; &lt;div class="demo3"&gt; &lt;div class="hover hover3"&gt;hover3&lt;/div&gt; &lt;div class="item item3"&gt;item3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 以上demo把transition的属性合起来写了，也可以分开来写 局限性 transition过渡动画不能再网页加载时自动触发，需要事件触发 transition过渡动画是一次性的，不能重复播放，除非一再触发 transition过渡动画只能定义元素开始和结尾的两种状态，不能定义中间过程的状态 使用位置一个元素从初始状态过渡到最终状态要使用transition属性，那这个transition是设置在初始状态中还是最终状态中呢？这个要根据具体情况而定，推荐设置在最终状态中，这样在状态较多时不容易混乱 比如：还是以方块的宽高变换为例，现有一宽高100px的方块和三个按钮，点击0.5s 按钮，宽度0.5s变成200px；点击1.0s 按钮，高度1s变成300px；点击origin 按钮，2s回到初始状态 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .demo &#123; position: absolute; top: 100px; left: 200px; width: 100px; height: 100px; background-color: orange; transition: all 2s linear; &#125; .half-second &#123; width: 200px; transition: width 0.5s linear; &#125; .one-second &#123; width: 300px; transition: width 1s linear; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;button class="half"&gt;0.5s&lt;/button&gt; &lt;button class="one"&gt;1.0s&lt;/button&gt; &lt;button class="origin"&gt;origin&lt;/button&gt; &lt;script&gt; $('.half').on('click', function () &#123; $('.demo').addClass('half-second'); &#125;); $('.one').on('click', function () &#123; $('.demo').addClass('one-second'); &#125;); $('.origin').on('click', function () &#123; $('.demo').prop('class', 'demo'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结合代码来讲，.demo 算是方块的初始状态，最终状态有两个 .half-second 和 .one-second，从初始状态到这两个状态的过渡动画是不同的（时间不同），如果把 transition 设置在 .demo 中就无法实现两个状态各自的变换，所以这里把他们的 transition 设置在了最终状态的元素中，不过你一定看到了 .demo 中的 transition 属性，这个属性并不是实现width变大的过渡效果，而是实现从最终状态变回初始状态的过渡效果，这时的两个最终状态就变成了初始状态，而原来的初始状态就成了这次变换中的最终状态，所以这个过程的 transition 属性设置在 .demo 中 animationanimation通过动画关键帧来实现过渡动画的效果，是一个复合属性，主要包括下面将要介绍的几个子属性 关键帧说明 animation用来实现过渡动画的效果的，transition也是实现过渡动画效果的，那两者有什么区别呢？从定义可以 看的出来，animation是通过关键帧来实现过渡动画效果的，一个关键帧代表了整个动画过程中的一个状态（以视频中的每一帧类比），通过定义关键帧的样式来控制CSS动画序列的中间步骤，与transition相比能更好的控制中间状态的动画 创建关键帧 要使用关键帧, 先创建一个带名称的@keyframes规则，以便后续使用 animation-name 这个属性来将一个动画同其关键帧声明匹配。每个@keyframes 规则包含多个关键帧，也就是一段样式块语句，每个关键帧有一个百分比值作为名称，代表在动画进行中，在哪个阶段触发这个帧所包含的样式。 关键帧百分比列出的顺序不影响它被执行的顺序，他们会按照该发生的顺序来处理 让关键帧生效 如果一个关键帧规则没有指定动画的开始或结束状态（也就是，0%/from 和100%/to，浏览器将使用元素的现有样式作为起始/结束状态。这可以用来从初始状态开始元素动画，最终返回初始状态。 如果在关键帧的样式中使用了不能用作动画的属性，那么这些属性会被忽略掉，支持动画的属性仍然是有效的，不受波及。 除了百分比以外，还可以用关键词来表示某个状态(某个关键帧)：0% ==&gt; from 100% ==&gt; to 重复定义 下面说的不支持层叠样式是Firefox 14版本之前，现在主流的浏览器基本已经支持百分比的层叠样式了，但是对于多个重名关键帧的层叠样式，还没有较好的支持（即如果关键帧使用同一个名称，则以最后一个定义为准；如果百分比重复定义，则按照层叠规则进行判断） 如果多个关键帧使用同一个名称，以最后一次的定义为准。@keyframes不存在层叠样式的情况，所以动画在一个阶段只会使用一个关键帧的数据。 如果一个@keyframes里的关键帧的百分比存在重复的情况，以最后一次定义的关键帧为准。因为@keyframes的规则不存在层叠样式的情况，即使多个关键帧设置相同的百分值也不会全部执行（执行最后一个） 属性个数不定 如果一个关键帧中没有出现其他关键帧中的属性，那么这个属性将使用插值(不能使用插值的属性除外，这些属性会被忽略掉) 这里要注意，如果没有定义 初始/结束 状态，浏览器使用元素的现有样式作为 初始/结束状态；或者 初始/结束 状态中有些属性没有设置，那么这些属性的值也是元素现有样式的值 demo 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #demo &#123; width: 100px; height: 100px; background-color: #f40; animation: demo 1s linear; &#125; @keyframes demo &#123; 50% &#123; width: 300px; &#125; &#125; @keyframes demo &#123; 0% &#123; width: 100px; &#125; 50% &#123; width: 500px; height: 200px; &#125; 50% &#123; width: 300px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 关于demo的说明： 在此样例中创建了两个同名的关键帧，以最后一个定义的关键帧为准，所以第一个关键帧不起作用 在第二个关键帧中，一共涉及了两个属性，width和height，对于height属性来说，没有定义 初始/结束 状态，所以height属性的 初始/结束 状态即为元素初始的样式（100px）；对于width来说，定义了初始状态（与元素现有的样式相同），没有定义结束状态，则结束状态为100px； 50%被重复定义，所以按照层叠样式，在50%这个时间点，元素的状态应该是width：300px；height：200px（相当于把两个50%中的定义都写在一个里面，然后判断最终的属性） 整个过程的变化就是 0% — 50% 50% — 100% width 100px -&gt; 300px 300px -&gt; 100px height 100px -&gt; 200px 200px -&gt; 100px 还有一点需要注意的就是，一个关键帧内的多个状态之间的不要用 ; 进行分隔，有可能会造成关键帧失效 animation-name定义 指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列 语法 1234567891011121314/* Single animation */animation-name: none;animation-name: test_05;animation-name: -specific;animation-name: sliding-vertically; /* Multiple animations */animation-name: test1, animation4;animation-name: none, -moz-specific, sliding; /* Global values */animation-name: initial /* 设置属性为其默认值 */animation-name: inherit /* 从父元素继承属性 */animation-name: unset demo 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #demo &#123; width: 100px; height: 100px; background-color: #f40; /* 写法一： */ animation-name: demo1, demo2; animation-duration: 1s, 1s; /* 写法二： */ /* animation: demo1 1s, demo2 1s; */ &#125; @keyframes demo1 &#123; 100% &#123; width: 200px; &#125; &#125; @keyframes demo2 &#123; 100% &#123; height: 200px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注意 写法一与写法二是等效的 animation-duration定义 指定一个动画周期的时长 语法 1234animation-duration: 6sanimation-duration: 120msanimation-duration: 1s, 15sanimation-duration: 10s, 30s, 230ms animation-timing-function定义 定义css动画在每一动画周期中执行的节奏。可能值为一个或多个 对于关键帧动画来说，timing function作用于一个关键帧周期而非整个动画周期，即从关键帧开始开始，到关键帧结束结束 定义一个关键帧区块的缓动函数应用到该关键帧；另外，若该关键帧没有定义缓动函数，则使用定义于整个动画的缓动函数 语法 123456789101112131415161718192021/* Keyword values */animation-timing-function: ease;animation-timing-function: ease-in;animation-timing-function: ease-out;animation-timing-function: ease-in-out;animation-timing-function: linear;animation-timing-function: step-start;animation-timing-function: step-end; /* Function values */animation-timing-function: cubic-bezier(0.1, 0.7, 1.0, 0.1);animation-timing-function: steps(4, end);animation-timing-function: frames(10); /* Multiple animations */animation-timing-function: ease, step-start, cubic-bezier(0.1, 0.7, 1.0, 0.1); /* Global values */animation-timing-function: inherit;animation-timing-function: initial;animation-timing-function: unset; 值 描述 linear 动画从开始到结束具有相同的速度。 ease 动画有一个缓慢的开始，然后快，结束慢。 ease-in 动画有一个缓慢的开始。 ease-out 动画结束缓慢。 ease-in-out 动画具有缓慢的开始和慢的结束。 cubic-bezier(n,n,n,n) 在立方贝塞尔函数中定义速度函数。 可能的值是从0到1的数字值。 这里关于animation-timing-function值的其他几种类型如step-start、step-end、steps(n, start/end)等后面再讲 animation-delay定义 CSS属性定义动画开始于何时，即从动画应用在元素上到动画开始的这段时间 说明 0s是该属性的默认值，代表动画在应用到元素上后立即开始执行。否则，该属性的值代表动画样式应用到元素上后到开始执行前的时间长度； 定义一个正值m会让动画经过ns的延迟后，再开始运动 定义一个负值n会让动画立即开始，开始的位置是元素运动的ns后的位置。例如，如果设定值为1s，动画会从它动画序列的第1s位置处立即开始。 demo 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @keyframes demo &#123; to &#123; left: 500px; &#125; &#125; #demo1, #demo2, #demo3 &#123; position: absolute; left: 0px; width: 100px; height: 100px; background-color: red; &#125; #demo1 &#123; top: 0px; animation: demo 2s linear 0s; &#125; #demo2 &#123; top: 120px; animation: demo 2s linear 1s; &#125; #demo3 &#123; top: 240px; animation: demo 2s linear -1s; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo1"&gt;animation-delay: 0s&lt;/div&gt; &lt;div id="demo2"&gt;animation-delay: 1s&lt;/div&gt; &lt;div id="demo3"&gt;animation-delay: -1s&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; animation-iteration-count定义 定义动画在结束前播放的次数。可以是1次（默认）、多次、无限次。 语法 12345animation-iteration-count: infinite;animation-iteration-count: 3;animation-iteration-count: 2.3; animation-iteration-count: 2, 0, infinite; demo 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @keyframes demo &#123; 30% &#123; width: 200px; &#125; 60% &#123; width: 300px; &#125; 100% &#123; width: 400px; &#125; &#125; #demo &#123; width: 100px; height: 100px; background-color: red; animation: demo 3s linear 0s; animation-iteration-count: 1; /* animation-iteration-count: 2.5; */ /* animation-iteration-count: infinite; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; animation-direction定义 指示动画播放的方向 语法 123456animation-direction: normalanimation-direction: reverseanimation-direction: alternateanimation-direction: alternate-reverseanimation-direction: normal, reverseanimation-direction: alternate, reverse, normal 值 含义 normal（默认） 动画正向播放 reverse 反向播放动画，每周期动画由尾到头运行 alternate 动画按照 “正反正反…”的顺序交替播放 alternate-reverse 动画按照 “反正反正…”的顺序交替播放 demo 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @keyframes demo &#123; 30% &#123; width: 200px; &#125; 60% &#123; width: 300px; &#125; 100% &#123; width: 400px; &#125; &#125; #demo &#123; width: 100px; height: 100px; background-color: red; animation: demo 3s linear 0s 3; animation-direction: normal; /* animation-direction: reverse; */ /* animation-direction: alternate; */ /* animation-direction: alternate-reverse; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; animation-play-state定义 定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放 语法 1234567891011/* Single animation */animation-play-state: running; /* 运行 */animation-play-state: paused; /* 暂停 */ /* Multiple animations */animation-play-state: paused, running, running; /* Global values */animation-play-state: inherited;animation-play-state: initial;animation-play-state: unset; demo 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @keyframes demo &#123; to &#123; width: 500px; &#125; &#125; #demo &#123; width: 100px; height: 100px; background-color: red; animation: demo 3s linear 0s infinite normal; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo"&gt;&lt;/div&gt; &lt;button&gt;running/paused&lt;/button&gt; &lt;script type="text/javascript"&gt; var oBtn = document.getElementsByTagName('button')[0], oDiv = document.getElementById('demo'); oBtn.onclick = function () &#123; oDiv.style.animationPlayState = window.getComputedStyle(oDiv, null)['animationPlayState'] == 'running' ? 'paused' : 'running'; console.log(window.getComputedStyle(oDiv, null)['animationPlayState']); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; animation-fill-mode定义 指定在动画执行之前和之后如何给动画的目标应用样式 语法 123456789animation-fill-mode: noneanimation-fill-mode: forwardsanimation-fill-mode: backwardsanimation-fill-mode: both /* 可以应用多个参数，这个时候使用逗号隔开 *//* 各个参数应用于与次序相对应的动画名 */animation-fill-mode: none, backwardsanimation-fill-mode: both, forwards, none 值 含义 forwards 动画结束时，目标保持动画最后一帧的样式 backwards 动画执行前，应用关键帧第一帧的样式 both 执行 forwards 和 backwards的动作 注意 上述的第一帧有可能是0%也有可能是100%（正向播放、反向播放） 对于backwards，动画采用第一帧的样式，保持 animation-delay demo 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @keyframes demo &#123; 0% &#123; left: 100px; &#125; 50% &#123; left: 200px; &#125; 100% &#123; left: 300px; &#125; &#125; #demo1, #demo2 &#123; position: absolute; left: 0px; width: 100px; height: 100px; background-color: red; &#125; #demo1 &#123; top: 0px; animation: demo 2s linear 1s; &#125; #demo2 &#123; top: 120px; animation: demo 2s linear 1s backwards; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo1"&gt;&lt;/div&gt; &lt;div id="demo2"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 可以看到，如果对于没有使用backwards值的小方块（上），在其初始位置等待延迟；对于使用backwards值的小方块（下），先立即应用第一帧的样式，然后在该位置等待延迟 下面这个demo是测试forwards和both： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @keyframes demo &#123; 0% &#123; left: 100px; &#125; 50% &#123; left: 200px; &#125; 100% &#123; left: 300px; &#125; &#125; #demo &#123; position: absolute; top: 0px; left: 0px; width: 100px; height: 100px; background-color: red; animation: demo 2s linear 1s forwards; /* animation: demo 2s linear 1s both; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; transition 和 animation的比较区别 触发条件不同 transition 通常和hover等事件配合使用，由事件触发。animation 则和 gif效果差不多 循环 transition 是一次性的，除非反复的触发事件；而 animation可以设定循环，重复播放 精确性 animation 可以设定每一帧的样式和时间；transition 只能设定头尾；animation 中可以设置每一帧需要的单独变化的样式属性，transition 中所有样式属性要一起变化 与JavaScript交互 animation 与 js 的交互不是很紧密；transition 和 js 的结合更强大。js设定要变化的样式，transition 负责动画效果 应用场景 如果要灵活定制多个帧以及循环，用animation 如果要加单的from to 效果，用transition 如果要使用js灵活设定动画属性，用transition 参考链接mdn css3 animation 属性众妙]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2F2018%2F06%2F07%2Fd03_css3%2F</url>
    <content type="text"><![CDATA[基本选择器 选择器 含义 * 通配符选择器，选择任何元素 E 标签选择器，匹配所有使用E标签的元素 .demo class选择器，匹配所有class属性中包含info的元素 #demo id选择器，匹配所有id属性等于demo的元素 demo 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; p &#123; font-size: 30px; &#125; .demo1 &#123; color: red; &#125; #demo2 &#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;span&gt;1&lt;/span&gt; &lt;p class="demo1"&gt;2&lt;/p&gt; &lt;p class="demo1 demo2"&gt;3&lt;/p&gt; &lt;p id="demo2"&gt;4&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; 多元素的组合选择器 选择器 含义 E, F 多元素选择器，同时匹配所有E元素或者F元素，E和F之间用逗号分隔 E F 后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔 E &gt; F 子元素选择器，匹配所有E元素的子元素F E + F 毗邻元素选择器，匹配所有紧随E元素之后的同级元素F 注意： 后代元素选择器是选择元素的后代元素，这里的后代元素包括子元素，孙元素，重孙元素等 子元素选择器选择子元素，这里的子元素就只是父元素的直接子元素，不包括孙元素、重孙元素等 毗邻元素选择器是选择之后相邻同级元素，重点是之后相邻和同级元素（之后并且相邻，不要忽略了之后） demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #demo1, #demo2 &#123; color: red; &#125; #demo3 span &#123; color: yellow; &#125; #demo4&gt;span &#123; color: blue; &#125; #demo5+span &#123; color: deeppink; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;span id="demo1"&gt;1&lt;/span&gt; &lt;span id="demo2"&gt;2&lt;/span&gt; &lt;div id="demo3"&gt; &lt;span&gt;3&lt;/span&gt; &lt;p&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div id="demo4"&gt; &lt;span&gt;5&lt;/span&gt; &lt;p&gt;&lt;span&gt;6&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;span&gt;7&lt;/span&gt; &lt;p id="demo5"&gt; &lt;span&gt;8&lt;/span&gt; &lt;/p&gt; &lt;span&gt;9&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; CSS 2.1属性选择器 选择器 含义 E[att] 匹配所有具有att属性的E元素，不考虑它的值 E[att=val] 匹配所有att属性等于 val 的E元素 E[att~=val] 匹配所有att属性具有多个空格分隔的值、其中一个值等于”val”的E元素 X 匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以”val”开头的E元素，主要用于lang属性，比如”en”、”en-us”、”en-gb”等等 X 指的是 E[att|=val] 因为 [Hexo] 对表格的转义不太友好，会把 | 转义成新的一栏，所以只能这么写了 注意 对于属性选择器，E可以省略，那么就是匹配所有满足属性条件的任何元素 要区分属性和特性，特性指的是规范中有声明的属性，而属性包括特性，还包括我们自己定义的一些规范中没有声明的属性；比如对于 div 标签来讲，class、id等属于它的特性，而 name 就是它的属性；对于 input 标签来讲，name也属于它的特性。既然我们这里说的是属性选择器，那么就不只是能选择满足特性的元素，自己设置的属性也可以被选择出来 demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; /* 匹配所有具有name属性的p元素 */ p[name] &#123; font-size: 30px; &#125; /* 匹配所有具有name属性的元素 */ [name] &#123; color: red; &#125; /* 匹配所有class属性为 demo3 的p元素 */ p[class='demo3'] &#123; color: orange; &#125; /* 匹配所有class属性中包含 demo4 的p元素 */ p[class~='demo4'] &#123; color: blue; &#125; /* 匹配所有class属性中有连字号分隔的，以 demo5 开头的p元素 */ p[class|='demo5'] &#123; color: yellow; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;p name='demo1'&gt;1&lt;/p&gt; &lt;p name='demo2'&gt;2&lt;/p&gt; &lt;p class="demo3"&gt;3&lt;/p&gt; &lt;p class="demo4 temp1"&gt;4&lt;/p&gt; &lt;p class="temp2 demo4"&gt;5&lt;/p&gt; &lt;p class="demo5-temp3"&gt;6&lt;/p&gt; &lt;p class="demo5"&gt;7&lt;/p&gt;&lt;!-- 要注意这个没有连字符的也能被匹配 --&gt; &lt;p class="temp3-demo5"&gt;8&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; CSS 2.1 中的伪类选择器 选择器 含义 E:first-child 匹配父元素的第一个子元素 E:link 匹配所有未被点击的链接的E元素 E:visited 匹配所有已被点击的链接的E元素 E:active 匹配所有已经按下但还没有释放的E元素 E:hover 匹配鼠标悬停其上的E元素 E:focus 匹配获得焦点的E元素 E:lang(c) 匹配lang属性等于c的E元素 E:first-child 这个容易理解错，重点讲一下。这个选择器可以分成两部分，E 和 first-child E：所要匹配的元素是E元素 first-child：所匹配的元素是它直接父级的第一个子元素 即匹配E元素直接父级下的第一个子元素，如果这个元素是E则被选中 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; list-style: none; &#125; li:first-child &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;li id='demo1'&gt;1&lt;/li&gt; &lt;ul&gt; &lt;li id='demo2'&gt;2&lt;/li&gt; &lt;li id='demo3'&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; &lt;/html&gt; 我们一个一个的来分析，首先我们要匹配的元素是li，这里的三个li都满足，所以看第二个条件，li需要是它直接父级的第一个元素，对于#demo1来说，它的直接父级是body，body下第一个子元素就是#demo1，所以#demo1满足；对于#demo2，它的直接父级是ul，ul下的第一个子元素是#demo2，第二个子元素是#demo3，所以#demo2满足而#demo3不满足，接下来稍微变化一下html结构，选择器保持不变 1234567&lt;body&gt; &lt;ul&gt; &lt;span&gt;&lt;/span&gt; &lt;li id='demo1'&gt;1&lt;/li&gt; &lt;/ul&gt; &lt;li id='demo2'&gt;2&lt;/li&gt;&lt;/body&gt; 还是一步一步来分析，首先第一个条件都满足，直接看第二个条件：对于#demo1来说，它的直接父级是ul，但是他不是ul下的第一个子元素，所以不满足；对于#demo2来说，它的直接父级是body，但是body的第一个子元素是ul，不是li，所以也不满足。 demo 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; font-size: 30px; &#125; a:link &#123; color: blue; &#125; a:visited &#123; color: #ccc; &#125; a:active &#123; color: green; &#125; span:active &#123;color: green; &#125; a:hover &#123; font-size: 50px; &#125; span:hover &#123; font-size: 50px; &#125; input:focus &#123; background-color: yellow; &#125; html:lang(en) &#123; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;a href=""&gt;链接&lt;/a&gt; &lt;span&gt;不是链接&lt;/span&gt; &lt;input type="text"&gt;&lt;/body&gt; &lt;/html&gt; CSS 2.1 中的伪元素 选择器 含义 E::first-line 匹配E元素的第一行 E::first-letter 匹配E元素的第一个字母 E::before 在E元素之前插入生成的内容（E元素内部） E::after 在E元素之后插入生成的内容（E元素内部） 注意 ::before 和 ::after 这两个伪元素的之前和之后指的是逻辑上的最前和最后，且是在元素内部 demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; width: 50px; &#125; p::first-line &#123; color: red; &#125; p::first-letter &#123; font-size: 30px; &#125; div &#123; width: 100px; height: 100px; border: 1px solid #000; &#125; div::before &#123; content: ''; display: block; width: 20px; height: 20px; background-color: green; &#125; div::after &#123; content: ''; display: block; width: 20px; height: 20px; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;p id="demo1"&gt;假装这里有很多字&lt;/p&gt; &lt;div id="demo2"&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; CSS 3 的同级元素通用选择器 选择器 含义 E ~ F 匹配任何在E元素之后的同级F元素 注意 ‘E+F’: 匹配任何在E元素之后的毗邻同级元素，两钟选择器只差两个字，意思稍有不同 demo 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; list-style: none; &#125; span~li &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;span&gt;1&lt;/span&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; &lt;/html&gt; CSS 3 属性选择器 选择器 含义 E[att^=’val’] 属性att的值以 “val” 开头的E元素 E[att$=’val’] 属性att的值以 “val” 结尾的E元素 E[att*=’val’] 属性att的值包含 “val” 字符串的元素 demo 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; p[class^='demo1'] &#123; color: red; &#125; p[class$='demo2'] &#123; color: blue; &#125; p[class*='demo3'] &#123; color: orange; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;p class="demo1"&gt;1&lt;/p&gt; &lt;p class="demo1demo1"&gt;2&lt;/p&gt; &lt;p class="demo1 demo1"&gt;3&lt;/p&gt; &lt;p class="demo1-demo1"&gt;4&lt;/p&gt; &lt;p class="demo2"&gt;5&lt;/p&gt; &lt;p class="demo2demo2"&gt;6&lt;/p&gt; &lt;p class="demo2 demo2"&gt;7&lt;/p&gt; &lt;p class="demo2-demo2"&gt;8&lt;/p&gt; &lt;p class="demo3x"&gt;9&lt;/p&gt; &lt;p class="xdemo3x"&gt;10&lt;/p&gt; &lt;p class="xdemo3"&gt;11&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; CSS 3 中用户界面相关伪类选择器 选择器 含义 E:enabled 匹配表单中激活的元素 E:disabled 匹配表单中禁用的元素 E:checked 匹配表单中被选中的元素（radio、checkbox…） 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; input:enabled &#123; color: green; &#125; input:disabled &#123; color: red; &#125; input:checked &#123; width: 100px; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;input id="demo1" type="text" value="激活"&gt; &lt;input id="demo2" type="text" value="禁用" disabled&gt; &lt;input class="demo3" type="radio"&gt; &lt;input class="demo3" type="checkbox"&gt;&lt;/body&gt; &lt;/html&gt; 备注：因为radio和checkbox不能修改默认的颜色样式，所以我用大小来区分效果 CSS 3 中用户界面相关伪元素选择器 选择器 含义 E::selection 匹配用户当前选中的元素 demo 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 100px; padding: 0px; &#125; p::selection &#123; background-color: #ccc; color: deeppink; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;p&gt;很多字很多字很多字很多字很多字很多字很多字很多字很多字&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; 修改之前选中文字的效果 修改之后选中文字的效果 CSS 3 中结构性伪类 选择器 含义 E:root 匹配文档的根元素 E:empty 匹配一个不包含任何子元素的元素 E:nth-child(n) 匹配父元素的第n个子元素 E:nth-last-child(n) 匹配父元素的第n个子元素 E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1) E:only-child 匹配父元素仅有的一个子元素 E:first-of-type 匹配直接父级下同E类型元素中的第一个 E:nth-of-type(n) 匹配直接父级下同E类型元素中的第n个 E:nth-last-of-type(n) 匹配直接父级下同E类型元素中的倒数第n个 E:last-of-type 匹配直接父级下同E类型元素中的最后一个 E:only-of-type 匹配直接父级下同E类型唯一一个子元素 注意 在html文档中，用 E:root 或者 html 都能选中根标签，但是建议使用 E:root 方法来选择根标签，因为如果在xml文档中，根标签是xml，html就不能选中根标签了，所以一般都是用 E:root 方法选中根标签 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; :root &#123; background-color: orange; &#125; html &#123; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; E:empty 方法是匹配不包含任何子元素的元素，这里文本节点也会被当成是子元素，但是利用 ::after 或者 ::before 等伪元素添加的文本，不在判定的范围内 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; /* 给三个p元素添加一些基础样式 */ p &#123; width: 100px; height: 100px; border: 1px solid black; margin-top: 10px; &#125; /* 利用 ::after 伪元素 给#demo3填充内容 */ #demo3::after &#123; content: '3'; &#125; p:empty &#123; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;p id="demo1"&gt;&lt;/p&gt; &lt;p id="demo2"&gt;2&lt;/p&gt; &lt;p id="demo3"&gt;&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; 可以发现，虽然在#demo3中有文本，但是这个文本并不是我们直接写在html结构中的，而是用 ::after 伪元素添加进去的，所以这个文本不算在 伪类 :empty 的判定范围之内。所以说，表面上看起来有文本的元素，也是有可能被 :empty伪类选中的 从 E:nth-child(n) 到 E:only-child这些伪类的理解，与之前讲过的CSS 2.1中的E:first-child伪类的理解是相似的，对比理解即可，需要注意的是n是从1开始的，不是从0开始。 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; font-size: 20px; list-style: none; &#125; ul li:nth-child(3) &#123; color: red; &#125; ul li:nth-last-child(2) &#123; color: green; &#125; ul li:last-child &#123; color: orange; &#125; /* ul是它直接父级元素body下的唯一子元素 */ ul:only-child &#123; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; &lt;/html&gt; n不仅仅能填数字，还可以填表达式 比如 2n、2n+1、3n+1，这时n的取值就是从0开始递增的自然数(0,1,2,3,4,…)，所以利用表达式可以选出来一组元素，2n(0, 2, 4, 6,…)，2n+1(1, 3, 5, 7,…)，3n+1(1, 4, 7, 10…) n还可以是关键字 even代表偶数，odd代表奇数 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; list-style: none; &#125; ul li:nth-child(2n) &#123; color: red; &#125; ul li:nth-child(2n+1) &#123; color: green; &#125; ul li:nth-child(even) &#123; font-size: 50px; &#125; ul li:nth-child(odd) &#123; font-size: 40px; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; &lt;/html&gt; E:first-of-type 这一系列的伪类选择器的理解与 E:first-child 的理解有些相似但是不同，下面重点讲解一下同样，分成两部分： E：所要匹配的元素是E元素 first-of-type：E元素是它直接父级下同E元素类型中的第一个子元素元素 重点是后半部分的理解，看起来好像比较绕口，但其实就是在之前 E:first-child 后半部分的理解上多了一个同类型的限制，first-child的理解是其直接父级下的第一个子元素，而first-of-type不是其直接父元素下的第一个，而是在其直接父级下的所有E类型的元素中的第一个，举例说明 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; list-style: none; &#125; li:first-of-type &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;span&gt;1&lt;/span&gt; &lt;li id="demo1"&gt;2&lt;/li&gt; &lt;li id="demo2"&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;li id="demo3"&gt;4&lt;/li&gt;&lt;/body&gt; &lt;/html&gt; #demo1的直接父级是ul，ul下有两种类型的元素 span 和 li，#demo1是li类型中的第一个，所以可以被选中；#demo3的直接父级是body，body有两种类型的元素 ul 和 li，#demo3是，li类型中的第一个，所以可以被选中 E:only-of-type 表格中E:first-of-type之后的，E:only-of-type之前的这些伪类选择器，具体的理解参照E:first-of-type即可，下面在稍微强调一下最后一个E:only-of-type，它是匹配E元素直接父级下的E类型元素，如果这类型元素有且仅有一个，则这个E类型的元素被选中，简单的说就是E的直接父级下，如果仅有一个E类型的元素，那么他将会被选中 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; list-style: none; &#125; li:nth-of-type(1) &#123; color: red; &#125; li:nth-last-of-type(1) &#123; color: orange; &#125; li:last-of-type &#123; font-size: 30px; &#125; /* span 的直接父级ul下只有一个span类型的元素，那么他可以被选中 */ span:only-of-type &#123; color: blue; &#125; /* em 的直接父级ul下有两个em类型的元素，那么他不可以被选中 */ em:only-of-type &#123; color: deeppink; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;li id="demo1"&gt;1&lt;/li&gt; &lt;ul&gt; &lt;span&gt;span&lt;/span&gt; &lt;em&gt;em&lt;/em&gt; &lt;em&gt;em&lt;/em&gt; &lt;li id="demo2"&gt;2&lt;/li&gt; &lt;li id="demo3"&gt;3&lt;/li&gt; &lt;li id="demo4"&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;li id="demo5"&gt;5&lt;/li&gt;&lt;/body&gt; &lt;/html&gt; CSS 3 反选伪类 选择器 含义 E:not(x) 匹配不符合参数x描述的元素 注意 x是简单的选择器（属性选择器，标签选择器，类选择器，id选择器，通配符选择器等）。其实也可以使用多元素选择器作为其参数（’,’分隔的那个），但是这个只是实验性的，尚未得到广泛支持，所以最好不要使用 :not 伪类的优先级就是他参数选择器的优先级。:not 伪类不会增加选参数选择起的优先级，但是可以利用这个特点提高规则的优先级，比如#foo:not(#bar) 和 #foo匹配相同的元素，但是前者的优先级更高 :not(foo)会匹配任何非foo元素，包括 html 和 body，所以使用类似写法的时候要注意 可以利用这个伪类写一个完全没有用处的选择器。例如，:not(*)，这个规则不会匹配任何元素 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; p:not([id='demo2']) &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;p id="demo1"&gt;1&lt;/p&gt; &lt;p id="demo2"&gt;2&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; CSS 3 目标元素选择器 选择器 含义 E:target 匹配被location.hash选中的目标元素 注意 即锚点元素，目标元素选择器可用于选取当前活动的目标元素 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #demo1, #demo2, #demo3 &#123; width: 100px; height: 100px; border: 1px solid red; &#125; div:target &#123; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;a href="#demo1"&gt;demo1&lt;/a&gt; &lt;a href="#demo2"&gt;demo2&lt;/a&gt; &lt;a href="#demo3"&gt;demo3&lt;/a&gt; &lt;div id="demo1"&gt;&lt;/div&gt; &lt;div id="demo2"&gt;&lt;/div&gt; &lt;div id="demo3"&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>CSS3</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3新属性]]></title>
    <url>%2F2018%2F06%2F06%2Fd02_css3%2F</url>
    <content type="text"><![CDATA[border-radius功能效果实现边框圆角的功能 用法border-radius是一个复合属性，像border的设置方法一样，我们可以为border-radius的四个角设置不同大小的圆角 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 100px; background-color: orange; border-radius: 10px 30px 50px 70px; /* 分别代表 左上角，右上角、右下角、左下角 */ &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 也可以把四个角拆开分别来写，效果也是一样的 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 100px; background-color: orange; border-top-left-radius: 10px; border-top-right-radius: 30px; border-bottom-right-radius: 50px; border-bottom-left-radius: 70px; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 原理下面深入探究一下border-radius这个属性是怎么实现圆角的 以一个宽高都是100px的盒子为例，只设置border-top-left-radius: 50px;，这个过程的实现原理是：在距离左上定点宽50px、高50px的地方做垂线，以交点为圆心，50px为半径做圆，处于盒子中部分的圆弧即是我们实现的圆角效果（图不是很标准，理解意思就好） 上面我们理解了如果设置border-top-left-radius: 50px;，其实是将左上角x方向和y方向设置相同的圆角大小，那么既然一个角上有x、y两个方向，那么我们可不可以将这两个方向也设置成不同的值呢？答案是可以的 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 100px; background-color: orange; border-top-left-radius: 40px 60px; /* 将坐上角x方向设置40px的圆角，y方向设置60px的圆角 */ &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 总结一下，我们可直接通过设置 border-radius 使四个角具有相同的圆角大小；也可以分别设置四个不同的角让他们具有不同的圆角尺寸；而对于每一个单独的角，我们还可以将它分为x方向和y方向设置它的圆角 合并写法通过以上介绍可以知道，如果细分的话，一个盒子可以设置8个方向的圆角大小，那么如何将这8个方向写到一起呢 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 100px; background-color: orange; border-radius: 10px 20px 30px 40px / 50px 60px 70px 80px; /* 左上角x方向 右上角x方向 右下角x方向 左下角x方向 / 左上角y方向 右上角y方向 右下角y方向 左下角y方向 */ &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 虽然可以合起来这么写，但是这并不符合标准的代码规范，了解即可，一般不这么写 单位%，px，em… 练习画一个半圆 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 50px; background-color: orange; border-radius: 50px 50px 0px 0px; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; box-shadow功能给指定的盒子添加阴影效果 用法box-shadow: x轴偏移量 y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式] x、y轴偏移量 如果没有x、要偏移量的话，物体的阴影是与之重合的，在物体的正下方，添加偏移量后可以看到阴影 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 50px; background-color: orange; box-shadow: 10px 10px; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 阴影模糊半径 上面的例子中，为阴影添加了偏移量使我们能够看到盒子的阴影，但是还没有模糊的效果，需要我么添加模糊半径来实现模糊的效果，模糊半径越大，模糊程度越重 box-shadow: 10px 10px 5px; 阴影扩展半径 我们知道，阴影的大小与物体距离光源的距离有关，离光源远，影子较小，反之影子较大；那则么控制影子的大小呢，就要设置阴影的扩展半径（默认情况下是与物体等大的，0px是与物体等大的，往上（正值）增大，往下（负值）减小） box-shadow: 10px 10px 5px 5px; box-shadow: 10px 10px 5px -5px; 阴影颜色 阴影的默认颜色是黑色，当然，我们可以自己设置这个颜色 box-shadow: 10px 10px 5px 5px #ccc; 投影方式 默认的投影方式是向外投影的，我们也可以设置它向内投影，但多数情况下我们都是用向外投影 box-shadow: 10px 10px 5px 5px #ccc inset; 性能杀手box-shadow属性很消耗页面的性能，所以这个属性不建议过多的使用 练习给定一个列表，为列表的每一个元素添加hover效果：li边框产生阴影效果 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; padding: 0px; margin: 0px; &#125; ul &#123; margin: 100px 0px 0px 100px; width: 300px; border: 1px solid #ccc; border-bottom: none; &#125; li &#123; list-style: none; width: 100%; height: 40px; border-bottom: 1px solid #ccc; &#125; li:hover &#123; box-shadow: 0px 0px 5px 0px #888; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; &lt;/html&gt; text-shadow功能为文本添加阴影效果（同box-shadow一样，text-shadow也很消耗页面的性能） 用法text-shadow: X偏移量 y偏移量 [模糊半径] [阴影颜色] 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; text-shadow: 10px 10px 1px #f40; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;p&gt;房东的猫&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; 颜色值 rgba定义RGB是一种色彩标准，是由红(R)、绿(G)、蓝(B)的变化以及相互叠加来得到各式各样的颜色。RGBA是在RGB的基础上增加了控制alpha透明度的参数 语法color: rgba(r, g, b, a) r: 红色的百分比（0-255 / 0.0% - 100.0%） g: 绿色的百分比（0-255 / 0.0% - 100.0%） b: 蓝色的百分比（0-255 / 0.0% - 100.0%） a: 透明度的取值（0 - 1） 我们知道红、绿、蓝是颜色的三原色，通过这三种颜色的不同比例可以调配处任何颜色，所以这里通过设置这三种颜色的比例来设置颜色（最好用 0 - 255 来调配颜色，因为不是所有的浏览器都支持百分数） 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 100px; background-color: rgba(0, 255, 0, 0.5); &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; rgba和opacityrgba中的a属性可以设置透明度，opacity属性也可以设置透明度，这两种设置透明度的方法有什么区别呢？ 使用rgba设置的透明度，子代不会继承，而使用opacity设置的透明度，子代会自动继承 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; .wrapper &#123; width: 200px; height: 200px; background-color: rgba(255, 0, 0, 0.5); &#125; .inner &#123; width: 100px; height: 100px; background-color: rgba(0, 255, 0, 1); &#125; .wrapper1 &#123; margin-top: 50px; width: 200px; height: 200px; background-color: rgb(255, 0, 0); opacity: 0.5; &#125; .inner1 &#123; width: 100px; height: 100px; background-color: rgba(0, 255, 0, 1); &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="wrapper1"&gt; &lt;div class="inner1"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 渐变的背景色gradient渐变这个属性也是性能杀手，尽量减少使用 线性渐变linear-gradient([direction], color[percent], color[percent], color[percent],.....); 含义 值 值 direction 渐变的方向（默认是从上到下） 角度（deg） to top/right/bottom/left/top left/top right/….. color 颜色 颜色值 颜色值 percent 到多少为止（重点强调“到”）（默认按照颜色的个数均分比例） % px 这里重点强调percent这个属性的含义，是到设定的比例为止，而不是占多少设定的比例 举例 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 100px; background: linear-gradient(red 20%, green 50%, orange 100%); &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 这里渐变色所占的比例的正确含义是，红色所占比例到20%的位置，绿色所占比例到50%的位置，橘色所占区域到100%的位置 如果按照错误的理解，每个颜色的比例是占有的比例，比如我让每一个颜色各占33%，我们看看效果是什么 background: linear-gradient(red 33%, green 33%, orange 33%); 实际效果不是想象中的三个颜色均分，而是只有这两种颜色，这种结果首先证明了这种思路是错误的，其次我们要知道这种写法为什么会出现这样的结果 首先，盒子会把颜色列表中的最后一种颜色当做背景颜色 比如我们这样写 background: linear-gradient(red 0%, green 0%, orange 0%); 效果是这样的： 给红色加上一些比例： background: linear-gradient(red 30%, green 0%, orange 0%); 效果是这样的 如果我们给绿色和橘色也都设置30%的比例，这个区域已经被红色部分覆盖，所以这两个颜色就没有效果了，到此解释了之前提出的疑问，当然如果我们不希望看到最后一个颜色的多余效果，可以在最后添加一个透明色 background: linear-gradient(red 20%, green 40%, orange 60%, transparent); 径向渐变radial-gradient(shape at position, color[percent], color[percent],...); shape position position position color[percent] circle r(半径) center center % % px px 同线性渐变 ellipse a(长轴) b(短轴) center center % % px px 同线性渐变 注：position的值如果只写一个的话，第二个值默认是 center background: radial-gradient(circle 50px at center, red 20%, green 40%, orange 60%, transparent 100%); background: radial-gradient(ellipse 50px 40px at center, red 20%, green 40%, orange 60%, transparent 100%); word-wrap对于一段文本来说，如果他的长度超出了文本框的边界，那么会自动换行到下一行展示，前提条件是这段文本可以断句，即是多个单词构成的（有空格）；那如果现在有一个很长的单词，也想让它在要超出边界时自动换行，怎么做呢 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; width: 100px; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;p&gt;https://www.google.com&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; 正常情况下一个单词不会换行： 添加word-wrap: break-word;样式 font-face引入自己需要的字体样式 详细介绍：font-face 语法： 1234@font-face &#123; font-family: &lt;YourWebFontName&gt;; src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*; &#125; 说明： YourWebFontName:此值指的就是你自定义的字体名称，最好是使用你下载的默认字体，他将被引用到你的Web元素中的font-family。如“font-family:”YourWebFontName”;” source:此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝路径； format：此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype,opentype,truetype-aat,embedded-opentype,avg等； 推荐字体下载网站：Google Fonts 示例： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; @font-face &#123; font-family: 'self'; src: url('diyfont.eot'); /* IE9+ */ src: url('diyfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('diyfont.woff') format('woff'), /* chrome、firefox */ url('./offer/font/Poor_Story/PoorStory-Regular.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url('diyfont.svg#fontname') format('svg'); /* iOS 4.1- */ &#125; p &#123; font-family: 'self'; font-size: 25px; font-weight: blod; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;p&gt;My house is perfect. By great good fortune I have found a housekeeper no less to my mind&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; 上述多个url是兼容不同字体的兼容性写法 border的一些属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; ul &#123; position: absolute; top: 100px; left: 600px; width: 300px; height: 300px; font-size: 0px; &#125; li &#123; display: inline-block; width: 100px; height: 100px; list-style: none; font-size: 50px; text-align: center; line-height: 100px; &#125; li:nth-child(1) &#123; background-color: rgb(168, 216, 185); &#125; li:nth-child(2) &#123; background-color: rgb(125, 185, 222); &#125; li:nth-child(3) &#123; background-color: rgb(141, 116, 42); &#125; li:nth-child(4) &#123; background-color: rgb(219, 142, 113); &#125; li:nth-child(5) &#123; background-color: rgb(155, 144, 194); &#125; li:nth-child(6) &#123; background-color: rgb(129, 199, 212); &#125; li:nth-child(7) &#123; background-color: rgb(215, 196, 187); &#125; li:nth-child(8) &#123; background-color: rgb(189, 182, 186); &#125; li:nth-child(9) &#123; background-color: rgb(145, 173, 112); &#125; div &#123; width: 100px; height: 100px; padding: 100px; border: 100px solid rgba(0, 0, 0, 0.5); border-image: url('./tmpPicture/html+css/border-image.png') 149; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; &lt;/html&gt; background的一些属性background-image引入背景图片 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 300px; height: 300px; padding: 50px; border: 50px solid rgba(0, 0, 0); background-image: url('http://ww1.sinaimg.cn/large/006eYMu7ly1fsc0hczb81j308b08ct8m.jpg'); &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; background-originpadding-box引入背景图片后我们来思考一个问题，背景图片是以哪里为起点引入的呢，是从border？padding？还是content？我们把border的透明度设置为0.5，以方便看清border下的内容 border: 50px solid rgba(0, 0, 0, 0.5); 我们发现，border区域确实有图片存在，这是不是说明背景图片就是以border为起点引入的呢？其实并不是，仔细观察会发现，我们的背景图片是从1开始的但是这张图的的border区域（最左上角）却不是从1开始的，那就说明这里不是图片的起点，那这里为什么会有图片呢？这是因为background还有一个background-repeat属性，这个属性的默认值是repeat，就是说我们引入的背景图片会自动的重复展示，充满整个盒子；我们把这个属性设置为no-repeat后再观察 background-repeat: no-repeat; 这次我们发现，引入的背景图片只剩下了一张，而且起点是从padding区域开始的，即background-origin的值默认是padding-box 默认情况下是从padding区域引入的，那我们可不可以修改这个值，让他从其他区域开始引入呢？当然可以 border-box从border开始引入背景图片 background-origin: border-box; content-box从content区域开始引入背景图片 background-origin: content-box; background-repeat上面已经提到过，用来控制背景图片是否重复以充满整个盒子 background-clipborder-clip: border-box | padding-box | content-box | no-clip 参数分别表示从边框（border），或内填充（padding），或者内容区（content）向外裁剪背景。no-clip表示不裁剪，和参数border-box显示同样的效果，background-clip默认值为border-box 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 300px; height: 300px; padding: 50px; border: 50px solid rgba(0, 0, 0, 0.5); background-image: url('http://ww1.sinaimg.cn/large/006eYMu7ly1fsc0hczb81j308b08ct8m.jpg'); background-clip: content-box; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; background-clip: text从前景内容的形状（比如文字）作为裁剪区域向外裁剪，如此即可实现使用背景作为填充色之类的遮罩效果 注意：webkit独有属性，且必须配合text-fill-color属性 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; div &#123; width: 280px; height: 315px; background-image: url('http://ww1.sinaimg.cn/large/006eYMu7ly1fsc4fz9kuzj307s08racx.jpg'); -webkit-background-clip: text; -webkit-text-fill-color: transparent; word-wrap: break-word; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;iuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiuiu &lt;/div&gt; &lt;img src="http://ww1.sinaimg.cn/large/006eYMu7ly1fsc4fz9kuzj307s08racx.jpg"&gt;&lt;/body&gt; &lt;/html&gt; 上面试效果图，下面是原图 background-size背景图片的尺寸 background-size: atuo | % | px | cover | contain; auto: 默认值是 auto，即不改变图片的宽高 cover: 等比例伸缩 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; div &#123; width: 400px; height: 400px; border: 1px solid #000; background-image: url('http://ww1.sinaimg.cn/large/006eYMu7ly1fsc0hczb81j308b08ct8m.jpg'); background-repeat: no-repeat; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 添加background-size: cover; contain：包含整个图片 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0px; padding: 0px; &#125; div &#123; margin: 100px; width: 200px; height: 200px; border: 1px solid #000; background-image: url('http://ww1.sinaimg.cn/large/006eYMu7ly1fsc0hczb81j308b08ct8m.jpg'); background-repeat: no-repeat; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 添加background-size: contain; background-position背景图片的位置 box-sizing可以改变某一个盒子的渲染方式 box-sizing:content-box; ：W3C标准盒模型 box-sizing: border-box;： IE6混杂模式下盒模型]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3简介]]></title>
    <url>%2F2018%2F06%2F06%2Fd01_css3%2F</url>
    <content type="text"><![CDATA[什么是css3CSS3是CSS2的升级版本，3只是版本号，它在CSS2.1的基础上增加了很多强大的新功能。 目前主流浏览器chrome、safari、firefox、opera、甚至360都已经支持了CSS3大部分功能了，IE10以后也开始全面支持CSS3了 兼容性CSS3的兼容性问题同样也显得格外重要，并不是所有CSS3属性都通过了W3C标准，所以我们不仅要知道css3有哪些新属性，还要知道不同浏览器对于这新属性的兼容性怎们样，可参照 兼容性手册 前缀因为兼容性的问题，在编写CSS3样式时，不同的浏览器可能需要不同的前缀。它表示该CSS3属性或规则尚未成为W3C标准的一部分，是浏览器的私有属性，虽然目前较新版本的浏览器都是不需要前缀的，但是对于某些还没有通过w3c规范的属性，还是要写上前缀 对于一个新属性，为了使它兼容各种浏览器，我们要写四个带前缀的属性，这样会多出很多代码，同时也加重了我们的编码量，所以，现在一些打包工具会在项目打包时自动为我们添加上这些前缀，我们自己开发时就不用写这些前缀了]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2018%2F06%2F04%2Fc03_net%2F</url>
    <content type="text"><![CDATA[什么是跨域跨域的产生源自于现代浏览器所通用的同源策略，所谓同源策略是指： 在url的协议名、域名、端口号均相同的情况下，才允许访问相同的cookie、localStorage或者是发送Ajax请求等等 那么在协议、域名、端口号有一项不同的时候，就是跨域 为什么浏览器会禁止跨域跨域会带来一系列安全性问题，比如CSRF攻击等 浏览器禁止跨域的原理http://icewind-blog.com/2014/08/22/the-principle-of-javascript-prohibits-cross-domain/ 实现跨域的方法Flash现在不用，想了解自己查 服务器代理中转以同源的可以访问的后台文件作为中转，发送跨域请求，使浏览器不参与到这次请求中 之前强调过，同源策略是浏览器的安全策略，那么如果请求跨域请求不经过浏览器，那么不就不受同源策略的限制了么，比如：现在有一主机下的一个页面 http://localhost/a/index.html 想要请求 http://abc.com 服务器中的文件 xyz.php，如果直接向 http://abc.com 发送请求请求数据的话，是会受同源策略的限制的。我们可以在 http://localhost/a 路径下新建一个 request.php 后台文件，用http://localhost/a/index.html 调用request.php文件，用request.php文件去请求服务器中的 xyz.php 中的数据，因为 request.php 到 xyz.php 的请求没有浏览器的参与，所以不受同源策略的影响，可以跨域请求数据；数据请求成功后，将数据返回给与它同源的index.html document.domain基础域名相同，低级域名不相同时，可以通过将 document.domain 的值设置为 基础域名的方式进行跨域 比如：ke.qq.com 和 v.qq.com 这两个域名的基础域名相同，都是 qq.com ，他们的三级域名不相同，那么如果ke.qq.com下的文件要请求v.qq.com下的文件资源时，可以在请求页面和被请求页面中都设置 document.domain = &#39;qq.com&#39;;，这样两个文件就可以进行跨域访问了 JSONPjson with padding web页面中使用带有src属性的标签是不受同源策略的限制的，所以我们可以选择带有src属性的标签实现跨域 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;tmp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_ca79a146.png"&gt; &lt;script src="https://code.jquery.com/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; console.log($('img').width()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这个例子中，我们使用img标签和script标签跨域访问了非同源服务器上的资源，显然，如果我们要跨域请求某个服务器上的数据时，我们要使用script标签进行跨域 我们假设temp.js文件使我们要跨域访问服务器资源，我们用script标签跨域请求temp.js中的相应的数据 (这里的tmp.js是本地的demo文件，我们假定它是一个跨域的服务器资源) 12// tmp.js 中的内容var a = 123; 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;tmp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="./tmp.js"&gt;&lt;/script&gt; &lt;script&gt; console.log(a); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样就实现了跨域请求资源的过程，但是这种方法是用静态引入script的方法实现跨域的，而在实际的开发中，我们的需求基本上都是要动态的去请求某个数据，那么这里就需要动态的引入script标签 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;tmp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var oScript = document.createElement('script'); oScript.src = './tmp.js'; document.body.appendChild(oScript); console.log(a); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果，控制台报错: “a is no defined” 动态引入script标签，js异步执行，也就是说，在执行 console.log(a)这条语句时，资源还没有请求完成，所以会出这样的错误；那我们就要想一个方法，等到资源请求回来后，再执行我们要进行的操作 我们可以把我们想要进行的操作写在一个函数中，然后再请求的文件中，将返回值写成函数执行的形式，执行这个函数，那么在数据请求成功的时候，就会执行这个函数 12// 修改后的tmp.jstemp(&#123;&quot;name&quot;: &quot;abc&quot;&#125;); 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;tmp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var oScript = document.createElement('script'); oScript.src = './tmp.js'; document.body.appendChild(oScript); function temp(data) &#123; console.log(data.name); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样写就可以动态的创建script，跨域的请求资源，但是这里我们把处理函数都写成固定的temp，这样灵活性很不好，我们还要和后台沟通确认结构，所以为了灵活性考虑，我们直接把方法名称传给后台 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;tmp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var oScript = document.createElement('script'); oScript.src = './tmp.js?cb=temp'; document.body.appendChild(oScript); function temp(data) &#123; console.log(data.name); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; CORS跨域http://www.ruanyifeng.com/blog/2016/04/cors.html]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax]]></title>
    <url>%2F2018%2F06%2F03%2Fc02_net%2F</url>
    <content type="text"><![CDATA[form首先回忆一下from表单请求数据的方法 action 表单提交的地址，表示请求该地址的网络资源 method 浏览器使用 method 属性设置的方法将表单中的数据传送给服务器进行处理 get 浏览器会与表单处理服务器建立连接，然后直接在一个传输步骤中发送所有的表单数据：浏览器会将数据直接附在表单的 action URL 之后。这两者之间用问号进行分隔 post 浏览器将会按照下面两步来发送数据。首先，浏览器将与 action 属性中指定的表单处理服务器建立联系，一旦建立连接之后，浏览器就会按分段传输的方法将数据发送给服务器。 在服务器端，一旦 POST 样式的应用程序开始执行时，就应该从一个标志位置读取参数，而一旦读到参数，在应用程序能够使用这些表单值以前，必须对这些参数进行解码。用户特定的服务器会明确指定应用程序应该如何接受这些参数。 ‘get’ 和 ‘post’ 的区别 传输数据的长度 get方法会将数据添加在 action URL后进行数据传输，而post方法是按照分段的方法将数据发送给请求地址，所以一般发送较短的数据时可以使用get，这样也可以获得表单最佳传输性能，而发送比较长的数据时使用post；其实两种方法传递的数据都会有长度的限制，get方法传递数据较少，因为get方法传递的数据拼接在URL后面，所以不能太长；而post的方法，数据放在请求主体中，所以可以传递较多的数据，但是也同样有限制，因为如果请求的数据过大，那么频繁的向服务器请求资源可能会导致服务器崩溃，为了服务器的安全考虑，post也有长度限制 安全性 get方法发送数据是直接把数据添加到URL后面，这样任何人都可以看到请求的数据，post方法更安全，一般用get方法做一些不重要的只读操作，如果要修改服务器上的数据那么用post更好；其实安全也只是相对的，get方法数据可以直接从地址栏中看到，我们认为他不安全，但是post请求的数据我们也可以打开控制台，在请求主体中看到，只不过小白不知道而已 浏览器缓存 GET请求返回的内容可以被浏览器缓存起来。而每次提交的POST，浏览器在你按下F5的时候会跳出确认框，浏览器不会缓存POST请求返回的内容。 表单之外 如果想在表单之外调用服务器端的应用程序，而且包括向其传递参数的过程，就要采用 GET 方法，因为该方法允许把表单这样的参数包括进来作为 URL 的一部分。而另一方面，使用 POST 样式的应用程序却希望在 URL 后还能有一个来自浏览器额外的传输过程，其中传输的内容不能作为传统 a 标签的内容 enctype 规定在发送表单数据之前如何对其进行编码 application/x-www-form-urlencoded （默认） 在发送前编码所有字符 multipart/form-data(&lt;input type=&#39;file&#39;&gt;) 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值 ajax既然form表单可以请求数据，那么为什么要用ajax呢？因为form表单请求数据会对页面进行整体刷新，而ajax方式请求数据是使用异步的方式对页面进行局部刷新 Asynchronous javascript and xml“异步的JavaScript和xml”。xml也是一种数据传输格式，现在基本被JSON取代，所以这里其实可以写成Asynchronous javascript and json，但是习惯还是写成 ‘ajax’ ajax请求数据的过程 构造一个 ajax 对象 ajax.open(method, url, boolean) 设置请求的属性 URL：请求的地址 method：请求的方式 boolean：是否是异步方式请求数据 ajax.send() 发送ajax请求 ajax.onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数 ajax.readyState： 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 ajax.status 表示请求相应的结果 200 ‘OK’ 304 资源未被修改 404 未找到页面 500 服务器内部错误 …….（还有很多，遇到补充） ajax对象的一些方法 方法 描述 abort() 停止当前请求 getAllResponseHeaders() 把http请求的所有相应首部作为键/值对返回 getResponseHeader(‘server’) 返回指定首部的串值 open(method, url, ture/false) 建立对服务器的调用 send(content) 先服务器发送请求 setRequestHeader(label, value) 把指定首部设置为所提供的值，在设置任何首部前必须先调用open() ajax对象的一些属性 属性 描述 onreadystatechange 状态改变的事件触发器 readyState 对象的状态值 responseText 获得字符串形式的相应数据 responseXML 获得XML形式的相应数据 status 服务器返回的状态码 statusText 服务器返回的状态文本信息 原生JS封装ajax方法12345678910111213141516171819function ajax(method, url, data, flag, callback) &#123; method = method.toUpperCase(); var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHttp'); if (method == 'GET') &#123; xhr.open('GET', url + '?' + data, flag); xhr.send(); &#125; else if (method == 'POST') &#123; xhr.open('POST', url, flag); xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); xhr.send(data); &#125; xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; callback(xhr.responseText); &#125; &#125;;&#125;]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS]]></title>
    <url>%2F2018%2F06%2F02%2Fc01_net%2F</url>
    <content type="text"><![CDATA[URL定义资源定位器，用来定位某一特定的网络资源 标准格式协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID] 协议类型 常用的是http 、https、ftp… 服务器地址 服务器的地址是一个IP地址，我们通常用域名来代替这个IP地址对服务器进行访问 端口 http的默认端口号是 80 https的默认端口号是 443 路径 我们要访问的资源在服务器上的路径 查询 按照给定的要求对指定的文件资源进行访问 举例 访问Google https://www.google.com 写上端口号 https://www.google.com:443 我们把这个url拿到浏览器的地址栏进行搜索会发现，这个443不见了，这是因为https协议的默认端口号就是443，所以浏览器自动将这个默认的端口号隐藏掉了 域名系统DNS定义 域名 域名就是我们访问某一网络应用时所使用的名字 就好像我们要找一个人，我们可以同过这个人的名字来找到他。以互联网应用举例，比如我们要访问Google网页，我们可以直接在浏览器的地址栏中输入 www.google.com，这时浏览器就会帮我们跳转到Google的主页 DNS 域名系统DNS是互联网是用的命名系统，用来把人们使用的机器名字转换成IP地址 我们知道，互联网是通过IP地址进行通信的，我们这里使用的是域名而不是IP地址，所以就要使用域名系统DNS将域名解析成对应的IP地址，完成网络通信 域名结构层次树状结构 用非等级的名字空间来管理一个很大的而且是经常变化的名字集合是非常困难的，因此，互联网采用了层次树状结构的命名方法。采用这种命名方法，任何一个和联网上的主机或者路由器，都有一个唯一的层次结构名字，即域名 域的划分 域名中的”域”是名字空间中一个可被管理的划分，域可以划分子域，子域还可以划分子域的子域，这样就形成了顶级域、二级域、三级域等等 如上图，com是顶级域名，google是二级域名，www是三级域名 语法 DNS规定，域名中的标号都有英文字母和数字组成，每一个标号不超过63个字符(但为了记忆方便，最好不要超过12个字符)，也不区分大小写。标号中除字符(-)外不能使用其他符号。级别最低的域名写在最左边，往右逐级升高，级别最高的顶级域名写在最右边。 管理各级域名由其上一级的域名管理机构进行管理，而最高级的顶级域名有ICANN进行管理，这种方法可以是每一个域名在整个互联网范围内是唯一的，并且也容易设计出一种查找域名的机制 顶级域名 据2012年5月的统计，现在的顶级域名已有326个，原先的顶级域名分为三大类 国家顶级域名(nTLD) 又名 ccTLD(cc表示国家代码 country-code)，比如 cn：中国 us：美国 uk：英国 等… 国家顶级域也包括某些地区，如中国香港(hk)，中国台湾(tw)；此外国家顶级域可以使用一个国家自己的文字，如中国可以有 “.cn”、”.中国”、”.中國” 通用顶级域(gTLD) com：公司企业 net：网络服务机构 org：非盈利性组织 int：国际组织 edu：美国专用的教育机构 gov：美国的政府部分 mil：美国的军事部分 等… 基础结构域名 这种顶级域名只有一个，即 arpa，用于发现域名解析，因此又称为反向域名 值得注意的是，ICANN(互联网名称与数字地址分配机构) 于2011年6月20日在新加坡会议上正式批准新顶级域名(New gTLD)，任何公司、机构都有权向ICANN申请新的顶级域。新顶级域名的后缀特点使企业域名具有了显著地、强烈的标志特征。因此新顶级域名被认为是真正的企业网络商标。目前已经有一些由两个汉字组成的中文顶级域名出现了，例如，商城、公司、新闻等 二级域名 在国家顶级域名下注册的二级域名均由该国家自行确定 顶级域名为 jp 的日本，将其教育和企业机构的二级域名定为 ac 和 co，而不用 edu 和 com。我国把二级域名分为 “类别域名” 和 “行政区域名” 两大类 类别域名 共7个 ac：科研机构 com：工、商、金融企业 edu：中国的教育机构 gov：中国的政府机构 mil：中国的国防机构 net：提供互联网服务的而机构 org：非营利性的组织 行政区域名 适用于我国的各省、自治区、直辖市，例如 bj(北京市)，js(江苏省) 等等 域名树可以表示互联网域名空间的结构，下面是一个域名树的样例图 实际上它是一个倒过来的树，最上面的是根，但没有对应的名字。跟下面的一级节点就是最高一级的顶级域名。顶级域名可以往下划分子域，即二级域名。再往下划分是三级域名、四级域名等 由图还可以得到一些其他的信息，比如我们常见的 com ，它不一定就是顶级域名，也有可能是国家域名下划分的二级域名；互联网的名字空间是按照组织机构来划分的，与物理的网络无关，与IP地址中的”子网”也没有关系 域名系统结构根据域名的结构，互联网的域名系统DNS被设计成一个联机分布式数据库系统，并采用客户服务器方式进行通信。DNS使大多数名字都在本地进行解析，仅少量的解析需要在互联网上通信，因此DNS系统的效率很高。由于DNS是分布式的系统，即使单个计算机除了故障，也不会妨碍整个DNS系统的正常运行 疑问：这里的 “大多数名字都在本地进行解析”是这样理解么？ 这个联机分布式的数据库系统的每一个主机上都有相应的域名服务器程序，在该主机上解析域名时，只需要利用该主机的域名服务器程序调用本机的数据库查询？或者换一种问法？这个联机分布式的数据库系统是不是与域名服务器相对应的呢？ 域名服务器定义域名到IP地址的解析是由分布在互联网上的许多域名服务器程序共同完成的。域名服务器程序在专设的节点上运行，我们把运行域名服务器程序的机器叫做域名服务器 域名分区 从理论上讲，整个互联网可以只是用一个域名服务器，使它装入互联网上所有的主机名，并回答所有对IP地址的查询。显然这种方法并不可取，因为互联网的规模很大，这样的域名服务器肯定会因为过负荷而无法正常工作，而且一旦域名服务器出现故障，整个互联网就会瘫痪。那换一种思路，如果让每一级的域名都有一个相对应的域名服务器，使所有的域名服务器构成和上述域名树一样的结构，这样可行么？答案是否定的，这样做会使域名服务器的数量太多，使域名系统的运行效率降低。DNS采用划分区的方法来解决这个问题 一个服务器所负责管辖的（或有权限的）范围叫做区。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点补习是能够连通的（为什么）。每一个区设置相应的权限域名服务器，用来保存该区中所有的主机到IP地址的映射。 也就是说DNS服务器的管辖范围不是以域为单位而是以区为单位。区是DNS服务器实际管辖的范围。区可能等于或者小于域，但不一定大于域。 域名服务器分类根域名服务器 根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址；无论是哪一个本地域名服务器（后面讲），若要对互联网上的任何一个域名进行解析，只要自己无法解析，就首先要借助根域名服务器 到2016年2月，全世界已经在588个地点（不断增加）安装了域名服务器，但这么多的根域名服务器只用了13个不同的IP地址的域名：a.rootservers.net，b.rootservers.net，… ，m.rootservers.net。虽然只有13个域名，但是并不代表根域名服务器就只是由13台机器组成的。实际上，在互联网中是由13套装置构成这13组域名服务器，每一套装置在很多地点安装根域名服务器（也成为镜像服务器），使用同一个域名。 由于根域名服务器采用了任播技术，因此当DNS客户向某个根域名服务器的IP地址发出查询报文时，互联网上的路由器就能找到离这个DNS客户最近的一个根域名服务器（上面说了，一个根域名的IP地址对应多个根域名服务器）。这样做不仅加快了DNS查询的过程，也更加合理的利用了互联万资源。 特别注意，根域名服务器并不直接把待查询的域名直接转换成IP地址（根域名服务器也没有存放这种信息），而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询 顶级域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的应服务器的IP地址） 权限域名服务器负责管理一个分区，当一个权限域名服务器还不能给出最后的查询回答时，就告诉发出查询请求的DNS客户，下一步应当找哪一个域名服务器。 本地域名服务器当一台主机发出DNS查询请求时，这个查询请求报文被发送给本地域名服务器，每一个ISP（互联网提供商），或者一个大学，甚至一个大学里的系都可以拥有一个本地域名服务器，这种域名服务器有时也叫作默认域名服务器。本地域名服务器离用户较近，一般不超过几个路由器的距离，当所查询的主机也属于同一个本地ISP时，该本地域名服务器立即就能将所查询的主机名转换成它对应的IP地址，而不需要再去查询其他的域名服务器 查询自己当前的IP对应的本地域名服务器： 运行cmd输入 ipconfig /all 可靠性为了提高域名服务器的可靠性，DNS域名服务器都把数据复制到几个域名服务器来保存，其中的一个是主域名服务器，其他的是辅助域名服务器。当主域名服务器出现故障时，辅助域名服务器可以保证DNS的查询工作不会中断。主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中，这样就保证了数据的一致性 域名解析 域名解析的大致流程: 当某一个应用进程需要把主机名解析为IP地址时，该应用进程就调用解析程序，并成为DNS的一个客户，把待解析的域名放在DNS的请求报文中，以UDP数据报方式发给本地域名服务器（使用UDP是为了减少开销）本地域名服务器在查找域名后，把对应的IP地址放在回答报文中返回。应用进程获得目的主机的IP地址后即可进行通信。若本地域名服务器不能回答该请求，则此域名服务器就暂时成为DNS中的另一个客户，并向其他域名服务器发送查询请求。这种过程直至找到能够回答该请求的域名服务器为止。 下面讨论两种域名解析的方式： 第一，主机向本地域名服务器的查询一般都是递归查询。所谓递归查询就是：如果主机所访问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文（即替该主机继续查询，而不是让该主机自己进行下一步查询）。因此，递归查询返回的查询结果，或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址 第二，本地域名服务器向根域名服务器的查询通常是采用迭代查询，迭代查询的特点是这样的：当根域名服务器受到本地域名服务器发送的迭代查询请求时，要么给出所要查询的IP地址，要么告诉本地域名服务器，下一步应该向哪一个域名服务器进行查询。然后让本地域名服务器进行后续的查询（而不是替本地域名服务器进行后续的查询）。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器进行查询。顶级域名服务器在收到本地域名服务器查询请求后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应该向哪个权限域名服务器进行查询，本地域名服务器就这样进行迭代查询。最后，知道了所要解析的域名的IP地址然后把这个结果返回给发起查询的主机 当然，本地域名服务器也可以采用递归查询，这取决于最初的查询请求报文的设置要求使用哪种查询方式 举个例子来说明两中查询的区别： 假定域名为 m.xyz.com 的主机想知另一台主机（域名为 y.abc.com ）的IP地址，比如说主机 m.xyz.com 要发邮件给 y.abc.com，这时就必须知道 y.abc.com 的IP地址 图一的查询步骤： 主机 m.xyz.com 先向其本地域名服务器发送DNS请求报文，进行递归查询 本地域名服务器向一个根域名服务器继续发送请求报文进行迭代查询 根域名服务器告诉本地域名服务器，下一次查询的顶级域名服务器 dns.com 的IP地址 本地域名服务器根据接受的IP地址向顶级域名服务器 dns.com 发送请求报文 顶级域名服务器告诉本地域名服务器，下一次查询的权限域名服务器 dns.abc.com 的IP地址 本地域名服务器根据收到的IP地址向权限域名服务器 dns.abc.com 发送请求报文 权限域名服务器 dns.abc.com 告诉本地域名服务器，所查询主机的IP地址 本地域名服务器把最后的查询结果告诉主机 m.xyz.com 整个过程要使用8个UDP用户数据报的报文。本地域名服务器经过三次迭代查询后，从权限域名服务器 dns.abc.com 得到了主机 y.abc.com 的IP地址，最后把结果返回给发起查询的主机 m.xyz.com 图二的查询步骤： 主机 m.xyz.com 向本地域名服务器发送 DNS 请求报文，进行递归查询 本地域名服务器作为新的 DNS 客户端，将 DNS 请求报文发送给一个根域名服务器，进行递归查询 根域名服务器接收到查询请求后，自身作为一个 DNS 客户端向 相应的顶级域名服务器 dns.com 发送 DNS 请求报文 顶级域名服务器 dns.com 在收到请求后，自身作为一个 DNS 客户端，向相应的权限域名服务器 dns.abc.com 发送 DNS 请求报文 权限域名服务器 dns.abc.com 在接受到请求后，将回答报文返回它的上一级顶级域名服务器 顶级域名 dns.com 在收到回答报文后，将它返回给它的上一级根域名服务器 根域名服务器收到回答报文后，将回答报文返回给本地域名服务器 本地域名服务器收到回答报文后，将回答报文返回给请求主机 整个过程同样也是使用了8个UDP用户数据报的报文 高速缓存为了提高DNS的查询效率，并减轻根域名的服务器的负荷和减少互联网上的DNS查询报文的数量，在域名服务其中广泛使用了高速缓存（有时也称高速缓存域名服务器）。高速缓存用来存放最近查询过得域名以及从何处获得的域名映射信息的记录。 以上面域名解析的图示为例，如果在不久前已经由用户查询过域名为 y.abc.com 的IP地址，那么本地域名服务器就不必向根域名服务器重新查询 y.abc.com 的IP地址，而是直接把高速缓存中存放的场次查询结果告诉用户。 假定本域名服务器的缓存中并没有 y.abc.com 的IP地址，而是存放着顶级域名服务器 dns.com 的IP地址，那么本地域名服务器也可以不必向根域名服务器进行查询，而是直接向 dns.com 顶级域名发送查询请求报文。这样不仅可以大大减轻根域名服务器的负荷，而且也能够使互联网上的DNS查询请求和回答报文的数量大大减少。 由于名字到地址的绑定并不经常改变，为了保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如每个项目只存放两天）。当域名服务区已从缓存中删去某信息后又被请求查询该信息，就必须重新到授权管理该项域名的域名服务器获取绑定信息。当权限域名服务器回答一个查询请求时，在响应中指明绑定有效存在的时间。增加此值可减少网络开销，而减少此值可提高域名转换的准确性 不但在本地域名服务器中需要高速缓存，在主机中也很需要。许多主机在启动时从本地域名服务器下载名字和地址的全部数据，维护存放自己最近使用的域名和高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机自然应该定期地检查域名服务器以获取新的映射信息，而主机必须从缓存中删掉无效的项。由于域名改动并不频繁，大多数网点不需要花太多精力就能维护数据库的一致性。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习笔记(三)]]></title>
    <url>%2F2018%2F05%2F30%2Fb04_jQuery%2F</url>
    <content type="text"><![CDATA[动画与效果animate() 用法 animate(target, during, speedType, callback) 功能 使元素获得指定的动画效果 参数 target: 一个对象，包含想要实现的动画效果 duration: 指定的动画效果在多长时间内完成 speedType: 速率函数，表示运动的速率变化方式 callback: 回调函数 后面三个参数可以省略 demo 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .demo &#123; position: absolute; top: 0px; left: 0px; width: 100px; height: 100px; background-color: green; border: 5px solid orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $('.demo').animate(&#123;left: '500px', top: '300px', width: '150px', height: '150px', opacity: '0.5', borderWidth: '10px'&#125;, 1000, 'swing', function () &#123; console.log('运动完成'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery 提供的 speedStyle 有两种，’swing’ 和 ‘linear’，默认的是 ‘swing’，如果想用其他的速率变化方式，可以使用一个 ‘jQuery.easing.js’ 插件，插件中包含的速率变化方式及其对应的曲线如下，以供参考 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;script src="./js/jquery.easing.1.3.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .demo &#123; position: absolute; top: 0px; left: 0px; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $('.demo').animate(&#123;left: '500px', top: '300px'&#125;, 1000, 'easeInOutQuint', function () &#123; console.log('运动完成'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; stop() 功能 用来暂停或者停止当前运动 用法 stop(boolean1, boolean2) 参数 参数 意义 true false boolean1 是否停止后续所有 停止后续所有 不停止 boolean2 是否立即到达 到达 不到达 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;script src="./js/jquery.easing.1.3.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .demo &#123; position: absolute; top: 0px; left: 0px; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $('.demo').animate(&#123;left: '500px'&#125;, 1000).animate(&#123;top: '150px'&#125;, 1000); $(document).click(function () &#123; // $('.demo').stop(true, false); // $('.demo').stop(false, false); // $('.demo').stop(true, true); // $('.demo').stop(false, true); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 一共四种组合情况，自己查看效果 finish()结束所有运动，并且直接到达最终的目标点 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;script src="./js/jquery.easing.1.3.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .demo &#123; position: absolute; top: 0px; left: 0px; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $('.demo').animate(&#123;left: '500px'&#125;, 1000).animate(&#123;top: '150px'&#125;, 1000); $(document).click(function () &#123; $('.demo').finish(); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; delay()当前运动结束之后，经过一段时间的延迟，再进行后续的运行 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;script src="./js/jquery.easing.1.3.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .demo &#123; position: absolute; top: 0px; left: 0px; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $('.demo').animate(&#123;left: '500px'&#125;, 1000).delay(1000).animate(&#123;top: '150px'&#125;, 1000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; slideUp() / slideDown() / slideToggle()slideUp(): 滑动的将元素隐藏起来 slideDown(): 滑动的将元素展示出来 slideToggle(): 如果元素可见，就将其隐藏；如果不可见就展示 参数：speed（完成时间）、callback（回调函数） 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;script src="./js/jquery.easing.1.3.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .demo &#123; /* display: none; */ position: absolute; top: 0px; left: 0px; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; // $('.demo').slideUp(1000, function () &#123; console.log('finish'); &#125;); // $('.demo').css('display', 'none').slideDown(2000); // $(document).click(function () &#123; // $('.demo').slideToggle(); // &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; fadeIn() / fadeOut() / fadeToggle()功能用法与 slideUp() 等方法相同，只不过动画效果不一样，这里的动画效果是淡入淡出 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;script src="./js/jquery.easing.1.3.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .demo &#123; /* display: none; */ position: absolute; top: 0px; left: 0px; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; // $('.demo').fadeOut(1000, function () &#123; console.log('finish'); &#125;); // $('.demo').css('display', 'none').fadeIn(2000); // $(document).click(function () &#123; // $('.demo').fadeToggle(); // &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 工具方法我们之前介绍的所有方法都是以类似于 \$(‘div’).xxx 的形式调用的，这种需要先获得 dom 元素，再进行调用的方法叫做 “实例方法”，实例方法是定义在 jQuery 原型上的；接下来要介绍的是 jQuery 中的工具方法，使用工具方法不需要先获取 dom 元素，以 类似于 \$.xxx 的形式调用，工具方法定义在 jQuery 函数上 type() 功能 可以精准的的判断参数的数据类型 原生JS中判断数组和对象的三种方法 instanceof 可以来区分某一变量是数组还是对象，但是无法用来直接判断一个变量到底是数组还是变量(就是说如果明确给到两个变量，让我们区分这两个变量哪个是数组，哪个是对象，这样可以区分；但是如果给一个变量让我们用 instanceof 直接判断它是数组还是变量，这样无法实现) 1234var arr = [1,2];var obj = &#123;&#125;;console.log(arr instanceof Object);console.log(obj instanceof Object); 两个打印结果都是 true，这就是为什么无法直接判断是数组还是对象的原因，那怎么区分他是数组还是对象呢 123456var arr = [1, 2];var obj = &#123;&#125;;console.log(arr instanceof Array); // trueconsole.log(arr instanceof Object); // trueconsole.log(obj instanceof Array); // falseconsole.log(obj instanceof Object); // true 可以看到，数组属于对象的一种实例，但是对象不属于数组的一种实例，所以用这样的方法可以区分 constructor 这样的写法一般情况下是可以判断是数组还是对象，但是如果涉及到跨域的问题（不知道这样写合不合适，学到跨域再修改吧），这样判断就不准确了 Object.prototype.toString.call() 这样的方法判断数据类型很准确，原生JS中最好使用这样方法判断 1234var arr = [1, 2];var obj = &#123;&#125;;console.log(Object.prototype.toString.call(arr)); "object Array"console.log(Object.prototype.toString.call(obj)); "object Object" type()的用法 使用 jQuery 中的 type() 方法进行数据类型的判断，结果很准确 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; var arr = [1, 2]; var obj = &#123;&#125;; console.log($.type(arr)); "array" console.log($.type(obj)); "object" &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; trim()消除字符串头尾两边的空格，不改变原字符串 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; var str = ' |q h t| '; console.log($.trim(str)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; proxy() 功能 改变this指向 语法 proxy(fn, obj) 参数 fn：要改变哪个函数中this的指向 obj：要让this指向哪个对象 返回值 返回值是一个函数，这个函数以新的 this 指向调用 fn 使用 因为返回的是一个函数，所以我们要执行这个函数来使用 proxy() 的功能 123456function test() &#123; console.log(this);&#125;var obj = &#123;&#125;; $.proxy(test, obj)(); 当然fn可能有参数，我们需要传入参数，传入参数的形式有以下几种： 12345678910var obj = &#123;&#125;;function test(a, b) &#123; console.log(this); console.log(a + ' ' + b);&#125;$.proxy(test, obj)(1, 2); $.proxy(test, obj, 1, 2)(); $.proxy(test, obj, 1)(2); 可能前两种参数的位置我们还能接受，但是第三种参数位置不禁让人有些困惑，为什么要这样传参？里面一个外面一个，其实允许这样的传参方式主要是为了方便分开传参 12345678910var obj = &#123;&#125;;function test(grade, no) &#123; console.log(this); console.log(grade + ': ' + no);&#125;var fn = $.proxy(test, obj, 2015);fn(201500800529);fn(201500800530);fn(201500800531);fn(201500800532); 可以看到，这个函数一共需要两个参数：年级、学号，而现在的数据中年级都是2015级，只有学号不一样，那我们可以在执行 proxy() 方法的时候就把年级先传入进去，后面再传入不同的学号即可，即相同的参数只需传入一次 noConflict()开发时我们可能引用多个 JavaScript 类库，而这些 JavaScript 库可能都使用 \$ 作为一个函数名或者变量名，就像 jQuery 一样。如果我们需要同时使用 jQuery 和其他类库，我们可以把 jQuery中 \$ 的使用权交给其他类库 1234console.log($);var nquery = $.noConflict();console.log($);console.log(nquery); parseJSON()功能同原生js中的 JSON.parse()，解析 JSON 字符串 1234567var jsonObj = &#123; "name": "qht", "age": 20, "sex": "male"&#125;var str = JSON.stringify(jsonObj);console.log($.parseJSON(str)); makeArray()把类数组转换成数组，相当于原生js中的 Array.prototype.slice() 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var oDiv = $('div'); var arr = $.makeArray(oDiv); // var arr = Array.prototype.slice.call(oDiv); console.log($.type(oDiv)); // "object" console.log($.type(arr)); // "array" &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery高级方法extend() 插件扩展功能 当我们需要自定义一些功能方法的时候，就要使用 extend() 方法将这些扩展方法添加到 jQuery 的函数或者原型链上，有两种插件扩展的方式：扩展工具方法、扩展实例方法 $.extend() 扩展工具方法：将扩展的工具方法添加到 jquery 函数上 123456$.extend(&#123; test: function () &#123; console.log('这是一个扩展的工具方法'); &#125;&#125;);$.test(); $.fn.extend() $.fn = $.prototype，为了不写比较长的 prototype，做了这样的处理，所以 $.fn 就相当于是 $.prototype 扩展实例方法：将扩展的工具方法添加到 jQuery 对象的原型链上 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="width: 100px; height: 100px;"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $.fn.extend(&#123; changeBgColor: function (color) &#123; this.css('backgroundColor', color); return this; // 为了方便后续的链式调用 &#125; &#125;); $('div').changeBgColor('green'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 一般不需要选取 dom 进行操作的方法，我们将其扩展为工具方法；需要选取 dom 元素来进行操作的方法我们将其扩展为实例方法 合并对象功能 $.extend() 和 $.fn.extend() 方法都可以用来合并对象 123456789101112131415var obj = &#123; param1: &#123; a: 1, b: 2 &#125;, no: 1&#125;;var obj1 = &#123; param2: &#123; c: 3, d: 4 &#125;, no: 2&#125;console.log(obj); 以上代码是将对象 obj1 合并到对象 obj 里面，返回合并后的 obj 对象 默认情况下，合并对象采用的是浅拷贝: 1234567891011121314151617var obj = &#123; param1: &#123; a: 1, b: 2 &#125;, no: 1&#125;;var obj1 = &#123; param2: &#123; c: 3, d: 4 &#125;, no: 2&#125;$.extend(obj, obj1);obj1.param2.c = 5;console.log(obj.param2.c); 可以看到，合并完成后，我们修改 obj1 中 param2 对象的参数，obj 中相应的参数也产生了相同的变化，说明这里使用的合并方式是浅拷贝，如果我们需要使用深拷贝，只需要给方法的第一个参数传一个true 1234567891011121314151617var obj = &#123; param1: &#123; a: 1, b: 2 &#125;, no: 1&#125;;var obj1 = &#123; param2: &#123; c: 3, d: 4 &#125;, no: 2&#125;$.extend(true, obj, obj1);obj1.param2.c = 5;console.log(obj.param2.c); Callbacks()通过构造、使用回调函数对象来管理回调函数队列的方法 用法 要使用 Callbacks() 方法首先要构造一个回调函数对象 1var cb = $.Callbacks(); 使用 add() 方法向回调函数队列中添加需要执行的回调函数，一次可以添加多个回调函数，且可以重复 123456789101112131415function fn1() &#123; console.log('fn1');&#125; function fn2() &#123; console.log('fn2');&#125; function fn3() &#123; console.log('fn3');&#125; cb.add(fn1, fn1); // 一次可以添加多个回调函数，且可以重复cb.add(fn2);cb.add(fn3); 使用 fire() 函数触发执行回调函数队列(队列是先入先出)，重复执行 cb.fireF()，回调函数队列也会重复被执行 1cb.fire(); 完整的测试代码： 123456789101112131415161718var cb = $.Callbacks(); function fn1() &#123; console.log('fn1');&#125;function fn2() &#123; console.log('fn2');&#125;function fn3() &#123; console.log('fn3');&#125; cb.add(fn1, fn1); // 可以一次添加多个函数，且可以重复cb.add(fn2);cb.add(fn3); cb.fire();cb.fire(); // 重复执行cb.fire()，回调函数队列也会重复被执行 四个参数 once 只执行一次 fire() 方法，即使重复调用也不会重复执行 123456789101112131415161718var cb = $.Callbacks('once'); function fn1() &#123; console.log('fn1');&#125;function fn2() &#123; console.log('fn2');&#125;function fn3() &#123; console.log('fn3');&#125; cb.add(fn1);cb.add(fn2);cb.add(fn3); cb.fire();cb.fire(); unique 回调函数中重复的函数只会执行一次 123456789101112131415161718var cb = $.Callbacks('unique'); function fn1() &#123; console.log('fn1');&#125;function fn2() &#123; console.log('fn2');&#125;function fn3() &#123; console.log('fn3');&#125; cb.add(fn1, fn1);cb.add(fn1);cb.add(fn2);cb.add(fn3); cb.fire(); stopOnFalse 当某一个回调函数的返回值是 false 时，该回调函数队列停止执行，后面的回调函数都不会被执行 123456789101112131415161718var cb = $.Callbacks('stopOnFalse'); function fn1() &#123; console.log('fn1');&#125;function fn2() &#123; console.log('fn2'); return false;&#125;function fn3() &#123; console.log('fn3');&#125; cb.add(fn1);cb.add(fn2); // 回调函数fn2返回false，后面的回调函数fn3不会再被执行cb.add(fn3); cb.fire(); memory fire() 的调用将会被”记忆”，即使在 fire() 方法执行后再使用 add() 方法添加回调函数，这个回调函数也会被执行 123456789101112131415161718var cb = $.Callbacks('memory'); function fn1() &#123; console.log('fn1');&#125;function fn2() &#123; console.log('fn2');&#125;function fn3() &#123; console.log('fn3');&#125; cb.add(fn1);cb.add(fn2); cb.fire(); cb.add(fn3); // 在 fire() 方法后添加，同样会被执行 参数混合使用 有时可能不只要满足一个参数的需求，可以同时使用多个参数 123456789101112131415161718var cb = $.Callbacks('once unique'); function fn1() &#123; console.log('fn1');&#125;function fn2() &#123; console.log('fn2');&#125;function fn3() &#123; console.log('fn3');&#125; cb.add(fn1, fn2);cb.add(fn2);cb.add(fn3); cb.fire();cb.fire(); Deferred()用于构造延迟对象，管理回调函数的状态； 相当于是有状态的回调函数 构造延迟对象 1var dtd = $.Deferred(); 管理函数状态 123456789function test(status) &#123; if (status == 1) &#123; dtd.resolve(); &#125; else if (status == 2) &#123; dtd.reject(); &#125; else &#123; dtd.notify(); &#125;&#125; resolve()、reject()、notify() 三个方法分别代表了函数的三个状态：成功、失败、进行中 执行相应的回调函数 123456789dtd.done(function () &#123; console.log('成功');&#125;);dtd.fail(function () &#123; console.log('失败');&#125;);dtd.progress(function () &#123; console.log('进行中');&#125;); 调用 test() 进行测试 123test(1);// test(2);// test(3); 以上部分完整代码 1234567891011121314151617181920212223var dtd = $.Deferred(); function test(status) &#123; if (status == 1) &#123; dtd.resolve(); &#125; else if (status == 2) &#123; dtd.reject(); &#125; else &#123; dtd.notify(); &#125;&#125; dtd.done(function () &#123; console.log('成功');&#125;);dtd.fail(function () &#123; console.log('失败');&#125;);dtd.progress(function () &#123; console.log('进行中');&#125;); test(1); 在测试上面的代码时，如果你先使用了 test(1) 或者 test(2) 进行测试，那么在后续的测试中，再使用其他的参数进行测试都不会按照预计的结果执行，如： 123test(1);test(2);test(3); 打印结果： 结果只有一个成功，而没有预想中的 失败 和 进行中，这是为什么呢？ 当 done 状态的回调函数或者 fail 状态的回调函数有一个被触发时，其他的函数就不能再被触发了 在上面抛出的问题中，首先触发了 done 状态的回调函数，所以后面其他状态的回调函数就不会再被执行了 避免函数状态受到外部因素干扰 在 test 方法中，我们使用 dtd.resolve()、dtd.reject()、dtd.notify()管理函数的状态，但如果我在函数外部使用同样的方法改变它的状态也是可以的，比如： 1234567891011121314151617181920212223var dtd = $.Deferred(); function test(status) &#123; if (status == 1) &#123; dtd.resolve(); &#125; else if (status == 2) &#123; dtd.reject(); &#125; else &#123; dtd.notify(); &#125;&#125; dtd.done(function () &#123; console.log('成功');&#125;);dtd.fail(function () &#123; console.log('失败');&#125;);dtd.progress(function () &#123; console.log('进行中');&#125;);dtd.resolve();test(3); 在这组测试代码中，test() 方法的参数是3，本来想让函数的状态修改为”进行中”，但是我在外部使用dtd.resolve() 将函数的状态修改为 resolve，导致打印结果变成 “成功” 如何避免外部因素的干扰 将 dtd 延迟对象创建于函数中，向外部返回一个不能触发的 dtd 延迟对象 1234567891011121314151617181920212223function test(status) &#123; var dtd = $.Deferred(); // 函数内部构造延迟对象 if (status == 1) &#123; dtd.resolve(); &#125; else if (status == 2) &#123; dtd.reject(); &#125; else &#123; dtd.notify(); &#125; return dtd.promise(); // 返回一个不能触发函数(无状态)&#125;var dtd = test(3);// dtd.resolve(); // 会报错，resolve() is not a functiondtd.done(function () &#123; console.log('成功');&#125;);dtd.fail(function () &#123; console.log('失败');&#125;);dtd.progress(function () &#123; console.log('进行中');&#125;); when()管理多个函数的状态，当所有函数的状态全部是”成功”时，才会触发 done 状态的函数；如过有一个状态为失败，则触发 fail 状态的函数；如果有一个状态为进行中，则什么也不打印(我自己测试的结果是什么也不打印) 1234567891011121314151617181920212223242526272829function test(status) &#123; var dtd = $.Deferred(); if (status == 1) &#123; dtd.resolve(); &#125; else if (status == 2) &#123; dtd.reject(); &#125; else &#123; dtd.notify(); &#125; return dtd.promise();&#125; function temp() &#123; return $.Deferred().resolve().promise();&#125;var dtd = test(1);var dtd1 = temp(); var dtdAll = $.when(dtd, dtd1);dtdAll.done(function () &#123; console.log('成功');&#125;);dtdAll.fail(function () &#123; console.log('失败');&#125;);dtdAll.progress(function () &#123; console.log('进行中');&#125;); ajax()通过 HTTP 请求加载远程数据 以一个对象作为参数，配置请求的各种属性 属性参数 type 请求方式：get / post / delete … url 请求路径 data 请求数据 async 是否异步，默认是true cache 是否缓存，默认是 true；如果数据要分分钟更新的时候，比如说获取图片验证码时我们就要添加 false，事件上是添加事件戳 datatype 预期服务器返回的数据类型，如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息只能判断，比如 XML MIME 就被识别为 XML。JSON 回生成一个 JavaScript 对象，而 script 会执行这个脚本。随后服务器端返回的数据会根据这个值解析后，传递给回调函数 “xml” 返回 XML 文档，可用 jQuery 处理。 “html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。 “script” 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 “cache” 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载） “json” 返回 JSON 数据 。 “jsonp”: JSONP 格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 “text”: 返回纯文本字符串 如果指定了 script 或者 jsonp 类型，那么当从服务器接收到数据时，实际上是用了 &lt;script&gt; 标签而不是 XMLHttpRequest 对象。这种情况下，$.ajax() 不再返回一个 XMLHttpRequest 对象，并且也不会传递事件处理函数，比如 beforeSend jsonp 在一个 jsonp 请求中重写回调函数的变量名，用这个值来代替 callback 部分 jsonpCallback 在一个 jsonp 请求中重写回到函数的值，用这个值来代替 jQuery 自动生成的随机函数名 crossDomain 同域请求为 false，跨域请求为 true，如果想用这种方法实现 ajax 跨域，那么需要服务端设置相关的配置支持这种跨域的方法 contentType 发送信息至服务器时，内容编码的类型，默认是 “application/x-www-form-urlencoded” 默认值适合大多数情况，如果明确传递了一个 content-type 给 ajax，那么他必定会发送给服务器，即使没有数据要发送 context 设置回调函数的执行上下文，就是说，让回调函数内 this 指向某一个对象 方法参数 beforeSend 在发送请求之前调用，并且传入一个 XMLHTTPRequest 对象作为参数 success 请求成功时触发的函数 error 请求失败时触发的函数 dataFilter 在请求成功之后调用，传入返回数据以及 “dataType” 参数的值。并且返回新的数据（可能是处理过的）传递给 success 回调函数 complete 当请求成功后调用这个函数，无论成功或者失败。传入 XMLHTTPRequest 对象，以及一个包含成功或者错误的字符串 jsonp这里详细讲解一下使用 jsonp 发送 ajax 请求时参数中回调函数的问题 前面讲 jsonp 的时候讲过，如果我们要请求 jsonp格 式的数据，我们需要在请求的 url 后面的参数中拼接一个回调函数，用来完成后端到前端的数据传递，比如 http://www.abc.com?q=sth&amp;callback=test 中的 callback = test，这里的 callback 不是固定的，要根据不同请求地址后台自己的规定而定（比如百度是 cb=xx，豆瓣是 callback=xx）。在 jQuery 的 ajax 中，如果我们使用的 dataType 是 jsonp，那么jQuery默认会自动为我们拼接上 “callback=随机函数”，所以如果我们要请求的后台规定的接口是 callback 的话，那我们就不需要在data数据的后面再次拼接 callback=xx；如果不是callback而是其他的像 cb、cbs 这些的话，我们就要单独设置相应的接口 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; $.ajax(&#123; type: 'GET', url: 'https://api.douban.com/v2/music/search', data: 'q=房东的猫', dataType: 'JSONP', success: function (data) &#123; console.log(data); &#125; &#125;); $.ajax(&#123; type: 'GET', url: 'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su', data: 'wd=房东的猫', dataType: 'JSONP', jsonp: 'cb', success: function () &#123; console.log('success'); &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，第一个 ajax 请求我们既没有设置 jsonp 属性，也没有设置 jsonpCallback 属性，然后成功的请求到了 jsonp 数据，这是因为上面说到 jQuery 会自动为我们添加上 callback=随机函数，而且豆瓣的后台借口就是使用的 callback，所以请求数据成功，成功的执行了 success 函数；而对于第二个 ajax 请求，百度搜索后台的接口是 cb 不是 callback，所以我们要设置 jsonp 为后台接口给定的形式 cb，但是这里并没有设置 cb等于什么，也就是回调函数的名字，为什么也请求成功了呢？因为只要我们设置 jsonp，在发送 ajax 请求时，jQuery 也会它自动补上一个随机函数名作为回调函数的名字，所以可以请求成功，成功的执行 success函数 也可以将 success 函数定义在外面 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; $.ajax(&#123; type: 'GET', url: 'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su', data: 'wd=房东的猫', dataType: 'JSONP', jsonp: 'cb', success: test &#125;); function test(data) &#123; console.log(data); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 除了执行 success 函数，我们也可以执行自己定义好的函数 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; $.ajax(&#123; type: 'GET', url: 'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su', data: 'wd=房东的猫', dataType: 'JSONP', jsonp: 'cb', jsonpCallback: 'test' &#125;); function test(data) &#123; console.log(data); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习笔记(二)]]></title>
    <url>%2F2018%2F05%2F29%2Fb03_jQuery%2F</url>
    <content type="text"><![CDATA[事件dom.click(function () {})类似于这种形式，直接为 dom 元素绑定事件 on() 语法 dom.on(event, src, param, function() {}); 参数 event: 需要绑定的事件 src: 可以执行事件的事件源对象 param: 需要向事件处理函数中传入的参数 function: 事件处理函数 实例讲解 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .wrapper &#123; width: 300px; height: 300px; background-color: gray; &#125; .inner1, .inner2 &#123; width: 100px; height: 100px; background-color: green; margin-bottom: 20px; &#125; .inner2 &#123; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="inner1"&gt;&lt;/div&gt; &lt;div class="inner2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; $('.wrapper').on('click', '.inner1', [1, 2, 3], function (e)&#123; console.log(e.target); console.log(e.data); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 详解： 一共构造了三个 dom 元素，wrapper 和他的两个子元素 inner1、inner2，用on给父元素 wrapper 绑定了 ‘click’ 事件；设置事件源对象是 ‘.inner1’，即只有 wrapper 下的 inner 被点击时才会触发该事件；将数组 [1,2,3] 作为参数传入事件处理函数 function；function 中打印了传入的参数 e.data 和 事件源对象 注意 事件源对象和传入参数这两个参数可以省略，当这两个参数都省略时没什么，但如果只有一个参数被省略掉时，这个参数的形式可能会引起歧义：如果参数不是字符串形式，那么这个参数会被当做第三个参数即传入参数来看待；如果参数是字符串，那这个参数会被当做事件源对象来看待 off() 功能 取消事件绑定 语法 dom.off(event, param1, param2…) 参数 event：需要解除绑定的事件 param：精确定位某一事件的条件 demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .wrapper &#123; width: 300px; height: 300px; background-color: gray; &#125; .inner1, .inner2 &#123; width: 100px; height: 100px; background-color: green; margin-bottom: 20px; &#125; .inner2 &#123; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="inner1"&gt;&lt;/div&gt; &lt;div class="inner2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; $('.wrapper').on('click', '.inner1', [1, 2, 3], function (e)&#123; console.log(e.target); console.log(e.data); &#125;); function fn1() &#123; console.log('fn1'); &#125; function fn2() &#123; console.log('fn2'); &#125; $('.wrapper').on('click', '.inner2', fn1); $('.wrapper').on('click', '.inner2', fn2); // 取消wrapper下所有元素的事件 // $('.wrapper').off('click'); // 取消wrapper下事件源对象为 inner1 元素的事件 // $('.wrapper').off('click', '.inner1'); // 取消wrapper下事件源对象为 inner2，且处理函数为 fn1 元素的事件 $('.wrapper').off('click', '.inner2', fn1); // 取消wrapper下事件源对象为 inner2，且处理函数为 fn2 元素的事件 $('.wrapper').off('click', '.inner2', fn2); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; one() 功能 绑定一次性事件 语法 语法和 on() 相同 demo 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $('div').one('click', function () &#123; console.log('执行了一次'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件对象e.pageY / e.clientY / e.screenYe.pageY：相对于文档顶部距离（和滚动条相关） e.clientY：相对于可视区窗口顶部的距离（和滚动条无关） e.screenY：相对于电脑屏幕顶部的距离（和浏览器的位置相关） 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .null &#123; height: 1500px; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class="null"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $(window).click(function (e) &#123; console.log(e.clientY); console.log(e.pageY); console.log(e.screenY); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; e.which / e.buttonwhich：对于键盘上的每一个按键都会返回一个值，以此来区分是哪个键；对于鼠标来说，左键的which值是1，右键是3，滚轮是2 button：对于鼠标的三个键，左键是0，右键是2，滚轮是1 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;input type="text"&gt; &lt;script type="text/javascript"&gt; $(window).on('contextmenu', function (e) &#123; e.preventDefault(); &#125;); $('input').on('keydown', function (e) &#123; console.log(e.which); &#125;); $('input').on('mousedown', function (e) &#123; console.log(e.which); console.log(e.button); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; e.preventDefault()取消默认事件，jQuery已经封装好了它的兼容性 e.stopPropagation()取消冒泡，jQuery已经封装好了它的兼容性 return false可以取消默认事件，也可以取消冒泡 trigger() 功能 事件触发器，用来在指定的条件下触发事件 用法 trigger(event, data) event: 事件类型 data: 参数数组，作为参数传递给要触发的事件处理函数 自定义事件 除了可以触发系统设定的事件外，还可以触发自定义事件 demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .demo &#123; position: absolute; top: 0px; left: 0px; width: 100px; height: 100px; background-color: green; &#125; button &#123; margin-left: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;button class="test1"&gt;点我也能触发demo的点击事件&lt;/button&gt; &lt;button class="test2"&gt;点我触发自定义的"move"事件&lt;/button&gt; &lt;script type="text/javascript"&gt; $('.demo').on('click', function (e, data1, data2) &#123; console.log(data1); console.log(data2); console.log('触发了demo点击事件'); &#125;); $('.test1').on('click', function () &#123; $('.demo').trigger('click', ['11', '22']); &#125;); $('.demo').on('move', function () &#123; console.log('触发了自定义的move事件'); $(this).animate(&#123;top: '300px', left: '300px', opacity: '0.5'&#125;, 1500); &#125;); $('.test2').on('click', function () &#123; $('.demo').trigger('move'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; trigger 的第二个参数是用来向要被触发的事件处理函数传递参数，这里的第二个参数必须是数组的形式；而在事件处理函数接受这些参数时，不能一下接受一个数组，而是一个一个的接受 一些方法scrollTop()滚动条滚动出去的距离 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; div &#123; height: 1000px; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $(window).scroll(function () &#123; console.log($(window).scrollTop()); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 利用这个方法可以实现 fixed 的效果（fixed在IE中的兼容性不好） 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .null &#123; height: 1500px; width: 1500px; &#125; .demo &#123; position: absolute; top: 100px; left: 100px; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class="null"&gt;&lt;/div&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $(window).scroll(function () &#123; $('.demo').css(&#123;top: $(window).scrollTop() + 100, left: $(window).scrollLeft() + 100&#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; width() / innerWidth() / outerWidth()width()：content innerWidth()：content + padding outerWidth()：content + padding + border outerWidth()：content + padding + border + margin 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .demo &#123; margin: 20px; width: 100px; height: 100px; background-color: green; padding: 10px; border: 5px solid #000; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; console.log($('.demo').width()); console.log($('.demo').innerWidth()); console.log($('.demo').outerWidth()); console.log($('.demo').outerWidth(true)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; offset().left/top / position().left/topoffset().left/top：元素相对于文档的坐标 position().left/top：元素相对于最近有定位的父级的坐标（没有就相对于文档） parent() / offsetParent() / parents() / closest() dom.parent(param) 该 dom 元素的直接父元素，参数可以省略，如果加参数的话，意思是如果该 dom 元素的直接父元素满足参数指定特征才返回这个父元素，否则不返回 dom.offsetParent() 返回距离该 dom 元素最近的有定位的父级元素 dom.parents(param) 返回该 dom 元素所有父元素，可以加参数，结果根据参数再次筛选 dom.closest(param) 返回在该 dom 元素所有的父级元素中，距离它最近的满足参数特征的元素 demo 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1" style="position: absolute"&gt; &lt;p class="box2"&gt; &lt;span class="box3"&gt; &lt;em class="box5"&gt;&lt;/em&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; console.log($('em').parent()); console.log($('em').parent('box4')); console.log($('em').offsetParent()); console.log($('em').parents()); console.log($('em').closest('div')); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里有个问题，如果标签是这样的结构，那么对于这些方法都好理解，但是如果在 em 标签下面在添加一个 p 标签（与 em 标签同级），结果就完全不一样了，按理说与 em 同级的元素不会影响到 em 的父元素是谁啊，为什么会出现这样的结果 val()和原生 JS 中的 value 属性功能相同 each() 功能 循环遍历jQuery对象 用法 each(function(index, ele) {}) 这里类似于原生 js 中的 forEach 方法，但是注意回调函数中的参数顺序是先写 index，后写 ele，因为ele 是可写可不写的 demo 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; $('li').each(function (index, ele) &#123; console.log(index); console.log(ele); &#125;); $('li').each(function (index) &#123; console.log(index); console.log(this); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，每一次的 ele 都可以被 this 代替，所以一般 ele 可以省略掉，只需要用 index，所以 index 参数写在前面（jQuery 类似这种循环遍历的方法，参数的顺序都是这样的） end() 功能 回退到上一次选择出来的 jQuery 对象 好处 方便链式调用 demo ul 下有4个 li，现在要把第二个设为红色，第三个设为绿色 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; // 一般情况下我们是这样实现的，需要两行代码 // $('li').eq(1).css('color', 'red'); // $('li').eq(2).css('color', 'green'); // 使用end() 方法，只需要一行代码 $('li').eq(1).css('color', 'red').end().eq(2).css('color', 'green'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; preObject 属性 使用上面的 end() 方法简化了代码，但是为什么 end() 具有这样的功能呢，jQuery 中怎么实现的？首先我们先来了解一下 preObject 属性 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; console.log($('li').eq(1)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码的功能是打印筛选出来的第二个 li，展开这个 li 对象，我们可以看到有一个 prevObject 属性，这个属性就是上一次被选中的 jQuery 对象（通过 $(‘li’) 选中的），end() 方法就是访问这个属性实现回退功能的；每一个备选出来的 jQuery 对象都有这个属性，如果它是直接被选出来的（就像上面的 &amp;(‘li’)）那么他的 prevObject 属性是 document add()add() 方法是为了集中操作 dom 元素，方便链式调用 现在有两个 ul，每个 ul 下有4个 li，现在要把每个 ul 下的第一个 li 字体设为绿色 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="first"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;ul class="last"&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; $('.first li').eq(0).add($('.last li').eq(0)).css('color', 'red'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; siblings() / prevAll() / nextAll() / prevUntil() / nextUntil() dom.siblings() 该dom元素的所有兄弟元素 dom.prevAll() 该dom元素前面的兄弟元素 dom.nextAll() 该dom元素后面的兄弟元素 dom.prevUntil(param) / dom.nextUntil(param) 掐头去尾选中元素，传 jQuery 对象或者 dom demo 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; // siblings() // $('li').eq(2).siblings().css('color', 'red'); // prevAll() // $('li').eq(2).prevAll().css('color', 'red'); // nextAll() // $('li').eq(2).nextAll().css('color', 'red'); // prevUntil() // $('li').eq(2).prevUntil($('li').eq(0)).css('color', 'red'); // nextUntil() // $('li').eq(2).nextUntil($('li').eq(4)).css('color', 'red'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; clone()克隆节点，参数为 true 时还能克隆节点上的事件 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; div &#123; width: 100px; height: 100px; background-color: green; margin-top: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;点我查看有没有点击事件&lt;/div&gt; &lt;script type="text/javascript"&gt; $('div').click(function () &#123; console.log('点击事件'); &#125;); var oDiv1 = $('div').clone(), oDiv2 = $('div').clone(true); $('body').append(oDiv1).append(oDiv2); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 分别克隆得到的第二个和第三个方块，第二个没有点击事件，第三个有点击事件 wrap() / wrapInner() / wrapAll() / unwrap() wrap() 给选中的 jQuery 对象外面添加一层 wrapper，参数可以 function，用来进行筛选 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; // 给所有的li添加一层p标签 // $('li').wrap('&lt;p&gt;'); // 给下标是3的倍数的li添加一层p标签 // $('li').wrap(function (index) &#123; // if (index % 3 == 0) &#123; // return '&lt;p&gt;' // &#125; // &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; wrapInner() 给选中的 jQuery 对象里面添加一层 wrapper，参数可以是 function 进行筛选 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; // 给所有的li添加一层inner // $('li').wrapInner('&lt;p&gt;'); // 给所有下标为3的倍数的li，添加一层inner // $('li').wrapInner(function (index) &#123; // if (index % 3 == 0) &#123; // return '&lt;p&gt;'; // &#125; // &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; wrapAll() 包裹选中的所有元素，一般不使用 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; $('li').wrapAll('&lt;div&gt;'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面这个例子看起来就是给所有的li添加了一层 div，并没有体会到破坏结构的感觉，看下面这个例子 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;span&gt;&lt;/span&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;li&gt;5&lt;/li&gt; &lt;script type="text/javascript"&gt; $('li').wrapAll('&lt;div&gt;'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 改变后的 dom 结构 可以看到，原来在 ul 外面的 li 被拿到了 ul 里面，原来 ul 里面的 span 被拿到了 ul 外面，破坏了原有的dom 结构 unwrap() 解除包装，但是结构化的标签不能删除（html、body） 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; // 将所有li的包装ul解除了 $('li').unwrap(); // 结构化标签body不能解除 $('li').unwrap(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; slice()截取操作，算头不算尾 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; console.log($('li').slice(0,2)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; empty()清空 jQuery 对象 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; // $('ul').empty(); // 这样也可以实现 // $('ul').html(''); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; serialize() / serializeArray()串联表单数据 / 串联数据成数组 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=""&gt; &lt;input type="text" name="username"&gt; &lt;input type="password" name="password"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;script type="text/javascript"&gt; $('input').eq(2).click(function (e) &#123; e.preventDefault(); var str = $('form').serialize(); console.log(str); var strArray = $('form').serializeArray(); console.log(strArray); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建dom元素直接创建1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .demo &#123; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; $('&lt;div class="demo"&gt;&lt;/div&gt;').appendTo($('body')); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 单标签创建12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .demo &#123; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; $('&lt;div class="demo"&gt;').appendTo($('body')); $('&lt;p/&gt;').appendTo($('.demo')); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意： 第二中单标签写法是 &lt;div/&gt; 而不是 &lt;/div&gt;，且这种写法无法给标签直接写属性]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习笔记(一)]]></title>
    <url>%2F2018%2F05%2F28%2Fb02_jQuery%2F</url>
    <content type="text"><![CDATA[选择元素 基本形式 jQuery 选取元素的基本形式是 — $(); ‘$’ 是 ‘jQuery’ 的代替符号，为了更方便书写，jQuery() 就是函数调用 ()里面可以填写我们想要选取的元素（参数），这个元素允许的形式有很多，在下面介绍； 通过这种方法选取出来的结果是一个类数组（返回值），这个类数组对象继承的是 jQuery 原型上的方法； 对于被选取出来的一组元素，jQuery 是一起处理的，省略了循环，这在 js 中是不允许的; 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;p id="text"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="wrapper"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $('div').css(&#123;width: '100px', height: '100px', backgroundColor: 'green', margin: '5px'&#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面这个 demo 体现了统一处理的效果：选取出来一组 dom 元素，没有进行循环遍历，直接对所有的元素赋予样式 () 中可以填写元素的形式（参数） css 选择器 即我们在 css 中选取元素的写法也可以在这里使用 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;p id="text"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="wrapper"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; // 标签选择器 console.log($('div')); // 类选择器 console.log($('.wrapper')); // ID选择器 console.log($('#text')); // 父子选择器 console.log($('div &gt; p')); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 因为使用 css 选择器选择元素的写法有些复杂(可能会很长)，所以 jQuery 单独封装了一个函数 “sizzle”，用来选择 dom 元素，sizzle 方法中使用正则匹配的方法查找 dom 元素，效率很高；为了给有些在开发中只需要选择 dom 元素的开发者提供便利，sizzle 也单独封装成了一个类库 sizzle.js，如果开发的功能只需要使用到选择 dom 元素，那么直接引入 sizzle.js 即可 dom 元素 一些已经在 js 中被选取出来的 dom 元素，也可以被 jQuery 选取 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;p id="text"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="wrapper"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var oDiv = document.getElementsByTagName('div'), oP = document.getElementById('text'); console.log($(oDiv)); console.log($(oP)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 因为在 jQuery 中可以对被选择出来的对象进行统一的操作而不需要进行遍历，这在原生 js 中是不允许的，所以可以利用 jQuery 获取在原生 js 中被选取的 dom 元素，然后进行统一操作； 这个方法可以用来将原生的 dom 元素转换成 jQuery 对象 null / undefined 使用 null 或者 undefined 等选取元素，返回一个空的类数组 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; console.log($(null)); console.log($(undefined)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; function(){} 如果 $() ; 选中了一个函数，那么他会把这个函数立即执行一次 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; $(function ()&#123; console.log('jQuery'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 两个参数 $(‘被选取的元素’, ‘被选取元素的执行期上下文’); 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;p id="text"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="demo"&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; console.log($('p', '.demo')); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里我们想选择类名为 “demo” 的 div 下的 p 标签，所以我们想选择的元素就是 p , 它的执行期上下文就是 .demo 特殊选择方法 可以按照索引选择一组相同元素中的元素 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li id="1"&gt;1&lt;/li&gt; &lt;li id="2"&gt;2&lt;/li&gt; &lt;li id="3"&gt;3&lt;/li&gt; &lt;li id="4"&gt;4&lt;/li&gt; &lt;li id="5"&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; // 选择ul下的第一个 li console.log($('ul&gt;li:first')); // 选择ul下的最后一个 li console.log($('ul&gt;li:last')); // 选择ul下的索引为3的 li（索引是从0开始的） console.log($('ul&gt;li:eq(3)')); // 选择ul下的索引为偶数的li console.log($('ul&gt;li:even')); // 选择ul下的索引为奇数的li console.log($('ul&gt;li:odd')); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 经过上面的一系列选取方法，最终筛选出一个 dom 类数组，这个类数组还有一些方法可以对结果进行进一步的筛选 filter() 参数可以是字符串或者是函数 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li id="1"&gt;1&lt;/li&gt; &lt;li id="2"&gt;2&lt;/li&gt; &lt;li id="3"&gt;3&lt;/li&gt; &lt;li id="4"&gt;4&lt;/li&gt; &lt;li id="5"&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; var oLi1 = $('li').filter('#1'), oLi2 = $('li').filter('[id=2]'), oLi3 = $('li').filter(function (index) &#123; if (index % 3 == 0) &#123; return true; &#125; &#125;); console.log(oLi1); console.log(oLi2); console.log(oLi3); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; not() 语法与 filter() 相同，筛选的结果与 filter() 相反 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li id="1"&gt;1&lt;/li&gt; &lt;li id="2"&gt;2&lt;/li&gt; &lt;li id="3"&gt;3&lt;/li&gt; &lt;li id="4"&gt;4&lt;/li&gt; &lt;li id="5"&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; var oLi1 = $('li').not('#1'), oLi2 = $('li').not('[id=2]'), oLi3 = $('li').not(function (index) &#123; if (index % 3 == 0) &#123; return true; &#125; &#125;); console.log(oLi1); console.log(oLi2); console.log(oLi3); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; has() 筛选某一个元素包含某些特征的子元素（特征可以是标签名、类名、ID名、属性等） 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li id="1"&gt;1&lt;/li&gt; &lt;li id="2"&gt;2&lt;/li&gt; &lt;li id="3"&gt; &lt;p id="pp"&gt;3&lt;/p&gt; &lt;/li&gt; &lt;li id="4"&gt;4&lt;/li&gt; &lt;li id="5"&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; var oLi = $('li').has('p'), oLi2 = $('li').has('[id=pp]'); console.log(oLi); console.log(oLi2); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; find() 上一个 has() 筛选的是子元素拥有某些特征的父元素，而这个 find() 是直接找到拥有这些特征的子元素 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li id="1"&gt;1&lt;/li&gt; &lt;li id="2"&gt;2&lt;/li&gt; &lt;li id="3"&gt; &lt;p id="pp"&gt;3&lt;/p&gt; &lt;/li&gt; &lt;li id="4"&gt;4&lt;/li&gt; &lt;li id="5"&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; var oLi = $('li').find('p'), oLi1 = $('li').find('#pp'); console.log(oLi); console.log(oLi1); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; eq() 按照下标索引筛选元素 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li id="1"&gt;1&lt;/li&gt; &lt;li id="2"&gt;2&lt;/li&gt; &lt;li id="3"&gt; &lt;p id="pp"&gt;3&lt;/p&gt; &lt;/li&gt; &lt;li id="4"&gt;4&lt;/li&gt; &lt;li id="5"&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; console.log($('li').eq(0)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; is() 判断筛选到的元素是否满足某个特定的特征，返回值是 true / false 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li id="1"&gt;1&lt;/li&gt; &lt;li id="2"&gt;2&lt;/li&gt; &lt;li id="3"&gt; &lt;p id="pp"&gt;3&lt;/p&gt; &lt;/li&gt; &lt;li id="4"&gt;4&lt;/li&gt; &lt;li id="5"&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; var oLi = $('li').eq(0).is('#1'); console.log(oLi); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 一些方法jQuery 操作 dom 都是通过函数调用的方法实现的 css()设置元素的 css 样式 参数是字符串时，可以单独的设置元素的某一个样式 参数是对象是，可以设置元素的一组样式 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var oDiv = $('div'); // 设置css样式 oDiv.css(&#123;width: '100px', height: '100px', border: '5px solid black'&#125;); oDiv.css('backgroundColor', 'green'); // 读取css样式 console.log(oDiv.css('width')); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; css() 取值相当于 getComputed，赋值相当于 dom.style.***; css() 赋值赋一组，取值取一个（第一个），如果取得值是颜色，会在内部转换成 rgb 值 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $('div').css(&#123;width: '100px', height: '50px', display: 'inline-block'&#125;); // 赋值赋一组 $('div').eq(0).css('backgroundColor', 'red'); $('div').eq(1).css('backgroundColor', 'green'); $('div').eq(2).css('backgroundColor', 'blue'); console.log($('div').css('backgroundColor')); // 取值取第一个 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; html() / text()功能相当于原生 js 里面的 innerHTML 和 innerText 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;文本&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; // 取值 console.log($('div').html()); console.log($('div').text()); // 赋值 $('p').html('&lt;span&gt;&lt;/span&gt;'); $('span').text('更改后的文本'); // 取值 console.log($('div').html()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; html() 、text() 没有参数时是取值操作，有参数时是赋值操作；并且和 css() 一样，赋值赋一组，取值取第一个 attr() / prop()这两个方法都是针对标签属性的操作，但是他们有以下几点区别： 回想之前讲过的在原生 js 中对属性的操作，系统中设定存在的属性，我们可以直接通过 dom.attr 取值或者是赋值；但是对于系统中没有设定的、自己定义的一些属性，我们要向取值或者赋值要使用 getAttirbute()、setAttribute() 方法；jQuery 中的这两个方法同样也是这样的区别，对于系统有设定的属性（特性）可以使用prop() 来取值或者赋值；对于系统没有设定的、自己定义的属性就要采用 attr 来取值或者赋值 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo" name="qht" sex="male"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; // 取值 console.log($('div').prop('class')); // demo -- 取值成功 console.log($('div').prop('name')); // undefined -- 取值失败 console.log($('div').attr('sex')); // male -- 取值成功 // 赋值 $('div').prop('class', 'temp'); -- 赋值成功 $('div').attr('name', 'sb'); -- 赋值成功 $('div').prop('sex', 'famale'); -- 赋值失败 console.log($('div').attr('class')); console.log($('div').attr('name')); console.log($('div').attr('sex')); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 关于这两个函数的第二点区别：attr() 只能操作属性，而 prop() 可以获取一些属性的状态，返回 true / false 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="checkbox" checked&gt; &lt;input type="checkbox"&gt; &lt;script type="text/javascript"&gt; console.log($('input').attr('checked')); // checked console.log($('input:eq(0)').prop('checked')); // true console.log($('input:eq(1)').prop('checked')); // false &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样的属性还有selected、disabled等 next() / prev() / index()next(): 下一个兄弟节点 prev(): 上一个兄弟节点 index(): 该节点在兄弟节点中的索引 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li id="demo1"&gt;&lt;/li&gt; &lt;li id="demo2"&gt;&lt;/li&gt; &lt;li id="demo3"&gt;&lt;/li&gt; &lt;li id="demo4"&gt;&lt;/li&gt; &lt;li id="demo5"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; console.log($('li:eq(2)')); console.log($('li:eq(2)').prev()); console.log($('li:eq(2)').next()); console.log($('li:eq(2)').index()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; addClass() / removeClass()为 dom 元素添加 / 删除类名 参数是要添加 / 删除的类名，如果 removeClass() 的参数为空，则将 dom 元素的所有类名都删除 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="name1 name2"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $('div').addClass('name3'); console.log($('div').prop('class')); $('div').removeClass('name2'); console.log($('div').prop('class')); $('div').removeClass(); console.log($('div').prop('class')); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 除了字符串以外，这两个函数的参数还可以是函数 这个函数可以实现，当满足某些条件的时候，再进行类名的添加或者删除 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; $('li').addClass('name'); $('li').addClass(function (index) &#123; if (index % 3 == 0) &#123; return 'three'; &#125; &#125;); $('li').removeClass(function (index) &#123; if (index % 3 == 0) &#123; return 'name'; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; toggleClass()这个方法的作用是：当一个有指定类名的元素调用这个方法时，这个方法会把它的指定类名删掉；当一个没有指定类名的元素调用这个方法时，这个方法会给这个元素添加一个指定类名 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo temp"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $('div').toggleClass('demo'); console.log($('div').prop('class')); $('div').toggleClass('demo'); console.log($('div').prop('class')); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这个方法一般用在一个元素的样式通过某种触发条件反复变换的场景下，灵活运用 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .demo &#123; width: 100px; height: 100px; background-color: green; &#125; .active &#123; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $('.demo').click(function () &#123; $(this).toggleClass('active'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; insertBefore() / before()A.insertBefore(B) : A 要插到 B 的前面 B.before(A) : B 的前面是 A 两种方法的操作结果相同，都是 A 在 B的前面，但是操作的主体不相同，即返回的对象不同 A.insertBefore(B) : A 要 插到 B 的前面，A是主动方(主动抢这个位置)，所以A是主体，方法调用的返回值是A B.before(A) : B 的前面是 A，B 是主动方(主动让出这个位置)，所以B是主体，方法调用的返回值是B 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="demo1"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;button class="btn1"&gt;insertBefore&lt;/button&gt; &lt;ul class="demo2"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;button class="btn2"&gt;before&lt;/button&gt; &lt;script type="text/javascript"&gt; $('.btn1').click(function () &#123; $(this).css('display', 'none'); $('.demo1 li:eq(3)').insertBefore($('.demo1 li:eq(0)')).css('color', 'red'); &#125;); $('.btn2').click(function () &#123; $(this).css('display', 'none'); $('.demo2 li:eq(0)').before($('.demo2 li:eq(3)')).css('color', 'red'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，两个 demo 都是把 第四个li 剪切到 第一个 li 前面，但是执行操作的主体不一样，上面的 demo 在执行完剪切操作后，将执行操作的主体颜色变红，这样可以看出来方法调用的返回值是谁（其实 jQuery 这样设置执行操作的不同主体，是为了我们更方便的使用链式调用来操作 dom） insertAfter() / after()功能用法和 insertBefore() / before() 相同，只不过是把元素剪切到后面 appendTo() / append()A.appendTo(B) : A 元素要添加到 B 元素里面 B.append(A) : B 元素 里面要添加 A 两种方法的操作结果相同，都是把子元素插入到父元素的最后一个元素后，但是操作的主体不相同，第一种方法是 A 要添加到 B 里面，A 是操作主体(A主动要这个位置)，方法的返回值是 A；第二种方法是 B 里面要添加 A，B 是操作主体(B主动让出这个位置)，方法的返回值是 B 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .wrapper1, .wrapper2 &#123; width: 200px; height: 150px; background-color: green; margin-top: 20px; &#125; .inner1, .inner2 &#123; width: 100px; height: 100px; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper1"&gt;&lt;/div&gt; &lt;div class="inner1"&gt;&lt;/div&gt; &lt;button class="btn1"&gt;appendTO&lt;/button&gt; &lt;div class="wrapper2"&gt;&lt;/div&gt; &lt;div class="inner2"&gt;&lt;/div&gt; &lt;button class="btn2"&gt;append&lt;/button&gt; &lt;script type="text/javascript"&gt; $('.btn1').click(function () &#123; $(this).css('display', 'none'); $('.inner1').appendTo($('.wrapper1')).css('backgroundColor', 'red'); &#125;); $('.btn2').click(function () &#123; $(this).css('display', 'none'); $('.wrapper2').append($('.inner2')).css('backgroundColor', 'red'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 两个方法操作结束后，都链式调用 css() 方法，将操作主体变成红色；可以看到，两次变红的主体不同，这是他们的区别所在 append() 方法的实现同原生JS中的 appendChild() 方法相同 小技巧：同上面的insertBefore() 一样，谁在前面谁是操作主体，方法的返回值是谁 prependTo() / prepend()功能用法同 appendTo() / append() 相同，只不过是把子元素插入到父元素的第一个元素之前 remove() / detach() 功能 删除元素，并返回被删除的元素 区别 都能删除元素，都能返回被删除的元素，但是这个返回的被删除的元素有所不同：用 remove() 方法删除元素返回元素不包含之前给其绑定的任何事件，而用 detach 方法删除元素返回的元素依然包含之前给元素绑定的任何事件 demo 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;script src="./js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; .wrapper &#123; width: 300px; height: 300px; background-color: gray; &#125; .inner1, .inner2 &#123; width: 100px; height: 100px; background-color: green; margin-bottom: 20px; &#125; .inner2 &#123; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="inner1"&gt;&lt;/div&gt; &lt;div class="inner2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;button&gt;恢复&lt;/button&gt; &lt;script type="text/javascript"&gt; $('.inner1').click(function () &#123; item1 = $(this).remove(); &#125;); $('.inner2').click(function () &#123; item2 = $(this).detach(); &#125;); $('button').click(function () &#123; $('.wrapper').append(item1).append(item2); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 分别点击橘色和绿色方块，将这两个元素进行删除，用 item1 和 item2 将删除的元素记录下来，点击 button后，将这两个元素用 append() 方法再添加到 wrapper 里面去；然后再分别点击橘色和绿色方块，发现只有橘色方块可以被删除，绿色方块无法被删除，原因就是使用 remove() 方法删除的元素，它的返回元素不在包含之前绑定的事件，所以后面点击就不在有事件响应了 还有一个知识点：就是点击 button 是将被删除的两个方块在添加到 wrapper 中，每点击一次就添加两个方块，可是为什么重复点击，始终只有这两个方块呢？因为每次添加的 dom 元素都相同，所以后面添加的会把前面的 dom 元素替换，所以始终是这两个元素]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点杂记]]></title>
    <url>%2F2018%2F05%2F27%2Fa36_javascript%2F</url>
    <content type="text"><![CDATA[渲染模式1. 什么是渲染渲染是浏览器排版引擎按照一定的规则绘制页面的过程 2. 为什么会有不同的渲染模式在早些时候（IE6诞生以前），各浏览器处于比较封闭的自发展过程中（基本没有兼容性可谈）。随着web技术的发展，兼容性问题显得越来越迫切。为了解决兼容性问题，各个浏览器厂商发布了按照统一标准(W3C)工作的浏览器，比如IE6就是其中之一。但是考虑到浏览器向下兼容的问题（以前建设的网站并不支持标准模式），所以浏览器在加入标准模式的同时也保留了混杂模式。 3. 有哪些渲染模式 标准模式 按照统一的标准渲染页面 混杂模式 排版会模拟Navigator4 与 IE5 的非标准行为，兼容在新版本浏览器中已经被淘汰的一些内容 其实标准模式又可以严格的分为 近标准模式、标准模式、超级标准模式，在近标准模式下，浏览器在保证尽量遵照标准的前提下，部分地兼容一些混杂模式的代码 4. 浏览器如何决定用哪个模式 DOCTYPE “DOCTYPE”是 “Document Type Declaration” 的缩写，简称 “文档类型说明”。通常情况下，DOCTYPE位于一个HTML文档最前的位置，浏览器在解析HTML文档正文之前，可以确定其文档类型，以选择需要的渲染模式。（不同的渲染模式会影响浏览器对CSS代码甚至JavaScript脚本的解析） 声明标准渲染模式 在HTML文件的最顶端使用 &lt;!DOCTYPE html&gt; 是HTML5所推荐的，所有浏览器都支持的启动标准模式的方法，在HTML5中DOCTYPE唯一的作用就是启用标准模式。 &lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “http://www.w3.org/TR/html4/strict.dtd&quot;&gt; &lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 除了这三种进入标准模式的声明方法，其他使用DOCTYPE声明的可能是近标准模式也可能是混杂模式，没有用DOCTYPE声明或者DOCTYPE声明写错的以及DOCTYPE声明不在HTML文档第一行的都会进入混杂模式 5. 如何判断浏览器当前处于什么模式123&lt;script type="text/javascript"&gt; console.log(document.compatMode);&lt;/script&gt; 返回值： CSS1Compat 标准模式 BackCompat 混杂模式 6. 标准模式和混杂模式下的区别标准模式和混杂模式有很多不同，这里介绍一些主要的常见的不同（这些不同也是在部分浏览器中才会体现出来，比如IE6，所以下面的测试代码均在IE6浏览器中进行测试） 盒模型的计算方式 标准模式 width、height作为content内容区的固定值，padding、border向外扩展构成盒模型 怪异模式 width、height作为盒模型区域的固定值，padding、border向内压缩content内容区构成盒模型 1&lt;div style="width:100px;height:100px;padding:10px;border:5px solid black;background-color: green;"&gt;&lt;/div&gt; 但是这种盒模型的构成方式不是始终是这样，当padding和border向内将content压缩到0，再要继续往小压缩的话，content不会变成负值，而是整个盒模型区域开始向外扩展，最终的大小取决于border 和 padding的值 行级元素能否设置宽高 标准模式 不能 怪异模式 可以 等待补充 label 定义 \ 标签为 input 元素定义标注（标记） label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上 for属性 for属性可以把label绑定到另外一个元素，需要把for属性的值设置为相关元素的id的属性值 12&lt;label for="demo"&gt;username:&lt;/label&gt;&lt;input id="demo" type="text"&gt; 效果： 如果没有label的绑定，点击username时，鼠标不会聚焦到文本框内；如果按照上述代码将label绑定到input上，点击username，鼠标会聚焦到文本框内 js中label的for属性用 htmlFor 表示 123456&lt;label&gt;username:&lt;/label&gt;&lt;input id="demo" type="text"&gt;&lt;script type="text/javascript"&gt; var label = document.getElementsByTagName('label')[0]; label.htmlFor = 'demo';&lt;/script&gt; 关于label的绑定机制的探究 可能与label的事件冒泡有关，后续探究 1234567891011121314&lt;label for="demo"&gt;username:&lt;/label&gt;&lt;input id="demo" type="text"&gt;&lt;script type="text/javascript"&gt; var label = document.getElementsByTagName('label')[0], input = document.getElementsByTagName('input')[0]; input.onclick = function() &#123; console.log('input'); &#125; label.onclick = function(e) &#123; console.log('label'); console.log(e); // return false; &#125;&lt;/script&gt; 属性映射HTML属性映射到Element属性 对于HTML标签中，系统有定义的属性，可以在js中通过 ‘.’ 的方式取出来，也可以通过这种方式给他们赋值；而对于系统中没有定义的自定义的属性，需要通过setAttribute / getAttribute 方法设置和访问 123456789&lt;input type="text"&gt;&lt;script type="text/javascript"&gt; var oId = document.getElementsByTagName('input')[0]; oId.id = 'demo'; // 生效 oId.selfid = 'demo1'; // 不生效 oId.setAttribute('tmpid', 'demo2'); // 生效 console.log(oId.tmpid); // 不生效 console.log(oId.getAttribute('tmpid')); // 生效&lt;/script&gt; 图片加载模式普通加载模式浏览器构建DOM树，在解析完html结构后，要对相应的资源进行下载，并将下载好的资源展示在页面中，这样会带来一个问题：页面是将图片当前已经下载好的部分展示出来，如果网速条件不是很好的话，对于一张图片，会断续的下载完成图片的一部分，展示在页面中的效果就是图片一部分一部分的展示出来，而不是直接完整的展示出来 预加载模式那既然我们不想让图片加载一部分展示一部分，而是想让它全部加载完成后，再整体展示出来，这样对于用户的视觉效果体验比较友好，所以我们给图片绑定load事件，当图片加载完成后，再展示在页面中 12345678&lt;script type="text/javascript"&gt; var oImg = new Image(); oImg.onload = function() &#123; document.body.appendChild(oImg); &#125; oImg.src = 'http://n.sinaimg.cn/ent/transform/20170818/IAPS-fykcppx9377606.jpg'; oImg.style.width = '300px';&lt;/script&gt; Image 图片对象： 属性：border complete height hspace lowsrc name src vspace width 事件：onabort onerror onkeydown onkeypress onkeyup onload 注意：src 属性一定要写到 onload 的后面，否则程序在 IE 中会出错。 懒加载模式当一个页面中有很多图片时，不在浏览器当前可视区的图片，用户需要向下滚动页面才能看到，当然用户也可以不去看这些图片，只看首屏的图片，所以，对于这些用户当前不需要的图片，可以先不加载，等用户查看的需求或者触发了一定的条件，才让这些图片加载 12345678910&lt;button&gt;查看图片&lt;/button&gt;&lt;script type="text/javascript"&gt; var oImg = new Image(), oButton = document.getElementsByTagName('button')[0]; oButton.onclick = function() &#123; oImg.src = 'http://n.sinaimg.cn/ent/transform/20170818/IAPS-fykcppx9377606.jpg'; oImg.style.width = '300px'; document.body.appendChild(oImg); &#125;&lt;/script&gt; 可以将懒加载和预加载结合起来展示图片 随机数Math.random()返回 [0, 1) 区间内的随机数 [0, max]返回0到任意正整数之间的随机整数 Math.floor(Math.random() * (max + 1)) 1234// 返回[0,40]区间内的任意整数Math.floor(Math.random() * 41)// 或者// parseInt(Math.random() * 41) [min, max]Math.floor(Math.random() * (max - min + 1) + min) 返回两个任意正整数之间的随机整数 1234// 返回[11, 22]区间内的任意整数Math.floor(Math.random() * 12 + 11);// 或者// parseInt(Math.random() * 12 + 11); 文档碎片有这样一个需求，页面中有一个空的ul，现在要向这个空的ul中插入10000个li，li中的内容表示它是第几个li 首先我们可能这样实现 123456789&lt;ul&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var oUl = document.getElementsByTagName('ul')[0]; for (var i = 0; i &lt; 10000; i++) &#123; var oLi = document.createElement('li'); oLi.innerHTML = i; oUl.appendChild(oLi); &#125;&lt;/script&gt; 我们知道，利用js修改DOM结构，要重新构建渲染树，页面要进行重排，这样很影响页面的性能，上面这段代码，利用for循环，对DOM结构进行了10000次的插入，页面要重排10000次左右，非常的影响页面的性能，那既然像这样每次都对DOM结构进行修改很影响性能，那能不能减少修改的次数呢。 构建一个新的元素 1234567891011&lt;ul&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var oUl = document.getElementsByTagName('ul')[0], oDiv = document.createElement('div'); for (var i = 0; i &lt; 10000; i++) &#123; var oLi = document.createElement('li'); oLi.innerHTML = i; oDiv.appendChild(oLi); &#125; oUl.appendChild(oDiv);&lt;/script&gt; 这上面这段代码中，我们构建了一个空的div，这个div是新构建的，不在DOM结构上，所以我们将10000个li先插到这个div中，然后将这个div插入到ul中，只进行了一次对DOM结构的修改，提高了页面的性能；但是现在有个问题就是：这个ul下的div并不是我想要的，它影响了我们原本的结构 文档碎片结点 1234567891011&lt;ul&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var oUl = document.getElementsByTagName('ul')[0], oFrag = document.createDocumentFragment(); for (var i = 0; i &lt; 10000; i++)&#123; var oLi = document.createElement('li'); oLi.innerHTML = i; oFrag.appendChild(oLi); &#125; oUl.appendChild(oFrag);&lt;/script&gt; createdocumentfragment()方法创建了一虚拟的节点对象，节点对象包含所有属性和方法。 当你想提取文档的一部分，改变，增加，或删除某些内容及插入到文档末尾可以使用createDocumentFragment() 方法。 你也可以使用文档的文档对象来执行这些变化，但要防止文件结构被破坏，createDocumentFragment() 方法可以更安全改变文档的结构及节点 在这段代码中，将10000个li插入到文档碎片结点中，再把文档碎片结点插入到DOM树中，这样既减少了频繁的DOM操作，又不影响页面的结构 巧妙利用字符串 12345678910&lt;ul&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var oUl = document.getElementsByTagName('ul')[0], str = ''; for (var i = 0; i &lt; 10000; i++) &#123; str += '&lt;li&gt;' + i + '&lt;/li&gt;'; &#125; oUl.innerHTML = str; &lt;/script&gt; emmm，自己体会吧… 使用classList操作className dom.classList.remove(name) 删除该dom元素类名称中的name部分 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;temp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="name1 name2 name3"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var oDiv = document.getElementsByTagName('div')[0]; oDiv.classList.remove('name1'); console.log(oDiv.className); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打印结果是：”name2 name3” dom.classList.add(name) 为该dom元素再原有类名的基础上再添加一个name名称 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;temp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="name1 name2 name3"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var oDiv = document.getElementsByTagName('div')[0]; oDiv.classList.add('name4'); console.log(oDiv.className); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打印结果是：”name1 name2 name3 name4” 关于字符串的一些方法indexOf() 功能 返回某个指定的字符串值在字符串中首次出现的位置 语法 stringObject.indexOf(searchvalue, fromindex) searchvalue: 必须，规定需要检索的字符串值 fromindex: 可选整数参数，规定在字符串开始检索的位置，它的合法取值是0到stringObject.length - 1；如果省略改参数，则将从字符串首字符开始检索 返回值 如果要查找的子串存在，则返回该子串在字符串中第一次出现的位置；如果不存在，则返回 -1 样例 12345var str = 'abcabcabc', subStr1 = 'bc', subStr2 = 'de';console.log(str.indexOf(subStr1)); // 1console.log(str.indexOf(subStr2)); // -1]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery简介]]></title>
    <url>%2F2018%2F05%2F26%2Fb01_jQuery%2F</url>
    <content type="text"><![CDATA[是什么jQuery 是一个非常优秀的 js 库，其中封装了非常多的方法，方便我们在开发中进行使用 版本jQuery 目前分为 1.x、2.x、3.x 三个发布版本，2.0 版本以后不再支持 IE9 以下的浏览器；针对于每个版本的jQuery 文件来说，有压缩和未压缩两种形式：压缩后的 jQuery 删除了文件中的所有空格、空行，函数名都用简单的变量代替；未压缩 jQuery 文件则是正常的一个一个方法；在我们学习使用时适合使用未压缩的版本，查看某一个方法的内部原理等，如果要是项目需要上线发布，则选择更轻量的压缩版本比较好 兼容性jQuery 中封装的方法解决了不同浏览器之间的兼容性问题，提高了开发效率 zepto也是一个 js 库，有 jQuery 演变而来，为移动端提供更好更轻量的服务]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单原生轮播图]]></title>
    <url>%2F2018%2F05%2F25%2Fa38_javascript%2F</url>
    <content type="text"><![CDATA[实现功能 默认情况先自动轮播 点击左右切换按钮轮播 连续点击左右切换按钮可连续轮播 点击索引轮播 鼠标悬停时停止轮播（未实现） 效果 框架123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;temp&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; padding: 0px; margin: 0px; list-style: none; &#125; .wrapper &#123; position: relative; width: 450px; height: 300px; margin: 100px auto 0px; overflow: hidden; &#125; .wrapper .slider-page &#123; position: absolute; left: 0px; top: 0px; width: 2250px; height: 300px; &#125; .wrapper .slider-page li &#123; width:450px; height: 300px; float: left; &#125; .wrapper .slider-page li img &#123; width: 100%; height: 100%; &#125; .wrapper .btn &#123; position: absolute; top: 50%; margin-top: -15px; width: 20px; height: 30px; background-color: #ccc; opacity: 0.3; text-align: center; line-height: 30px; font-size: 20px; font-weight: bold; cursor: pointer; &#125; .wrapper .btn:hover &#123; opacity: 0.8; &#125; .wrapper .right &#123; right: 0px; &#125; .wrapper .slider-index &#123; position: absolute; bottom: 10px; left: 50%; margin-left: -50px; width: 100px; height: 15px; text-align: center; line-height: 16px; cursor: pointer; &#125; .wrapper .slider-index span &#123; display: inline-block; width: 10px; height: 10px; background-color: #ccc; border-radius: 50%; margin-left: 10px; &#125; .wrapper .slider-index .active &#123; background-color: black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;ul class="slider-page"&gt; &lt;li&gt;&lt;img src="http://n.sinaimg.cn/ent/transform/20170818/IAPS-fykcppx9377606.jpg" alt="迪丽热巴"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="https://p.nanrenwo.net/uploads/allimg/170521/8467-1F5211A057.jpg" alt="迪丽热巴"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="http://img1.utuku.china.com/640x0/news/20170523/46c6bce9-79d4-4de3-ad79-5b413ffb4def.jpg" alt="古力娜扎"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="https://upload-images.jianshu.io/upload_images/4657108-f8f34a2df8473c1d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/423" alt="古力娜扎"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="http://n.sinaimg.cn/ent/transform/20170818/IAPS-fykcppx9377606.jpg" alt="迪丽热巴"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="btn left"&gt;&amp;lt;&lt;/div&gt; &lt;div class="btn right"&gt;&amp;gt;&lt;/div&gt; &lt;div class="slider-index"&gt; &lt;span class="active"&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var oSliderPage = document.getElementsByClassName('slider-page')[0], moveWidth = oSliderPage.children[0].offsetWidth, imgCounts = oSliderPage.children.length - 1, index = 0, disArray = [], timer = null; var btnLeft = document.getElementsByClassName('left')[0], btnRight = document.getElementsByClassName('right')[0], oSliderIndex = document.getElementsByClassName('slider-index')[0], oSpan = oSliderIndex.getElementsByTagName('span'); for (var i = 0; i &lt;= imgCounts; i++) &#123; disArray.push(-i * moveWidth); &#125; btnLeft.onclick = function () &#123; slid(oSliderPage, 'right'); &#125; btnRight.onclick = function () &#123; slid(oSliderPage, 'left'); &#125; for (var i = 0; i &lt; imgCounts; i++) &#123; (function (myIndex) &#123; oSpan[myIndex].onclick = function () &#123; clearTimeout(timer); index = myIndex; changeIndex(index); move(oSliderPage, &#123;left: disArray[index]&#125;, function () &#123; auto(oSliderPage); &#125;); &#125; &#125;)(i); &#125; auto(oSliderPage); function auto(ele) &#123; timer = setTimeout(function () &#123; slid(ele); &#125;, 1500); &#125; function slid(ele, direc) &#123; clearTimeout(timer); if (!direc || direc == 'left') &#123; if (index == imgCounts) &#123; index = 0; ele.style.left = disArray[index] + 'px'; &#125; index++; if (index == imgCounts) &#123; changeIndex(0); &#125; else &#123; changeIndex(index); &#125; move(ele, &#123;left: disArray[index]&#125;, function () &#123; auto(ele); &#125;); &#125; else &#123; if (index == 0 || index == imgCounts) &#123; index = imgCounts; ele.style.left = disArray[index] + 'px'; &#125; index--; changeIndex(index); move(ele, &#123;left: disArray[index]&#125;, function () &#123; auto(ele); &#125;); &#125; &#125; function changeIndex(activeIndex) &#123; for (var i = 0; i &lt; imgCounts; i++) &#123; oSpan[i].className = ''; &#125; oSpan[activeIndex].className = 'active'; &#125; &lt;/script&gt; &lt;script src="../library/sport.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 测试时注意引入的 ‘sport.js’ 的路径 思路 自动轮播 按钮轮播 索引变换 索引轮播 坑 当多种轮播方式在同一时间起作用时，会出现计时器的争抢现象 注意index的变化和move执行的先后顺序 不足还有一个功能没有实现：当鼠标移上某一张图片时，轮播图应该停止轮播，但是这个功能不能简单地用mouseenter、mouseleave事件实现，如加入以下代码 123456oSliderPage.onmouseenter = function () &#123; clearTimeout(timer);&#125;oSliderPage.onmouseleave = function () &#123; auto(this);&#125; 这样写的问题是：当一张图已经轮播到指定的位置时，上面的代码有用；但是当一张图还在轮播的过程中，这时把鼠标放上去不会停止轮播，因为当这张图片开始轮播的时候，这次轮播的计时器就已经被清除了，所以把鼠标放上去执行clearTimeout(timer)的时候，并没有计时器可以被清除，所以没有效果，所以尝试做出以下改进：当一张图轮播结束后，这时再判断是否停止轮播]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运动]]></title>
    <url>%2F2018%2F05%2F25%2Fa37_javascript%2F</url>
    <content type="text"><![CDATA[匀速运动点击开始匀速运动，再次点击停止运动1234567891011121314151617181920212223242526272829303132333435// head&lt;style type="text/css"&gt; .demo &#123; position: absolute; left: 0px; top: 0px; width: 100px; height: 100px; background-color: green; &#125;&lt;/style&gt; // body&lt;div class="demo"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divDemo = document.getElementsByClassName('demo')[0], key = true, timer = 0; function constantMove(obj) &#123; var speed = 7; timer = setInterval(function() &#123; obj.style.left = obj.offsetLeft + speed + 'px'; &#125;, 100); &#125; divDemo.onclick = function() &#123; if (key) &#123; constantMove(this); key = false; &#125; else &#123; clearInterval(timer); key = true; &#125; &#125;; &lt;/script&gt; 到达指定位置时停止运动 要求无论是左向右运动还是右向左运动都可以到指定位置停止 两组测试样例： 1：下面代码原样测试 2：将下面代码中的 demo样式中的left改成right，将speed改成负数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style type="text/css"&gt; .demo &#123; position: absolute; left: 0px; top: 0px; width: 100px; height: 100px; background-color: green; &#125; .stopLoc &#123; position: fixed; left: 600px; top: 0px; width: 2px; height: 100px; background-color: #000; &#125; &lt;/style&gt;&lt;div class="demo"&gt;&lt;/div&gt;&lt;div class="stopLoc"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divDemo = document.getElementsByClassName('demo')[0], divStopLoc = document.getElementsByClassName('stopLoc')[0], timer = 0, key = true, stopLoc = divStopLoc.offsetLeft; function constantMove(obj) &#123; var speed = 7; timer = setInterval(function () &#123; var objLoc = obj.offsetLeft; if (Math.abs(stopLoc - objLoc) &gt;= Math.abs(speed)) &#123; obj.style.left = objLoc + speed + 'px'; &#125; else &#123; obj.style.left = stopLoc + 'px'; clearInterval(timer); key = true; &#125; &#125;, 50); &#125; divDemo.onclick = function() &#123; if (key &amp;&amp; (this.offsetLeft != stopLoc)) &#123; constantMove(this); key = false; &#125; else &#123; clearInterval(timer); key = true; &#125; &#125;&lt;/script&gt; 从开始到结束的整个过程来看，物体不是一直都在做匀速运动 方块是以每个单位时间 7 的速度运动的，也就是说每个单位时间方块的 left 的值要加上7，现在想让方块在 600 的位置停止，600 不能被 7 整除，所以方块根本不会经过这个地方，所以不会在这里停止 在这段代码中方块确实是在指定位置停止的，实现方法是当方块即将要到达停止位置时（不走不到，再走一步就超过），让方块的位置直接等于指定位置，这样，如果最后剩余的距离不等于方块的speed的话，方块就相当于是变了一个较小的速度，单独看，这两个过程都是匀速运动，但是合起来看整个过程，方块做了一次变速 代码中的key是为了控制方块重复点击不加速 缓冲运动位置变化12345678910111213141516171819202122232425262728293031323334353637383940414243444546// head&lt;style type="text/css"&gt; .demo &#123; position: absolute; left: 10px; top: 0px; width: 100px; height: 100px; background-color: green; &#125; .stopLoc &#123; position: fixed; left: 600px; top: 0px; width: 2px; height: 100px; background-color: #000; &#125; &lt;/style&gt; // body&lt;div class="demo"&gt;&lt;/div&gt;&lt;div class="stopLoc"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var oDivDemo = document.getElementsByClassName('demo')[0], key = true, stopLoc = 600; function bufferMove(elem) &#123; var timer = setInterval(function () &#123; var elemLoc = elem.offsetLeft; if (elemLoc === stopLoc) &#123; clearInterval(timer); &#125; else &#123; var speed = (stopLoc - elemLoc) / 7; speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); elem.style.left = elemLoc + speed + 'px'; &#125; &#125;, 50); &#125; oDivDemo.onclick = function () &#123; if (key) &#123; bufferMove(this); key = false; &#125; &#125;&lt;/script&gt; 举一个实际的例子，实现下图的效果： 当鼠标移上黑色区域，红色区域缓冲移出；鼠标移开时，红色区域缓冲移入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;style type="text/css"&gt; .wrapper &#123; width: 300px; height: 100px; background-color: red; position: absolute; left: -300px; top: 100px; &#125; .wrapper::after &#123; content: ''; display: block; width: 50px; height: 100px; background-color: black; position: absolute; right: -50px; &#125;&lt;/style&gt;&lt;div class="wrapper"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var oDivWrapper = document.getElementsByClassName('wrapper')[0], key = true, timer = null; function bufferMove(elem, interval, base, stopLoc) &#123; clearInterval(timer); timer = setInterval(function () &#123; var elemLoc = elem.offsetLeft; if (elemLoc === stopLoc) &#123; clearInterval(timer); &#125; else &#123; var speed = (stopLoc - elemLoc) / base; speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); elem.style.left = elemLoc + speed + 'px'; &#125; &#125;, interval); &#125; oDivWrapper.onmouseenter = function () &#123; bufferMove(this, 30, 7, 0); &#125; oDivWrapper.onmouseleave = function () &#123; bufferMove(this, 10, 7, -300); &#125;&lt;/script&gt; 透明度变化1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style type="text/css"&gt; .demo &#123; width: 100px; height: 100px; background-color: green; opacity: 0.1; &#125;&lt;/style&gt;&lt;div class="demo"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var oDivDemo = document.getElementsByClassName('demo')[0], timer = null, key = true; function getStyle(elem, prop) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(elem, null)[prop]; &#125; else &#123; return elem.currentStyle[prop]; &#125; &#125; function opacityMove(elem, target) &#123; clearInterval(timer); timer = setInterval(function () &#123; var curValue = parseFloat(getStyle(elem, 'opacity')); if (curValue == target) &#123; clearInterval(timer); console.log('stop'); &#125; else &#123; var speed = ((target - curValue) * 100) / 7; speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); elem.style.opacity = curValue + speed / 100; &#125; &#125;, 150); &#125; oDivDemo.onclick = function () &#123; if (key) &#123; opacityMove(this, 0.9); key = false; &#125; &#125;&lt;/script&gt; 多物体运动多物体单值无关联运动一 主要解决timer问题 预期效果： 不符合预期的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;style type="text/css"&gt; .demo1, .demo2, .demo3, .demo4 &#123; width: 100px; height: 100px; border: 1px solid black; margin-bottom: 20px; &#125; .demo1 &#123; background-color: red; &#125; .demo2 &#123; background-color: green; &#125; .demo3 &#123; background-color: orange; &#125; .demo4 &#123; background-color: yellow; &#125;&lt;/style&gt;&lt;div class="demo1"&gt;&lt;/div&gt;&lt;div class="demo2"&gt;&lt;/div&gt;&lt;div class="demo3"&gt;&lt;/div&gt;&lt;div class="demo4"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var oDiv = document.getElementsByTagName('div'), timer = null; function getStyle(elem, prop) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(elem, null)[prop]; &#125; else &#123; return elem.currentStyle[prop]; &#125; &#125; function widthMove(elem, target) &#123; clearInterval(timer); timer = setInterval(function () &#123; var curValue = parseInt(getStyle(elem, 'width')); if (curValue === target) &#123; clearInterval(timer); console.log('stop'); &#125; else &#123; var speed = (target - curValue) / 7; speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); elem.style.width = curValue + speed + 'px'; &#125; &#125;, 30); &#125; for (var i = 0; i &lt; oDiv.length; i++) &#123; oDiv[i].onmouseenter = function () &#123; widthMove(this, 500); &#125;; oDiv[i].onmouseleave = function () &#123; widthMove(this, 100); &#125;; &#125;&lt;/script&gt; 不符合预期的效果： 不符合预期的现象： 鼠标移上时，盒子的宽度能够像预期一样开始缓冲变宽，但是当鼠标移开到其他盒子上时，盒子的宽度不能正常的回复到正常值 不符合预期的原因： 鼠标移上盒子，开始执行这个盒子的widthMove函数，这个盒子有个计时器标志timer，当鼠标在这个timer还没有清除时，移到了其他盒子上，这时timer成为了另一个盒子的timer，导致上一个timer无法被清除 解决方法： 导致这个问题的原因就是每一个盒子的计时标志timer不唯一，无法正常被清除，那么解决问题的方法，就是让每一个盒子都有自己专属的timer，因为这里每一个盒子都是一个对象，所以把timer设置为他们各自的属性即可 1// 将widthMove() 函数体中的 timer 都改成 elem.timer 即可 多物体单值无关联运动二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;style type="text/css"&gt; .demo1, .demo2, .demo3, .demo4 &#123; width: 100px; height: 100px; border: 1px solid black; margin-bottom: 20px; &#125; .demo1 &#123; background-color: red; &#125; .demo2 &#123; background-color: green; &#125; .demo3 &#123; background-color: orange; &#125; .demo4 &#123; background-color: yellow; opacity: 1; &#125;&lt;/style&gt;&lt;div class="demo1"&gt;&lt;/div&gt;&lt;div class="demo2"&gt;&lt;/div&gt;&lt;div class="demo3"&gt;&lt;/div&gt;&lt;div class="demo4"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var oDiv = document.getElementsByTagName('div'); for (var i = 0; i &lt; oDiv.length; i++) &#123; oDiv[i].key = true; &#125; oDiv[0].onclick = function () &#123; if (this.key) &#123; move(this, 'width', 400); this.key = false; &#125; &#125; oDiv[1].onclick = function () &#123; if (this.key) &#123; move(this, 'height', 200); this.key = false; &#125; &#125; oDiv[2].onclick = function () &#123; if (this.key) &#123; move(this, 'borderWidth', 10); this.key = false; &#125; &#125; oDiv[3].onclick = function () &#123; if (this.key) &#123; move(this, 'opacity', 0.1); this.key = false; &#125; &#125; function getStyle(elem, prop) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(elem, null)[prop]; &#125; else &#123; return elem.currentStyle[prop]; &#125; &#125; function move(elem, prop, target) &#123; clearInterval(elem.timer); elem.timer = setInterval(function () &#123; var curValue = (prop == 'opacity') ? parseFloat(getStyle(elem, prop)) : parseInt(getStyle(elem, prop)); if (curValue == target) &#123; clearInterval(elem.timer); console.log(prop); &#125; else &#123; var speed; if (prop == 'opacity') &#123; speed = ((target - curValue) * 100) / 7; speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); elem.style.opacity = curValue + speed / 100; &#125; else &#123; speed = (target - curValue) / 7; speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); elem.style[prop] = curValue + speed + 'px'; &#125; &#125; &#125;, 50); &#125;&lt;/script&gt; 单物体多值无关联运动 一个物体的多个值一起变化（无序） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;style type="text/css"&gt; .demo1, .demo2 &#123; width: 100px; height: 100px; position: absolute; left: 0px; opacity: 0.2; &#125; .demo1 &#123; top: 200px; background-color: red; &#125; .demo2 &#123; top: 400px; background-color: green; &#125;&lt;/style&gt;&lt;div class="demo1"&gt;&lt;/div&gt;&lt;div class="demo2"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var oDiv = document.getElementsByTagName('div'); for (var i = 0; i &lt; oDiv.length; i++) &#123; oDiv[i].key = true; &#125; var targetMove1 = &#123; left: 500, width: 300, height: 300, opacity: 1 &#125;; var targetMove2 = &#123; width: 500, height: 50, opacity: 0.5, left: 400 &#125;; function getStyle(elem, prop) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(elem, null)[prop]; &#125; else &#123; return elem.currentStyle[prop]; &#125; &#125; function move(elem, targetObj) &#123; clearInterval(elem.timer); elem.timer = setInterval(function () &#123; var stop = true; for (var prop in targetObj) &#123; var curValue = (prop == 'opacity') ? parseFloat(getStyle(elem, prop)) : parseInt(getStyle(elem, prop)), speed = (prop == 'opacity') ? ((targetObj[prop] - curValue) * 100 / 7) : ((targetObj[prop] - curValue) / 7); speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); if (prop == 'opacity') &#123; elem.style[prop] = curValue + speed / 100; &#125; else &#123; elem.style[prop] = curValue + speed + 'px'; &#125; if (curValue != targetObj[prop]) &#123; stop = false; &#125; &#125; if (stop) &#123; clearInterval(elem.timer); &#125; &#125;, 50); &#125; oDiv[0].onclick = function () &#123; if (this.key) &#123; move(this, targetMove1); this.key = false; &#125; &#125;&lt;/script&gt; 一个物体的多个值连续变化（有序） 这个代码bug，先放这，想清楚在改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;style type="text/css"&gt; .demo1, .demo2 &#123; width: 100px; height: 100px; position: absolute; left: 0px; opacity: 0.2; &#125; .demo1 &#123; top: 200px; background-color: red; &#125; .demo2 &#123; top: 400px; background-color: green; &#125;&lt;/style&gt;&lt;div class="demo1"&gt;&lt;/div&gt;&lt;div class="demo2"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var oDiv = document.getElementsByTagName('div'); for (var i = 0; i &lt; oDiv.length; i++) &#123; oDiv[i].key = true; &#125; var targetMove1 = &#123; left: 500, width: 300, height: 300, opacity: 1 &#125;; var targetMove2 = &#123; width: 500, height: 50, opacity: 0.5, left: 400 &#125;; function getStyle(elem, prop) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(elem, null)[prop]; &#125; else &#123; return elem.currentStyle[prop]; &#125; &#125; function move(elem, targetObj) &#123; clearInterval(elem.timer); for (var prop in targetObj) &#123; console.log(prop); var curValue = 0; while (curValue != targetObj[prop]) &#123; console.log(111); elem.timer = setInterval(function () &#123; curValue = (prop == 'opacity') ? parseFloat(getStyle(elem, prop)) : parseInt(getStyle(elem, prop)); var speed = (prop == 'opacity') ? ((targetObj[prop] - curValue) * 100 / 7) : ((targetObj[prop] - curValue) / 7); speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); if (prop == 'opacity') &#123; elem.style[prop] = curValue + speed / 100; &#125; else &#123; elem.style[prop] = curValue + speed + 'px'; &#125; &#125;, 40); &#125; clearInterval(elem.timer); &#125; 多物体多值链式运动 效果图 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;style type="text/css"&gt; .demo1, .demo2, .demo3, .demo4 &#123; width: 100px; height: 100px; position: absolute; opacity: 0.2; &#125; .demo1 &#123; left: 0px; top: 200px; background-color: red; &#125; .demo2 &#123; left: 0px; top: 400px; background-color: green; opacity: 1; &#125; .demo3 &#123; right: 0px; top: 200px; background-color: orange; &#125; .demo4 &#123; top: 400px; right: 0px; background-color: yellow; &#125;&lt;/style&gt;&lt;div class="demo1"&gt;&lt;/div&gt;&lt;div class="demo2"&gt;&lt;/div&gt;&lt;div class="demo3"&gt;&lt;/div&gt;&lt;div class="demo4"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var oDiv = document.getElementsByTagName('div'); for (var i = 0; i &lt; oDiv.length; i++) &#123; oDiv[i].key = true; &#125; var targetMove1 = &#123; left: 500, width: 300, height: 300, opacity: 1 &#125;; var targetMove2 = &#123; width: 500, height: 50, opacity: 0.5, left: 400 &#125;; var targetMove3 = &#123; left: 450, width: 50, height: 50, opacity: 1 &#125;; var targetMove4 = &#123; left: 800, top: 200, width: 50, height:50, opacity: 1 &#125; function getStyle(elem, prop) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(elem, null)[prop]; &#125; else &#123; return elem.currentStyle[prop]; &#125; &#125; function move(elem, targetObj, callback) &#123; elem.timer = setInterval(function () &#123; var stop = true; for (var prop in targetObj) &#123; var curValue = (prop == 'opacity') ? parseFloat(getStyle(elem, prop)) : parseInt(getStyle(elem, prop)), speed = (prop == 'opacity') ? ((targetObj[prop] - curValue) * 100 / 7) : ((targetObj[prop] - curValue) / 7); speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); if (prop == 'opacity') &#123; elem.style[prop] = curValue + speed / 100; &#125; else &#123; elem.style[prop] = curValue + speed + 'px'; &#125; if (curValue != targetObj[prop]) &#123; stop = false; &#125; &#125; if (stop) &#123; clearInterval(elem.timer); typeof(callback) == 'function' ? callback() : ''; &#125; &#125;, 50); &#125; oDiv[0].onclick = function () &#123; if (this.key) &#123; move(this, targetMove1, function ()&#123; move(oDiv[1], targetMove2, function () &#123; move(oDiv[2], targetMove3, function () &#123; move(oDiv[3], targetMove4); &#125;); &#125;); &#125;); this.key = false; &#125; &#125;&lt;/script&gt; 加速运动单向匀加速运动初速的为0， 给定一个加速度 1234567891011121314151617181920212223242526272829303132333435363738394041424344// head&lt;style type="text/css"&gt; .demo &#123; position: absolute; left: 800px; width: 50px; height: 50px; background-color: orange; border-radius: 50%; line-height: 50px; text-align: center; cursor: pointer; &#125;&lt;/style&gt; // body&lt;div class="demo"&gt;click&lt;/div&gt;&lt;script type='text/javascript'&gt; var oDivDemo = document.getElementsByClassName('demo')[0], key = true; function move(elem, tarLoc) &#123; var speed = 0, a = -3, curValue; var timer = setInterval(function() &#123; curValue = elem.offsetLeft; if (Math.abs(tarLoc - curValue) &lt; Math.abs(speed)) &#123; elem.style.left = tarLoc + 'px'; clearInterval(timer); &#125; else &#123; elem.style.left = curValue + speed + 'px'; speed += a; &#125; &#125;, 25); &#125; oDivDemo.onclick = function () &#123; if (key) &#123; move(this, 8); key = false; &#125; &#125;&lt;/script&gt; 匀减速运动给定一个非0初速度，给定一个加速度 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style type="text/css"&gt; .demo &#123; position: absolute; left: px; top: 0px; width: 50px; height: 50px; background-color: orange; border-radius: 50%; line-height: 50px; text-align: center; cursor: pointer; &#125;&lt;/style&gt;&lt;div class="demo"&gt;click&lt;/div&gt;&lt;script type='text/javascript'&gt; var oDivDemo = document.getElementsByClassName('demo')[0], key = true; function move(elem, tarLoc) &#123; var speed = 100, a = -4, curValue; var timer = setInterval(function() &#123; curValue = elem.offsetLeft; if (Math.abs(tarLoc - curValue) &lt; Math.abs(speed)) &#123; elem.style.left = tarLoc + 'px'; clearInterval(timer); &#125; else &#123; elem.style.left = curValue + speed + 'px'; speed += a; &#125; &#125;, 25); &#125; oDivDemo.onclick = function () &#123; if (key) &#123; move(this, 800); key = false; &#125; &#125;&lt;/script&gt; 弹性运动没有摩擦力 首先实现这样一个效果 123456789101112131415161718192021222324252627282930313233343536// head&lt;style type="text/css"&gt; .demo &#123; position: absolute; left: 500px; top: 0px; width: 50px; height: 50px; background-color: orange; border-radius: 50%; line-height: 50px; text-align: center; cursor: pointer; &#125;&lt;/style&gt; // body&lt;div class="demo"&gt;click&lt;/div&gt;&lt;script type="text/javascript"&gt; var oDivDemo = document.getElementsByClassName('demo')[0]; function move(ele) &#123; clearInterval(ele.timer); var curValue, a = 3, speed = 0; ele.timer = setInterval(function () &#123; curValue = ele.offsetLeft; speed += curValue &lt; 600 ? a : -a; ele.style.left = curValue + speed + 'px'; &#125;, 30); &#125; oDivDemo.onclick = function () &#123; move(this); &#125;&lt;/script&gt; 坑 如果将计时器中的 speed += curValue &lt; 600 ? a : -a; ele.style.left = curValue + speed + ‘px’; 这两条语句的位置换一下顺序的话，效果如下图（对比图） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// head&lt;style type="text/css"&gt; .demo &#123; position: absolute; left: 500px; top: 0px; width: 50px; height: 50px; background-color: orange; border-radius: 50%; line-height: 50px; text-align: center; cursor: pointer; &#125; .demo1 &#123; position: absolute; left: 500px; top: 100px; width: 50px; height: 50px; background-color: orange; border-radius: 50%; line-height: 50px; text-align: center; cursor: pointer; &#125;&lt;/style&gt; // body&lt;div class="demo"&gt;click&lt;/div&gt;&lt;div class="demo1"&gt;&lt;/div&gt;&lt;script type='text/javascript'&gt; var oDiv = document.getElementsByTagName('div'); function move(ele) &#123; clearInterval(ele.timer); var speed = 5, a = 5, curValue; ele.timer = setInterval(function () &#123; curValue = ele.offsetLeft; ele.style.left = curValue + speed + 'px'; speed += curValue &lt; 600 ? a : -a; &#125;, 50); &#125; function move1(ele) &#123; clearInterval(ele.timer); var speed = 0, a = 2, curValue; ele.timer = setInterval(function () &#123; curValue = ele.offsetLeft; speed += curValue &lt; 600 ? a : -a; ele.style.left = curValue + speed + 'px'; &#125;, 50); &#125; oDiv[0].onclick = function () &#123; move(this); move1(oDiv[1]); &#125;&lt;/script&gt; 原因 首先来理解整个这个过程： 物体以一定的初速度开始做匀加速运动，到达中间点后开始做匀减速运动；速度减为0后开始做反向匀加速运动，到达中间点后开始做匀减速运动，如此反复(上面代码中设定的中间点是600) 下面介绍两种写法的区别： 复合预期的写法，到达中间点后加速度立即变为负数，然后改变物体的位置； 不符合预期的写法，到达中间点后先改变物体的位置，然后才改变加速的，这样的话，过了中间点后，物体仍然处于加速原来的状态，所以会继续运动一段时间，等下一次再次判定时，才会按照上一次改的加速的运动，这样多次反复，运动距离会越来越远 有摩擦力加上摩擦力后，物体的加速的就不能保持不变了，会逐渐减小 12345678910111213141516171819202122232425262728293031323334353637&lt;style type="text/css"&gt; .demo &#123; position: absolute; left: 100px; top: 0px; width: 50px; height: 50px; background-color: orange; border-radius: 50%; line-height: 50px; text-align: center; cursor: pointer; &#125;&lt;/style&gt;&lt;div class="demo"&gt;click&lt;/div&gt;&lt;script type="text/javascript"&gt; var oDivDemo = document.getElementsByClassName('demo')[0]; function move(ele, tarLoc) &#123; clearInterval(ele.timer); var curValue, a, speed = 0, u = 0.9; ele.timer = setInterval(function () &#123; curValue = ele.offsetLeft; a = (tarLoc - curValue) / 9; speed += a; speed *= u; console.log(speed); ele.style.left = curValue + speed + 'px'; &#125;, 30); &#125; oDivDemo.onclick = function () &#123; move(this, 600); &#125;&lt;/script&gt; 让运动停下来上面的代码中没有清除计时器，所以物体并没有真正的停下来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// head&lt;style type="text/css"&gt; .demo &#123; position: absolute; left: 100px; top: 0px; width: 50px; height: 50px; background-color: orange; border-radius: 50%; line-height: 50px; text-align: center; cursor: pointer; &#125;&lt;/style&gt; // body&lt;div class="demo"&gt;click&lt;/div&gt;&lt;script type="text/javascript"&gt; var oDivDemo = document.getElementsByClassName('demo')[0], key = true; function move(ele, tarLoc) &#123; clearInterval(ele.timer); var curValue, a, speed = 0, u = 0.9; ele.timer = setInterval(function () &#123; curValue = ele.offsetLeft; a = (tarLoc - curValue) / 9; speed += a; speed *= u; ele.style.left = curValue + speed + 'px'; if (Math.abs(tarLoc - curValue) &lt;= 1 &amp;&amp; Math.abs(speed) &lt;= 1) &#123; clearInterval(ele.timer); &#125; &#125;, 30); &#125; oDivDemo.onclick = function () &#123; if (key) &#123; move(this, 600); key = false; &#125; &#125;&lt;/script&gt; 模拟重力场（加拖拽） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// head&lt;style type="text/css"&gt; .demo &#123; position: absolute; left: 0px; top: 0px; width: 50px; height: 50px; background-color: orange; border-radius: 50%; text-align: center; line-height: 50px; font-weight: bold; cursor: pointer; &#125;&lt;/style&gt; // body&lt;div class="demo"&gt;drag&lt;/div&gt;&lt;script type="text/javascript"&gt; var oDiv = document.getElementsByTagName('div')[0]; function move(ele, speedX, speedY) &#123; var curLocX, curLocY, xLoc, yLoc, g = 4.5, u = 0.9; ele.timer = setInterval(function () &#123; curLocX = ele.offsetLeft; curLocY = ele.offsetTop; speedY += g; xLoc = curLocX + speedX; yLoc = curLocY + speedY; if (window.innerHeight - ele.offsetHeight &lt;= yLoc) &#123; yLoc = window.innerHeight - ele.offsetHeight; speedX *= u; speedY *= u; speedY *= -1; &#125; if (yLoc &lt; 0) &#123; yLoc = 0; speedX *= u; speedY *= u; speedY *= -1; &#125; if (window.innerWidth - ele.offsetWidth &lt;= xLoc) &#123; xLoc = window.innerWidth - ele.offsetWidth; speedX *= u; speedY *= u; speedX *= -1; &#125; if (xLoc &lt; 0) &#123; xLoc = 0; speedX *= u; speedY *= u; speedX *= -1; &#125; ele.style.left = xLoc + 'px'; ele.style.top = yLoc + 'px'; if (Math.abs(curLocX - xLoc) &lt; 0.1 &amp;&amp; curLocY == yLoc) &#123; clearInterval(ele.timer); &#125; &#125;, 20); &#125; oDiv.onmousedown = function(e) &#123; clearInterval(this.timer); var event = e || window.event, deviationX = event.clientX - this.offsetLeft, deviationY = event.clientY - this.offsetTop, speedX = 0, speedY = 0; document.onmousemove = function (e) &#123; var event = e || window.event, xLoc = event.clientX - deviationX, yLoc = event.clientY - deviationY; speedX = xLoc - oDiv.offsetLeft; speedY = yLoc - oDiv.offsetTop; oDiv.style.left = xLoc + 'px'; oDiv.style.top = yLoc + 'px'; &#125; document.onmouseup = function () &#123; this.onmousemove = null; this.onmouseup = null; move(oDiv, speedX, speedY); &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM]]></title>
    <url>%2F2018%2F05%2F22%2Fa35_javascript%2F</url>
    <content type="text"><![CDATA[BOM简介BOM是 “Browser Object Modle” 的缩写，简称 “浏览器对象模型”。主要处理浏览器窗口和框架，描述了与浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作。 BOM与DOM的关系 JavaScript 是通过访问 BOM 来访问、控制、修改浏览器的 BOM 的 window 包含了document，因此通过 window 对象的 document 属性可以访问、检索、修改文档内容与结构 document 对象是 DOM 模型的根节点 综上所述，BOM 包含 DOM，访问浏览器的是 BOM 对象，从 BOM 对象访问 DOM 对象，从而 js 可以操作浏览器以及浏览器读取到文档；除此之外，W3C 规定了关于 DOM 的标准规范，但是对于 BOM 来说，因为它是对浏览器的操作，而每个浏览器各自的实现不尽相同，所以有些方法在某些浏览器上适用，有些浏览器上不适用 BOM 对象BOM 对象包含以下内容 Window JavaScript 层级中的顶级对象，表示浏览器窗口 Navigator 包含了客户端浏览器信息 History 包含了浏览器访问过的URL Location 包含了浏览器当前访问的URL Screen 包含了客户端显示屏的信息 window对象window对 象有很多属性和方法，这里只记录一些常用的，其他可以到 w3c 查找 对象方法 close() 关闭当前的浏览器窗口 alert() 显示一段消息的弹出框 comfirm() 显示一段消息以及确认按钮和取消按钮的对话框，返回值是Boolean类型 12345678&lt;script type="text/javascript"&gt; var value = confirm('真的要关闭当前窗口么?'); if (value) &#123; window.close(); &#125; else &#123; window.alert('没有关闭!'); &#125;&lt;/script&gt; open(URL, name, features, replace) 打开一个新的浏览器窗口或者查找一个已命名的窗口，新的文档对第四个标准不支持了，所以不考虑第四个参数 参数都可以为空，但是如果不写第三个参数的话，是在当前浏览器中打开一个新的窗口（一个新的标签页），除非是打开已存在的窗口（比如第四点） 123&lt;script type="text/javascript"&gt; window.open('', '', '');&lt;/script&gt; 打开一个宽高为设定值的新的窗口 123&lt;script type="text/javascript"&gt; window.open('', '', 'width=500, height=400');&lt;/script&gt; 打开一个指定路径或网址的新的窗口 1234&lt;script type="text/javascript"&gt; window.open('./new.html', '', 'width=500, height=400'); window.open('https://www.baidu.com', '', 'width=500, height=400');&lt;/script&gt; 这里如果打开文件是自身的话，会循环无止境的打开新的窗口 打开一个新的窗口，并为之命名 1234&lt;script type="text/javascript"&gt; window.open('', 'newName', 'width=500, height=400'); window.open('https://www.baidu.com', 'newName', '');&lt;/script&gt; 如果要关闭某一个新建的窗口，要用一个变量来接受这个窗口对象 12345&lt;script type="text/javascript"&gt; var newWindow = window.open('', 'newW', 'width=500, height=400'); // neW.close(); 这样是不行的 newWindow.close();&lt;/script&gt; moveBy(x, y) 相对窗口的当前坐标，把他移动一定的距离（往右移x，往下移y） 1234&lt;script type="text/javascript"&gt; var newWindow = window.open('', 'newW', 'width=500, height=400'); newWindow.moveBy(200, 200);&lt;/script&gt; 操作对 window 无效 moveTo(x, y) 把窗口移动到指定位置 1234&lt;script type="text/javascript"&gt; var newWindow = window.open('', 'newW', 'width=500, height=400'); newWindow.moveTo(200, 200);&lt;/script&gt; 操作对 window 无效 print() 打印当前窗口的内容 prompt() 显示可提示用户输入的对话框，点击确认返回值是输入内容，点击取消返回值是null 1234&lt;script type="text/javascript"&gt; var name = window.prompt('请输入用户名'); console.log(name);&lt;/script&gt; scrollBy(x, y) 滚动条滚动指定的距离 scrollTo(x, y) 滚动条滚动到指定位置 对象属性 closed 判断窗口是否被关闭，返回Boolean值 123456&lt;script type="text/javascript"&gt; var newW = window.open('', '','width=100, height'); console.log(newW.closed); newW.close(); console.log(newW.closed);&lt;/script&gt; innerHeight / innerWidth 返回窗口的文档显示区的高度、宽度 1234&lt;script type="text/javascript"&gt; console.log('width:' + window.innerWidth); console.log('height:' + window.innerHeight);&lt;/script&gt; outerHeight / outerWidth 返回浏览器窗口的高度、宽度 length 设置或返回窗口中的框架数量（后面用到再补充） name 窗口的名称（后面会借助 window.name 实现数据的跨域） pageXOffset / pageYOffset 设置或者返回当前页面相对于窗口显示区左上角 X / Y 的位置 这个的一个用途是：可以做页面中固定位置的广告，一般用position：fixed实现，但是position：fixed在IE中会存在兼容性问题，可以用这个做 screenLeft / screenTop screenX / screenY 只读整数，声明了窗口左上角在屏幕上的x坐标和y坐标。IE、Safari、chrome、Opera 支持 screenLeft，chrome、Firefox、Safari 支持 screenX Navigator对象Navigator 对象包含的属性描述了正在使用的浏览器的。可以使用这些属性进行平台专用配置。虽然这个对象的名称显而易见是 Netscape 的 Navigator 浏览器，但是 JavaScript 的浏览器也支持这个对象 对象属性 appVersion 返回浏览器的平台和版本信息 cookieEnabled 返回指定浏览器是否启用cookie的布尔值 onLine 返回指定系统是否处于联机模式的布尔值 做离线缓存可以用到这个 userAgent 返回客户机发送服务器的 user-agent 头部的值，这个是有用的方法，后面讲 plugins 返回包含客户端安装的所有插件的数组 对象方法History对象History 对象包含用户（在浏览器中）访问过的 URL 对象属性 length 返回浏览器历史列表中访问过的URL 对象方法 back() 加载 history 列表中的前一个 URL forward() 加载 history 列表中后一个 URL go(num) 加载 history 列表中前 / 后 num 个页面 Location对象Location 对象包含有关当前URL的信息 对象属性 hash 设置或返回从 # 开始的 URL（锚） host 设置或返回主机名和当前URL的端口号，如果端口号是默认端口号，就不显示端口号；如果是设置的别的端口号，就会返回端口号 hostname 设置或者返回当前URL的主机名 post 设置或者返回当前URL的端口号 href 设置或者返回完整的URL pathname 设置或返回当前URL的路径部分 protocol 设置或返回当前URL的协议 search 设置或返回从 ？ 开始的 URL 部分 对象方法 assign() 加载新的文档 reload(‘force’) 重新加载当前文档，参数不可选，不填或填false则取浏览器缓存文档 replace() 用新的文档替换当前文档 Screen对象Screen 对象包含有关客户端显示屏幕的信息。每个 Window 对象的 screen 属性都引用一个 Screen 对象。JavaScript 将利用这些信息来优化他们的输出，已达到用户的显示要求。例如，一个程序可以根据显示器的尺寸选择大图像还是小图像，他还可以根据显示器的颜色深度选择使用16为色还是8为色的图形。另外，JavaScript 还能根据浏览器屏幕信息，将新的浏览器窗口固定到屏幕中间 对象属性 availHeight / avaliWidth 返回显示器高度 / 宽度 （不包含任务栏） height / width 返回显示屏幕的高度 / 宽度（不管是任务栏还是什么都包括）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面渲染机制]]></title>
    <url>%2F2018%2F05%2F22%2Fa34_javascript%2F</url>
    <content type="text"><![CDATA[浏览器渲染页面过程一个 web 页面一般是由三部分构成的，即我们熟知的 html + css + js，那么当浏览器在渲染一个页面时，它的过程是怎么样的呢？下面我们简单的介绍浏览器渲染页面的流程（不同浏览器的内核不同，所以它们渲染页面的机制也不是完全相同，但从整体流程上来看，大致上可以分为四个步骤 第一步：构建DOM树首先浏览器会解析并加载页面的html结构，按照深度优先的原则构建DOM树 注意这里对html操作的描述是解析并加载，也就是说构建DOM树这个过程分为两步，解析、加载 解析的意思就是识别html标签，将识别元素挂到DOM树上去；加载的意思是下载某些标签所引入的文档图片等资源；重要的是：解析发生在加载之前，也就是说当html结构解析完毕后，才会加载这些资源 举个例子： 123&lt;div&gt;&lt;/div&gt;&lt;img src="demo.png"&gt;&lt;p&gt;&lt;/p&gt; 在这个例子中，首先解析html结构，div、img、p 标签被识别挂到 DOM 树上去，此后才会加载 img 中需要的图片资源（这里仅以这三个标签为例进行讲解，不考虑 html 文档中的 head、body 等标签） 第二步：构建CSSOM树接下来，浏览器将要做的工作是解析页面中的CSS结构，将不同标签的渲染样式构建成树 第三步：构建RENDER树DOM tree 和 CSSDOM tree 合并成 render tree，render tree 中每个 node 都有自己的 style，而且 render tree不包含隐藏的节点(比如 display:none 的节点，还有无样式 head 节点)，因为这些节点不会用于呈现，而且不会影响呈现的，注意 visibility:hidden 隐藏的元素还是会包含到 render tree 中的，因为 visibility:hidden 会影响布局(layout)，会占有空间。 第四步：计算布局render tree 构建完毕之后根据样式计算布局，布局阶段的输出结果称为 “盒模型”（box model）。盒模型精确表达了窗口中每个元素的位置和大小，而且所有的相对的度量单位都被转化成了屏幕上的绝对像素位置 JS操作对页面渲染的影响在页面中使用JS操作 DOM 元素，会影响页面的渲染过程，下面举例说明 重排（reflow） DOM 节点的添加、删除 添加或删除DOM节点，会使DOM树、RENDER树的结构发生变化，页面要重新渲染 DOM 节点的宽高变化 DOM 节点的宽高变化会影响其他 DOM 元素的位置，会使 CSSOM、RENDER 树的结构发生变化，页面需要重新渲染 查询 DOM 元素的样式 比如 offsetWidth、offsetLeft 等操作，页面需要重新渲染来保证查询的值是实时的，也会影响页面性能 重排也叫作“回流”，每个页面至少回流一次，就是在页面第一次加载的时候 重绘（repaint）重绘（repaints）当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color，就叫称为重绘 整体来看，重绘浪费的效率比较少，而重排浪费的效率比较多，但是都会影响页面的性能，所以要尽量减少 JS对 DOM 的操作 在浏览器中分析F12 -&gt; performance -&gt; summary 蓝色：网络通信和HTML解析 黄色：JavaScript 执行 紫色：样式计算和布局，即重排 绿色：重绘 性能优化浏览器发生重排和重绘都会消耗浏览器的性能，那么为了提高浏览器的性能，可以采取哪些方式呢 减少DOM操作 js 对 DOM 的操作是引发重排重绘的主要原因，所以要尽量减少 js 对 DOM 的操作 浏览器优化队列 理论上每发生一次 DOM 的变动就会触发一次重排或重绘，但是现在的浏览器增加了优化处理，会把 js 中连续的对 DOM 的读操作，或者连续的对 DOM 的写操作排成队列集中处理一次执行，避免了多次渲染，所以在开发时尽量把触发重排重绘的 DOM 操作写在一起，注意读操作和写操作分开写才能达到效果，比如 123456789101112131415/* 连续写操作只触发一次重排重绘 */div.style.color = 'red';div.style.left = '10px';div.style.background = 'yellow';/* 连续的读操作只触发一次重排重绘 */var color = div.style.color;var height = div.offsetHeight;var width = div.offsetWidth;/* 交替的读写操作会不会形成优化丢列，每次操作都会触发重排重绘 */var color = div.style.color;div.style.color = 'green';var height = div.offsetHeight;div.style.left = '10px'; 离线 DOM 操作 我们可以先进行 DOM 操作，而操作的元素不在页面结构中，操作完成后再一次添加到页面中 比如使用：document.createDocumentFragment()，字符串拼接、cloneNode() 等方法 巧妙修改 css 样式 添加类名 将我们要应用的样式提前写入 css 样式中，修改样式时直接变换相应的类名即可 比如一个元素未点击和点击后的效果不同，我们可以提前在 css 中写好这两种样式，根据不同触发条件应用不同的类名，适应不同的样式 一次性添加到 dom.style.cssText 上 直接举例说明，原来某一段修改css样式的代码如下 123div.style.width = '10px';div.style.height = '20px';div.style.backgroundColor = 'red'; 一次性添加到 dom.style.cssText 上： 1div.style.cssText = 'width: 10px; height: 20px; background-color: green;'; 动画元素脱离文档流 脱离了文档流的元素，其样式改变不会影响到文档流中原有的布局]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON、XML]]></title>
    <url>%2F2018%2F05%2F22%2Fa33_javascript%2F</url>
    <content type="text"><![CDATA[这篇主要是简单了解一下 XML 与 JSON 的用途及简单的语法，不进行深入的研究 XML XML是一门语言 XML是存储和通过因特网传输结构化数据的标准 XML可以自定义标签 JSON 曾经有一段时间，XML 是互联网上传输结构化数据的标准。web 服务的第一次浪潮很大程度上都是建立在XML 之上的，突出的特点是服务器与服务器之间的通信。然而不少人认为 XML 过于繁琐、冗长。为了解决这个问题，涌现了一些方案。 2006 年，DouglasCrockford 把 JSON (Javascript Object Notation，JavaScript对象表示法) 作为 IETF RFC 4627 提交给 IETF，而 JSON 早在 2001 年就开始被使用了。JSON 是 JavaScript 的一个严格子集，利用JavaScript 中的一些模式来表示结构化数据。与 XML 相比，JSON 是在 JavaScript 中读写结构化数据更好的方式。因为可以把 JSON 直接传给 eval()，而不必创建 DOM 对象。 JSON 是一种数据格式，而不是一门编程语言 JSON 与 JavaScript 具有相同的语法形式，但是不从属于 JavaScript 并不是只有 JavaScript 才有 JSON，JSON 只是一种数据格式，很多语言都有针对 JSON 的解析器和序列化器。 语法 JSON 的语法可以表示一下三种类型的值，不支持变量、函数或者对象实例 简单值 使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值、null，不支持 undefined。JSON 中的字符串必须使用双引号，单引号会导致语法错误 对象 JSON 中的对象与 JavaScript 中的字面量有些不同，先看一个 JavaScript 字面量的例子： 1234var person = &#123; name: 'qht', age: 20&#125;; JSON 中的对象是这样的： 1234&#123; "name": "qht", "age": 20&#125; 不同点： 没有变量声明(JSON 中没有变量的概念) 文末没有分号(因为这并不是 JavaScript 语句，所以不需要分号) 属性值必须加双引号(JavaScript 中的属性名可以加引号也可以不加引号，如果加引号，可以加单引号也可以见双引号，但是对于 JSON 来说，属性名必须加双引号，单引号回导致语法错误) 数组 JSON 中的数组采用的就是 JavaScript 中数组字面量的形式，没有变量声明和分号 1[11, "hello", true] JSON对象 早期的 JSON 解析器基本上就是 JavaScript 的 eval() 函数，ECMAScript 5 对解析 JSON 的行为进行了规范，定义了全局的 JSON 对象，支持这个对象的浏览器有IE8+、Firefox3.5+、Safari4+、chrome、Opera10.5+。对于较早版本的浏览器，可以使用一个shim：https://github.com/douglascrockford/JSON-js。在旧版本的浏览器中，使用 eval() 对 JSON 数据结构求值存在风险，可能会执行一些恶意代码。对于不能原生支持 JSON解析的浏览器，使用这个 shim 是最好的选择。 解析与序列化 JSON 格式的数据进行解析和序列化利用的是 JSON 对象中的两个方法 JSON.stringify() 12345678var obj = &#123; name: 'qht', age: 20, fn: function() &#123; console.log('a'); &#125;, test: undefined,&#125; JSON 序列化的结果是一个字符串，默认情况下，这个字符串不包含任何空格或者缩进。 在序列化 JavaScript 对象时，所有函数、原型成员都会别有意忽略，不体现在结果中，值为 undefined 的任何属性也都会被跳过。结果中的最终值都是值为有效的 JSON 数据类型的实例属性。 JSON.parse() 将JSON字符串直接传递给 JSON.parse() 方法，就可以得到相应的 JavaScript 类型的值。如果传递给这个方法的字符串不是有效的 JSON，该方法会抛出错误。 12345var obj = &#123; name: 'qht'&#125;var str = JSON.stringify(obj);console.log(JSON.parse(str));]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件练习]]></title>
    <url>%2F2018%2F05%2F21%2Fa32_javascript%2F</url>
    <content type="text"><![CDATA[改变元素样式 给定一个div，要求点击后改变样式 初始样式：宽高100px，颜色red 改变样式：宽50px，高150px，颜色green 123456789&lt;div style="width:100px;height:100px;background-color:red;"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; div.onclick = function () &#123; this.style.width = '50px'; this.style.height= '150px'; this.style.backgroundColor = 'green' &#125;&lt;/script&gt; 一般情况下会想到这种实现方式，但是这种方法并不好，频繁的用 js 访问 dom元素，会使页面性能下降，这里介绍另一种编程思想 这里我们要实现的效果就是，一个元素从一种样式变成另外一种样式，那我们不对元素本身进行修改，而是提前就写好两种样式，在使用时，需要那种样式，就让哪种样式起作用，这样也可以达到要求，且不需要频繁的操作 dom，性能更好 12345678910111213141516171819202122// head&lt;style type="text/css"&gt; .originStyle &#123; width: 100px; height: 100px; background-color: red; &#125; .newStyle &#123; width: 50px; height: 150px; background-color: green; &#125;&lt;/style&gt; // body&lt;div class="originStyle"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; div.onclick = function () &#123; this.className = 'newStyle'; &#125;&lt;/script&gt; 了解了这个以后，来思考这样一个问题： 这个编程方法的思想是通过选择新的渲染样式，让旧的渲染样式失效；这个过程是通过让新的标签名起作用，让旧的标签名失效来实现的，但是如果旧的标签名如果与其他的一些标签相关联，那么与之相关的这些标签同样也会失效，举个例子： 123456789101112131415161718192021222324252627282930// head&lt;style type="text/css"&gt; .wrapper &#123; width: 150px; height: 150px; background-color: green; &#125; .wrapper .inner &#123; width: 50px; height: 50px; background-color: red; &#125; .wrapperNew &#123; width: 150px; height: 150px; background-color: orange; opacity: 0.5; &#125; &lt;/style&gt; // body&lt;div class="wrapper"&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divWrapper = document.getElementsByTagName('div')[0]; divWrapper.onclick = function () &#123; this.className = 'wrapperNew'; &#125; &lt;/script&gt; 效果：在wrapper改变样式的同时，wrapperInner也失效了 这样的效果使我们不想要的，我们只想要改变wrapper的样式，并不想让与之相关的其他元素的样式受影响，下面说一下我的思路： 首先想到的是，既然会影响到与之相关联的元素，那么我在写页面样式的时候，就提前想好，将来可能要改变谁的样式，我让他的逻辑与其他元素不相关联，这样以后改的时候就不会影响到其他元素了；但这样的想法显然是不行的，在项目开发中，需求随时都有可能变化，元素之间的关系也是不断变化的，所以这个思路pass 既然无法从元素之间的关系入手，那就是说不能简单的让要被改变样式的元素失效。仔细想一下，上面demo中wrapperInner失效的原因是wrapper外面的盒子的类名由 wrapper 变成了 wrapperNew，这样通过 .wrapper .wrapperInner 给wrapperInner设置的样式就不起作用了，所以，我们是要让wrapper的样式失效，但是我们不能让wrapper名称失效，所以想到了，在旧的样式不变的基础上，让新的样式也作用在元素上，保证旧的类名不失效的前提下，让新的样式覆盖掉旧的样式。 1234// 将上面代码中事件处理函数中的// this.name = 'wrapperNew';// 改成 // this.name = 'wrapper wrapperNew'; 那既然要让新的样式覆盖掉旧的样式，那么就要把新的样式写在旧的样式后面，或者让新的样式的权重更高，目前我能想到的让新的样式权重更高的方法就是用 ‘!important’（肯定还有更好的办法，还没想到） 1234567891011121314151617181920212223242526272829// head&lt;style type="text/css"&gt; .wrapper &#123; width: 150px; height: 150px; background-color: green; &#125; .wrapper .inner &#123; width: 50px; height: 50px; background-color: red; &#125; .wrapperNew &#123; // 既然是覆盖，那么相同的属性就没必要再写一遍了 background-color: orange; opacity: 0.5; &#125; &lt;/style&gt; // body&lt;div class="wrapper"&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divWrapper = document.getElementsByTagName('div')[0]; divWrapper.onclick = function () &#123; this.className = 'wrapper wrapperNew'; &#125; &lt;/script&gt; 用 addEventListener() 绑定监听函数 一个ul下面有三个li，现在要给这三个li分别绑定事件，要求点击第几个a，就打印数字几 12345678910111213141516&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var liCol = document.getElementsByTagName('li'), len = liCol.length; for (var i = 1;i &lt;= len; i++) &#123; (function(j) &#123; liCol[j].addEventListener('click', function() &#123; console.log(j); &#125;, false); &#125;(i)) &#125;&lt;/script&gt; 注意： 不使用立即执行函数的话会形成闭包，打印结果都是4 小技巧： 当某一个函数内部使用了其他函数作用域内的变量的时候，一定要注意是否形成了闭包 封装绑定事件处理函数的兼容性方法 在IE11/chrome、IE9、IE9以下文档模式下分别调试通过 1234567891011function addEvent(elem, type, handle) &#123; if (elem.addEventListener) &#123; elem.addEventListener(type, handle, false); &#125; else if (elem.attachEvent) &#123; elem.attachEvent('on' + type, function() &#123; handle.call(elem); &#125;); &#125; else &#123; elem['on' + type] = handle; &#125;&#125; 封装解除事件处理函数绑定的兼容性方法12 封装取消事件冒泡的兼容性方法1234567function stopBubble(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125;&#125; 封装阻止默认事件的兼容性方法1234567function cancelHandler(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125;&#125; 拖拽应用1234567891011121314151617181920&lt;div style="width:100px;height:100px;background-color:green;position:absolute;"&gt;&lt;/div&gt;&lt;script type='text/javascript'&gt; var div = document.getElementsByTagName('div')[0], originLocX, originLocY; div.onmousedown = function(e) &#123; var event = e || window.event; originLocX = event.clientX - parseInt(window.getComputedStyle(this, null).left); originLocY = event.clientY - parseInt(window.getComputedStyle(this, null).top); document.onmousemove = function(e) &#123; var event = e || window.event; div.style.left = event.clientX - originLocX + 'px'; div.style.top = event.clientY - originLocY + 'px'; &#125; document.onmouseup = function() &#123; document.onmousemove = null; document.onmouseup = null; &#125; &#125;&lt;/script&gt; 随机移动方块 具体要求：当鼠标移到方块上时，方块随机向上、下、左、右任意一个方向移动 123456789101112131415161718192021222324252627// head&lt;style type="text/css"&gt; div &#123; width: 100px; height: 100px; background-color: green; position: absolute; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px; &#125;&lt;/style&gt; // body&lt;div&gt;&lt;/div&gt;&lt;script type='text/javascript'&gt; var div = document.getElementsByTagName('div')[0]; div.onmouseenter = function() &#123; var w = parseInt(window.getComputedStyle(this, null).width); h = parseInt(window.getComputedStyle(this, null).height); sub = parseInt(Math.random() * 100 / 25); var arr = [[0, -h], [0, h], [-w, 0], [w, 0]]; this.style.left = parseInt(window.getComputedStyle(this, null).left) + arr[sub][0] + 'px'; this.style.top = parseInt(window.getComputedStyle(this, null).top) + arr[sub][1] + 'px'; &#125;&lt;/script&gt; 文本框输入练习 要求： 文本框中默认显示：‘请输如关键词’ 字样，颜色为 #999； 文本框聚焦后：默认字样消失，等待用户输入，颜色为 #424242； 文本框失去焦点后：若文本框中有内容，则显示内容，反之，则展示默认显示； 若文本框中输入的内容与默认内容相容，要求再次聚焦后，该内容不消失 123456789101112131415161718192021222324252627282930// head&lt;style type="text/css"&gt; input &#123; width: 300px; height: 30px; color: #999; &#125;&lt;/style&gt; // body&lt;input type="text" value="请输入关键词"&gt;&lt;script type="text/javascript"&gt; var input = document.getElementsByTagName('input')[0], isInput = false; input.onfocus = function () &#123; if (this.value == '请输入关键词' &amp;&amp; !isInput) &#123; this.value = ''; this.style.color = '#424242'; &#125; &#125; input.onblur = function () &#123; if (this.value == '') &#123; this.value = '请输入关键词'; this.style.color = '#999'; isInput = false; &#125; else &#123; isInput = true; &#125; &#125;&lt;/script&gt; 代码中的isInput是为了实现第四点要求，实现的关键是在文本框失去焦点的时候，判断是否是否输入过内容]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用事件分类]]></title>
    <url>%2F2018%2F05%2F20%2Fa31_javascript%2F</url>
    <content type="text"><![CDATA[鼠标事件 常用鼠标事件 mousedown 鼠标点下去 mouseup 鼠标抬起来 click mousedown + mouseup 鼠标点下去然后抬起来 mousemove 鼠标移动 mouseenter == mouseover 鼠标移上去 mouseenter 不支持事件冒泡 mouseout == mouseleave 鼠标移开 mouseout事件不支持事件冒泡 contextmenu 右键出菜单 区分点击的是 左键 还是 右键 只能利用 mousedown 或者 mouseup 事件对象里面的 button属性 button：0 — 左键 ​ 1 — 滚动轮 ​ 2 — 右键 DOM3 标准规定：click 事件只能监听左键，只能通过mousedown 和 mouseup来判断鼠标键 解决 mousedown + mouseup 和 click 的冲突 因为 click 的对事件是否触发的判断 和 mousedown + mouseup 的整个过程对事件是否触发的判断是一样的，mousedown 以后一定会 mouseup，这样就相当于完成了一次 click 事件，会触发 click 的事件处理函数，如果不想让这个过程触发 click 的事件处理函数，该怎么解决呢 思路：利用时间差 12345678910111213141516171819202122&lt;div style="width:100px;height:100px;background-color:green;"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0], firstTime, secondTime, key = false; div.onmousedown = function() &#123; firstTime = new Date().getTime(); &#125; div.onmouseup = function() &#123; secondTime = new Date().getTime(); if (secondTime - firstTime &lt; 300) &#123; key = true; &#125; &#125; div.onclick = function () &#123; if (key) &#123; console.log('触发了click事件'); key = false; &#125; &#125;&lt;/script 键盘事件 常用键盘事件 keydown 键盘按键按下去(一直按住会连续触发) keypress 键盘按键按下去以后 keyup 键盘按键抬起来 keydown、keypress、keyup的判断顺序 keydown &gt; keypress &gt; keyup keydown、keypress的区别 keydown的执行要先于keypress keydown可以相应任意键盘按键(除了fn)，keypress 只可以相应字符类按键(有 ASCII 值的) 通过keypress事件对象中的charCode属性，可以判断按下的是什么字符 which 键盘的每一个按键都对应一个which值 demo 了解不同类型的按键及它们的事件对象 12345678910111213&lt;script type="text/javascript"&gt; document.onkeydown = function(event) &#123; console.log(event); &#125; document.onkeypress = function (event) &#123; console.log(event); &#125; document.onkeyup = function (event) &#123; console.log(event); &#125;&lt;/script&gt; 按下 a ： 打印出三个事件对象，分别是 onkeydown 、onkeypress、onkeyup 的事件对象 按下 Ctrl ： 打印出两个事件对象，分别是 onkeydown、onkeypress 的事件对象，因为 onkeypress 只能监听字符类的按键 按下Fn： 不打印任何事件对象，因为Fn只是键盘的一个辅助按键，不算做一个功能按键 按下一个字符类按键，返回这个按键所对应的字符 12345&lt;script type="text/javascript"&gt; document.onkeypress = function (event) &#123; console.log(String.fromCharCode(event.charCode)); &#125;&lt;/script&gt; 文本类操作事件 常用文本操作事件 input 文本框中当前有什么文本，都会得到反馈 12345678910111213141516// head&lt;style type="text/css"&gt; input &#123; width: 300px; height: 30px; &#125;&lt;/style&gt; // body&lt;input type="text"&gt;&lt;script type="text/javascript"&gt; var input = document.getElementsByTagName('input')[0]; input.oninput = function () &#123; console.log(this.value); &#125;&lt;/script&gt; 在文本框里面输入或者删除文本，观察控制台的打印结果 focus、blur 文本框聚焦、失去焦点 12345678910111213141516171819// head&lt;style type="text/css"&gt; input &#123; width: 300px; height: 30px; &#125;&lt;/style&gt; // body&lt;input type="text"&gt;&lt;script type="text/javascript"&gt; var input = document.getElementsByTagName('input')[0]; input.onfocus = function () &#123; console.log('foucus'); &#125; input.onblur = function () &#123; console.log('blur'); &#125;&lt;/script&gt; 点击文本框，再点击空白非文本框区域，观察控制台打印结果 change 文本框聚焦然后失去焦点后，文本框的中的内容有变化，会触发change事件 12345678910111213141516// head&lt;style type="text/css"&gt; input &#123; width: 300px; height: 30px; &#125;&lt;/style&gt; // body&lt;input type="text"&gt;&lt;script type="text/javascript"&gt; var input = document.getElementsByTagName('input')[0]; input.onchange = function () &#123; console.log('change'); &#125;&lt;/script&gt; 鼠标点击文本框，输入一些内容，鼠标点击空白区域，观察控制台打印结果； 鼠标再次点击文本框，修改刚才输入的内容，鼠标点击空白区域，观察控制台打印结果； 一定要清除，change事件的触发是在文本框聚焦又失去焦点后才触发的 窗体类操作事件 常见的窗体类操作事件 scroll 当滚动条滚动的时候，scroll事件就会触发，是window上的事件 load window上的事件，当页面完全加载完后(包括所有的图片、JavaScript文件、CSS文件等资源)，才触发load事件。 正是因为load事件的这种加载方式，所以它的执行会很慢，很影响页面性能，所以一般不使用，关于页面加载方式的问题，后面会详细讲到]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件深入]]></title>
    <url>%2F2018%2F05%2F19%2Fa30_javascript%2F</url>
    <content type="text"><![CDATA[事件处理模型事件冒泡结构上(非视觉上)嵌套关系的元素，会存在事件冒泡功能，即同一事件，自子元素冒泡向父元素。(自底向上) 首先描述视觉现象 123456789101112131415161718192021222324252627282930313233343536373839404142// head&lt;style type="text/css"&gt; .wrapper &#123; width: 300px; height: 300px; background-color: red; &#125; .content &#123; width: 200px; height: 200px; background-color: green; /* margin-left: 300px; */ &#125; .box &#123; width: 100px; height: 100px; background-color: orange; /* margin-left: 200px; */ &#125;&lt;/style&gt; // body&lt;div class="wrapper"&gt; &lt;div class="content"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var wrapper = document.getElementsByClassName('wrapper')[0], content = document.getElementsByClassName('content')[0], box = document.getElementsByClassName('box')[0]; wrapper.addEventListener('click', function() &#123; console.log('wrapper'); &#125;, false); content.addEventListener('click', function() &#123; console.log('content'); &#125;, false); box.addEventListener('click', function() &#123; console.log('box'); &#125;, false);&lt;/script&gt; 以上代码实现的效果： 点击红色区域打印：wrapper 点击绿色区域打印：content、wrapper 点击橘色区域打印：box、content、wrapper 视觉上，小的盒子放在大的盒子上，点击小的盒子，不仅会触发自己的事件，还会触发它所处的大的区域的盒子的事件，这样看来，好像是一层一层往下走，而不是我们所理解的冒泡的现象，这是因为这里所说的冒泡现象是结构上的而非视觉上的，下面来解释结构上的冒泡 理解结构上的冒泡 将上面代码中 content 和 box 中的注释打开，再次运行代码 代码实现效果： 点击红色区域打印：wrapper 点击绿色区域打印：content、wrapper 点击橘色区域打印：box、content、wrapper 这一次在视觉上，各个盒子都是相互分离的，没有嵌套关系，但是点击每一个部分后触发的效果和原来是一样的，说明冒泡现象和这些盒子在视觉上的关系是没有联系的，下面把这些盒子的结构拿来看一下 12345&lt;div class="wrapper"&gt; &lt;div class="content"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 这三个盒子在结构上的关系是一层包着一层的，对比着这个结构，再次回想刚才事件的出发效果：点击box区域，触发box+content+wrapper的事件；点击content区域，触发content+wrapper的事件；点击wrapper区域，触发wrapper的事件；即 ”点击“这个事件，在子元素触发后，就一层一层的向它的父元素传递 ”点击“ 这个事件，如果父元素也有相应事件的处理函数，那么就展示相应的效果；把这样的过程形象化为 ”事件的冒泡“ 通过几个问题深入理解事件的冒泡 上述三层盒模型结构中，wrapper是最外层，那是不是就代表着wrapper是box、content事件冒泡的终点呢？ 仔细读定义，同一个事件会从子元素一层一层的向父元素传递，对于box来讲，他的点击事件的传递路径是这样的：box — content — wrapper — body — html — document，只不过我们只给content和wrapper的点击事件绑定了处理函数，使它们可以展示出来效果，其他的父元素也收到了点击这个事件，只是没有处理函数来响应这个事件 运行下面代码，点击box观察结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344// head&lt;style type="text/css"&gt; .wrapper &#123; width: 300px; height: 300px; background-color: red; &#125; .content &#123; width: 200px; height: 200px; background-color: green; &#125; .box &#123; width: 100px; height: 100px; background-color: orange; &#125;&lt;/style&gt; // body&lt;script type="text/javascript"&gt; var wrapper = document.getElementsByClassName('wrapper')[0], content = document.getElementsByClassName('content')[0], box = document.getElementsByClassName('box')[0]; document.addEventListener('click', function() &#123; console.log('this is document'); &#125;, false); document.documentElement.addEventListener('click', function() &#123; console.log('this is HTML'); &#125;, false); document.body.addEventListener('click', function() &#123; console.log('this is body'); &#125;, false); wrapper.addEventListener('click', function() &#123; console.log('red'); &#125;, false); content.addEventListener('click', function() &#123; console.log('green'); &#125;, false); box.addEventListener('click', function() &#123; console.log('orange'); &#125;, false);&lt;/script&gt; 不是所有的事件都支持冒泡，那有哪些事件是支持事件冒泡的 H5 还定义了一些新事件： media相关事件，都不冒泡 drag相关事件 dragstart 、 drag 、 dragenter 、 dragexit 、 dragleave 、 dragover 、 drop 、 dragend 均冒泡 History相关事件：popstate，hashchange 冒泡（从window开始……所以意义在哪里），pagetransition不冒泡 事件捕获结构上(非视觉上)嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素(事件源元素)。(自底向上) 事件捕获的触发条件 只有用 addEventListener 方法绑定的事件处理函数，才存在事件捕获，触发事件捕获的条件是，将 addEventListener方法中的第三个参数改为 true 理解事件捕获的过程 12345678910111213141516171819202122232425262728293031323334// head&lt;style type="text/css"&gt; .wrapper &#123; width: 300px; height: 300px; background-color: red; &#125; .content &#123; width: 200px; height: 200px; background-color: green; &#125; .box &#123; width: 100px; height: 100px; background-color: orange; &#125; // body&lt;/style&gt; var wrapper = document.getElementsByClassName('wrapper')[0], content = document.getElementsByClassName('content')[0], box = document.getElementsByClassName('box')[0]; wrapper.addEventListener('click', function() &#123; console.log('wrapper'); &#125;, true); content.addEventListener('click', function() &#123; console.log('content'); &#125;, true); box.addEventListener('click', function() &#123; console.log('box'); &#125;, true);&lt;/script&gt; 上面代码的执行效果： 点击橘色区域打印：wrapper、content、box 点击绿色区域打印：wrapper、content 点击红色区域打印：wrapper 从打印结果上来看，点击不同区域打印的内容与事件冒泡打印的内容是相同的，不同的是它们的顺序正好是相反的，这也正是冒泡与捕获这两种事件模型的区别所在。以上面的代码为例解释事件捕获的过程：点击橘色区域，触发box的 “点击” 事件，因为box所绑定的事件的事件模型是捕获，所以从document开始，向下一层一层的捕获这个 “点击” 事件，直到wrapper这一层，有相应的事件处理函数，响应了这个点击事件，content层同理。(这里说事件捕获从document开始不是很准确，暂且理解这个过程，准确理解在后面的事件流中会提到) 事件捕获中的 “事件源” 事件捕获中的 ”事件源“ 不参与事件的捕获，事件源是捕获的发起者，但它本身不执行捕获操作(简单说就是自己不会捕获自己)，它只是单纯的执行本身的事件处理函数。 详细理解看后面的事件流，样例与 “事件流” 的样例一起出 兼容性 IE9以下版本浏览器不支持事件捕获 事件流 一个完整的事件流是从 window 开始，最后回到 window 的过程 事件流被分为三个阶段(1~5)捕获过程、(5~6)目标过程、(6~10)冒泡过程 事件流各阶段的执行顺序 捕获过程 —&gt; 目标过程 —&gt; 冒泡过程 以样例说明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// head&lt;style type="text/css"&gt; .wrapper &#123; width: 300px; height: 300px; background-color: red; &#125; .content &#123; width: 200px; height: 200px; background-color: green; &#125; .box &#123; width: 100px; height: 100px; background-color: orange; &#125;&lt;/style&gt; // body&lt;div class="wrapper"&gt; &lt;div class="content"&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var wrapper = document.getElementsByClassName('wrapper')[0], content = document.getElementsByClassName('content')[0], box = document.getElementsByClassName('box')[0]; wrapper.addEventListener('click', function() &#123; console.log('wrapperBubble'); &#125;, false); content.addEventListener('click', function() &#123; console.log('contentBubble'); &#125;, false); box.addEventListener('click', function() &#123; console.log('boxBubble'); &#125;, false); wrapper.addEventListener('click', function() &#123; console.log('wrapper'); &#125;, true); content.addEventListener('click', function() &#123; console.log('content'); &#125;, true); box.addEventListener('click', function() &#123; console.log('box'); &#125;, true);&lt;/script&gt; 点击橘色区域(box)，打印结果如下 wrapper content boxBubble box contentBubble wrapperBubble 整体上来看，打印结果与 捕获—目标—冒泡 的执行顺序一致，但是其中box和boxBubble的顺序好像有些奇怪，为什么不是先box然后才boxBubble呢？ 描述一下整个事件流的过程： 捕获阶段：首先window会捕获到事件，之后document、documentElement、body会捕获到，然后是在body中的DOM元素一层一层的捕获到事件，有wrapper、content 目标阶段：真正点击的元素box的事件发生了两次(因为box既在捕获阶段绑定了事件，又在冒泡阶段绑定了事件)。这里有一点要注意，目标阶段不属于捕获阶段，也不属于冒泡阶段，所以出于目标阶段的元素，它事件的执行顺序不是按照先捕获后冒泡的顺序，而是按照该元素事件绑定的顺序执行的，先绑定的那个事件就执行哪个事件 冒泡阶段：与捕获阶段的顺序相反，一步一步冒泡到window 解释刚才提出的问题： ​ 因为box的事件执行处于目标阶段，所以要按照目标阶段的执行顺序谁先绑定谁先执行，box先绑定的冒泡事件，所以先执行冒泡后执行捕获 思考：如果不用 addEventListener 的方法给元素绑定事件，用其他方法给元素绑定的事件在整个事件流的哪一个阶段执行呢？ 1234567891011121314151617181920212223242526272829// 标签结构以及样式和上一个样例一样，这里不再贴出，只贴出script中的代码&lt;script type="text/javascript"&gt; var wrapper = document.getElementsByClassName('wrapper')[0], content = document.getElementsByClassName('content')[0], box = document.getElementsByClassName('box')[0]; wrapper.onclick = function() &#123; console.log('wrapper onclick'); &#125; wrapper.addEventListener('click', function() &#123; console.log('wrapperBubble'); &#125;, false); content.addEventListener('click', function() &#123; console.log('contentBubble'); &#125;, false); box.addEventListener('click', function() &#123; console.log('boxBubble'); &#125;, false); wrapper.addEventListener('click', function() &#123; console.log('wrapper'); &#125;, true); content.addEventListener('click', function() &#123; console.log('content'); &#125;, true); box.addEventListener('click', function() &#123; console.log('box'); &#125;, true);&lt;/script&gt; 点击box后的打印结果： wrapper content boxBubble box contentBubble wrapper onclick wrappeBubble 由打印结果可知，用onclick方法绑定的事件处理函数，在事件冒泡阶段执行 取消冒泡、阻止默认事件取消冒泡有时候我们不需要事件冒泡这一功能，只要求事件源响应相应的事件，那就要取消事件源的冒泡 首先引入一个事件对象的概念(简单引入，后面细讲) 对于事件处理函数function() {} 我们可以给他传递一个形参e，这个e就是要绑定的这个事件的对象，这个事件对象内有一些属性和方法可以帮助我们更好操作目标对象 123document.addEventListener('click', function(e) &#123; console.log('e');&#125;, false); e.stopPropagation() W3C规定的标准的取消冒泡(和捕获)的方法，IE9以下不兼容 12345678910111213&lt;div style="width:100px;height:100px;background-color:red"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; document.addEventListener('click', function(e) &#123; console.log('This is document!'); &#125;, false); div.addEventListener('click', function(e) &#123; e.stopPropagation(); this.style.backgroundColor = 'green'; &#125;, false);&lt;/script&gt; e.cancelBubble = true IE取消事件冒泡的方法，现代主流浏览器也都支持 12// 假装有测试代码// 把上一个测试代码的 e.stopPropagation() 改成 e.cancelBubble = true 即可 阻止默认事件浏览器会自带一些默认的事件，比如点击a标签跳转、右键出菜单等，如果我们不想让这些默认的事件生效，就要阻止这些默认事件 return false 在事件处理函数的内部，将false当做返回值返回，这种方法只针对以句柄方式绑定的事件处理函数，兼容行很好 12345&lt;script type="text/javascript"&gt; window.oncontextmenu = function() &#123; return false; &#125;&lt;/script&gt; event.preventDefault() W3C标准阻止默认事件的方法，IE9以下不兼容 12345&lt;script type="text/javascript"&gt; window.addEventListener('contextmenu', function(event) &#123; event.preventDefault(); &#125;, false);&lt;/script&gt; event.returnValue = false IE阻止默认事件的方法，现代主流浏览器也都支持 12345&lt;script type="text/javascript"&gt; document.attachEvent('oncontextmenu', function(event) &#123; event.returnValue = false; &#125;);&lt;/script&gt; 事件对象DOM中的事件对象兼容DOM的浏览器会将一个event对象传入到事件处理函数中。无论指定事件处理程序时使用什么方法(DOM0级或者DOM2级)，都会传入event对象 简单了解DOM0级事件和DOM2级事件 DOM0级事件 标签内写onclick事件 在JS中写onclick = function() {} DOM2级事件 addEventListerner &amp;&amp; removeEventListener DOM2级事件包含完整的事件流(捕获过程、目标过程、冒泡过程) 12345678910111213&lt;div class='sample1' style="width:100px;height:100px;background-color:red"&gt;&lt;/div&gt;&lt;div class="sample2" style="width:100px;height:100px;background-color:green"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divSample1 = document.getElementsByClassName('sample1')[0], divSample2 = document.getElementsByClassName('sample2')[0]; divSample1.onclick = function (e)&#123; console.log(e); &#125; divSample2.addEventListener('click', function(e) &#123; console.log(e); &#125;, false); &lt;/script&gt; 只有在事件处理程序执行期间，event对象才会存在 event对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性方法也不一样。但是所有的事件都会有下表中列出的成员 IE事件对象与访问DOM中的event对象不同，要访问IE中的event对象有几种不同的方式，取决于指定事件处理程序的方法。在使用DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在；使用attachEvent方法添加的，会有一个event对象作为参数被传入事件处理函数中，可以通过window对象来访问event，就像DOM0级方法一样，也可以直接访问event对象 DOM0级方法添加事件处理函数，event对象作为window对象的一个属性存在是针对IE9以下版本的浏览器，IE9+中，这种情况可以直接访问event 1234567891011121314&lt;div class='sample1' style="width:100px;height:100px;background-color:red"&gt;&lt;/div&gt;&lt;div class="sample2" style="width:100px;height:100px;background-color:green"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divSample1 = document.getElementsByTagName('div')[0], divSample2 = document.getElementsByTagName('div')[1]; divSample1.onclick = function (e)&#123; // e = window.event; console.log(e); &#125; divSample2.attachEvent('onclick', function(e) &#123; console.log(e); &#125;);&lt;/script&gt; IE8文档模式下divSample1的打印结果是：undefined IE9文档模式下divSample1的打印结果是：事件对象 在IE8文档模式下，使用DOM0方式绑定事件，要用window.event访问事件对象(代码中注释部分) IE的event对象同样也包含与创建它的事件相关的属性和方法。其中很多属性和方法都有对应的或者相关的DOM属性和方法。与DOM的event对象一样，这些属性和方法也会因为事件类型的不同而不同，但所有事件对象都会包含下表所列的属性和方法 兼容性方法var e = event || window.event 12345678&lt;div class="sample" style="width:100px;height:100px;background-color:red"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; div.onclick = function(event) &#123; var e = event || window.event; console.log(e); &#125;&lt;/script&gt; 事件源对象因为事件流的存在，有时会有多个对象相应某一个事件(比如事件冒泡)，那我想找到触发这个事件的对象(即事件源对象)，可以通过事件对象的某些属性 event.target 火狐独有的(火狐只有这个属性) event.srcElement IE9以下独有的(IE9+也是两个属性都有) chrome浏览器有以上两个属性 兼容性方法 var target = event.target || event.srcElement; 123456789&lt;div class="sample" style="width:100px;height:100px;background-color:red"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; div.onclick = function(event) &#123; var e = event || window.event; var target = e.target || e.srcElement; console.log(target); &#125;&lt;/script&gt; 事件委托通俗的讲，事件委托就是把一个元素响应事件的函数委托到另一个元素上。一般来说，会把一个或者一组元素的事件处理函数委托到他的父层或者更外层的元素上，当事件源上触发某一事件后，根据事件冒泡机制，事件会冒泡到被委托的元素上，进而响应这一事件 优点 减少内存消耗 把一组元素的事件处理函数委托到他们的父元素上，这样这一组元素不用每一个都绑定响应的事件处理函数，只需要被委托的元素绑定该处理函数，减少内存消耗，提高程序的执行效率 动态绑定事件 当委托元素的个数变化时，不需要修改程序，因为它们都会将事件冒泡给被委托元素 demo12345678910111213141516// 要求点击哪个li，打印相应li中的内容&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt; var demo = document.getElementsByTagName('ul')[0]; demo.addEventListener('click', function(e) &#123; var event = e || window.event, target = event.target || event.srcElement; console.log(target.innerHTML); &#125;, false);&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件绑定、解除]]></title>
    <url>%2F2018%2F05%2F18%2Fa29_javascript%2F</url>
    <content type="text"><![CDATA[为事件绑定处理函数 绑定思路：给指定元素，绑定指定类型的，指定处理函数 elem.onxxx = function() {} 兼容性很好，但是一个元素的同一个事件句柄上只能绑定一个处理函数 1234567&lt;div style="width:100px;height:100px;background-color:red;"&gt;&lt;/div&gt;&lt;script type="text/JavaScript"&gt; var div = document.getElementsByTagName('div')[0]; div.onclick = function () &#123; console.log('a'); &#125;&lt;/script&gt; 基本等同于写在HTML行间 如果事件绑定写在行间，那么不需要写 function，直接写函数体 1&lt;div style="width:100px;height:100px;background-color:red;" onclick="console.log('a')"&gt;&lt;/div&gt; 这种绑定方法叫做 “句柄” 的绑定方法 IE浏览器不能通过句柄的方式给 document 绑定事件处理函数 其他方式都可以绑定，句柄的方式就无法绑定 1234567891011121314// 注释部分要在IE11以下的浏览器中调试，IE11和现代主流浏览器不支持attachEvent方法&lt;script type="text/javascript"&gt; document.onclick = function() &#123; console.log('a'); &#125; // document.attachEvent('onclick', function()&#123; // console.log('b'); // &#125;); document.addEventListener('click', function() &#123; console.log('c'); &#125;, false);&lt;/script&gt; elem.addEventListener(type, fn, true/false) 第一个参数 ‘type’ 代表事件类型，直接写类型，不加 ’on’ // ‘click’ 第二个函数 ’fn‘ 代表处理函数，可以是匿名函数或者函数引用 12345678910111213141516&lt;div class="sample1" style="width:100px;height:100px;background-color:red"&gt;&lt;/div&gt;&lt;div class="sample2" style="width:100px;height:100px;background-color:green"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; // 第二个参数是匿名函数 var divSample1 = document.getElementsByClassName('sample1')[0]; divSample1.addEventListener('click', function () &#123; console.log('red'); &#125;, false); // 第二个参数是函数引用 var divSample2 = document.getElementsByClassName('sample2')[0]; divSample2.addEventListener('click', demo, false); function demo() &#123; console.log('green'); &#125;&lt;/script&gt; 第三个参数 ‘true/false’ 这个参数与 ‘事件捕获’ 与 ‘事件冒泡’ 相关，后面会提到 IE9 以下不兼容 以下代码在IE8浏览器中运行，结果打印为 ‘undefined’ 12345&lt;div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; console.log(div.addEventListener);&lt;/script&gt; 可以为一个事件绑定多个不同的处理函数 第二个参数是匿名函数 123456789var divSample1 = document.getElementsByClassName('sample1')[0];divSample1.addEventListener('click', function() &#123; console.log('red');&#125;, false); divSample1.addEventListener('click', function() &#123; this.style.backgroundColor = 'green'; console.log('to green');&#125;, false); 点进红色区域后，红色区域变成绿色，控制台输出是： red to green 第二个参数是函数引用 1234567891011121314&lt;div class="sample1" style="width:100px;height:100px;background-color:red"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divSample1 = document.getElementsByClassName('sample1')[0]; divSample1.addEventListener('click', demo, false); divSample1.addEventListener('click', demo, false); function demo() &#123; console.log('red'); &#125; function demo() &#123; this.style.backgroundColor = 'green'; console.log('to green'); &#125;&lt;/script&gt; 效果： 点击红色区域后，红色区域变绿，控制台输出： to green 问题： 可以发现，用addEventListener方法绑定多个处理函数时，如果第二个参数为匿名函数，则可以实现多绑定；而如果第二个参数为同一个函数的函数引用时，则不能实现多绑定的效果——后绑定的函数覆盖了先绑定函数的效果，这是为什么呢？ 原因： 从定义上分析：一个事件可以绑定多个不同的处理函数，这里的重点是 ‘不同的’，即如果要实现一个事件绑定多个处理函数，那么被绑定的这些处理函数应该是不同的；对于匿名函数来说，每一个匿名函数都是不同的，而对于函数引用来讲，这个函数引用指向同一个函数，所以多次调用，前面的语句会被后面的语句覆盖 elem.attachEvent(type, fn) 第一个参数 ‘type’ ‘on’ + 事件类型 // ‘onclick’ 第二个参数 fn 事件处理函数 兼容性 IE10 及以下独有，chrome、Firefox、IE11等不支持 一个事件可以绑定多个处理函数 第二个参数为匿名函数 123456789101112131415161718192021document.attachEvent('onclick', function() &#123; console.log('1');&#125;);document.attachEvent('onclick', function() &#123; console.log('2');&#125;);document.attachEvent('onclick', function() &#123; console.log('3');&#125;);document.attachEvent('onclick', function() &#123; console.log('4');&#125;);document.attachEvent('onclick', function() &#123; console.log('5');&#125;);document.attachEvent('onclick', function() &#123; console.log('6');&#125;);document.attachEvent('onclick', function() &#123; console.log('7');&#125;); IE9、IE10下的打印结果：1、2、3、4、5、6、7 IE8及以下的打印结果：乱序，没有规律 第二个参数为函数引用 12345document.attachEvent('onclick', demo);document.attachEvent('onclick', demo);function demo() &#123; console.log('demo');&#125; IE9、IE10的打印结果：demo IE8及以下的打印结果：demo、demo 注意：IE8及以下的浏览器，即使使用同一个处理函数绑定事件句柄，效果不会被覆盖，函数被绑定 ​ 多少次，就会执行多少次该事件 事件处理函数的运行环境(this指向) 方法 this指向 elem.onxxx elem elem.addEventListener elem elem.attachEvent window 12345678910111213// 前两个方法的测试代码&lt;div class="sample1" style="width:100px;height:100px;background-color:red"&gt;sample1&lt;/div&gt;&lt;div class="sample2" style="width:100px;height:100px;background-color:green"&gt;sample2&lt;/div&gt;&lt;script type="text/javascript"&gt; var divSample1 = document.getElementsByClassName('sample1')[0]; var divSample2 = document.getElementsByClassName('sample2')[0]; divSample1.onclick = function() &#123; console.log(this); &#125; divSample2.addEventListener('click', function() &#123; console.log(this); &#125;, false);&lt;/script&gt; 123456// 第三种方法的测试代码（IE9文档模式下调试）&lt;script type="text/javascript"&gt; document.attachEvent('onclick', function() &#123; console.log(this); &#125;)&lt;/script&gt; 问题： IE10及以下支持的这个 attachEvent 绑定处理函数方法，this指针不是指向调用它的DOM元素，而是指向window，但是实际操作中，使用this来操作当前DOM元素的情况比较多，那么怎么解决这个问题呢？ 思路： 既然这个方法的this是指向window的，如果要想让在处理函数的函数体中使this指向当前DOM元素，那就不能把处理函数的函数体直接写在attachEvent方法的function() {}中，而是把函数体写在另一个函数中，通过调用这个方法，并改变其this指向，来实现该想法 123456789101112&lt;div style="width:100px;height:100px;background-color:red"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; div.attachEvent('onclick', function() &#123; // 调用处理函数，并使该处理函数的this指针指向指定DOM元素 handle.call(div); &#125;); function handle() &#123; // 处理函数函数体 console.log(this); &#125;&lt;/script&gt; 解除事件的处理函数 解除绑定思路：给指定元素，解除指定类型的，指定处理函数 事件处理函数 解除方法 备注 elem.onxxx elem.onxxx = false / null / ‘’ elem.addEventListener elem.removeEventListener(type, fn, false) fn为函数引用 elem.attachEvent elem.detachEvent(‘on’ + type, fn) fn为函数引用 因为第二、三个方法解除绑定都需要函数引用(函数名)，所以如果绑定处理函数时，第二个参数为匿名函数，则无法解除该事件的处理函数绑定 1234567891011121314151617// 下面两行注释掉的代码即为解除函数绑定的方法&lt;div class="sample1" style="width:100px;height:100px;background-color:red;"&gt;sample1&lt;/div&gt;&lt;div class="sample2" style="width:100px;height:100px;background-color:green;"&gt;sample2&lt;/div&gt;&lt;script type="text/javascript"&gt; var divSample1 = document.getElementsByClassName('sample1')[0], divSample2 = document.getElementsByClassName('sample2')[0]; divSample1.onclick = function () &#123; console.log('red'); &#125; // divSample1.onclick = null; divSample2.addEventListener('click', demo, false); function demo() &#123; console.log('green'); &#125; // divSample2.removeEventListener('click', demo); &lt;/script&gt; 123456789// IE9文档模式下调试通过// 下面注释部分即为解除绑定方法&lt;script type="text/javascript"&gt; document.attachEvent('onclick', demo); function demo() &#123; console.log('还没有解除'); &#125; // document.detachEvent('onclick', demo);&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时器练习]]></title>
    <url>%2F2018%2F05%2F16%2Fa28_javascript%2F</url>
    <content type="text"><![CDATA[简单计时器 具体功能：页面中有两个显示事件的模块，一个代表分钟，另一个代表秒；要求初始状态均为0，秒数开始增加，60秒后分钟数加1，秒数重新置0，3分钟停止 12345678910111213141516171819Minutes&lt;input type="text" value='0' readonly&gt;Seconds&lt;input type="text" value='0' readonly&gt;&lt;script type="text/javascript"&gt; var minute = document.getElementsByTagName('input')[0], second = document.getElementsByTagName('input')[1], timer; timer = setInterval(function () &#123; if (minute.value == 3) &#123; clearInterval(timer); &#125; else &#123; if (second.value == 59) &#123; second.value = 0; minute.value++; &#125; else &#123; second.value++; &#125; &#125; &#125;, 1000);&lt;/script&gt; 自动阅读器 具体功能：页面中有两个固定的按钮，一个用来开始阅读(点击后自动滑屏)，一个用来停止阅读(点击后停止滑屏) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// head&lt;style type="text/css"&gt; .start, .stop &#123; position: fixed; width: 100px; height: 100px; border-radius: 50%; opacity: 0.8; text-align: center; line-height: 100px; font-weight: bold; font-size: 20px; color: black; cursor: pointer; &#125; .start &#123; bottom: 200px; right: 50px; background-color: orange; &#125; .stop &#123; bottom: 70px; right: 50px; background-color: green; &#125;&lt;/style&gt; // body&lt;p&gt;自己填充足够的内容&lt;/p&gt;&lt;div class="start"&gt;start&lt;/div&gt;&lt;div class="stop"&gt;stop&lt;/div&gt;&lt;script type="text/javascript"&gt; var start = document.getElementsByClassName('start')[0], stop = document.getElementsByClassName('stop')[0], timer, key = true; start.onclick = function() &#123; if (key) &#123; timer = setInterval(function() &#123; window.scrollBy(0, 10); &#125;, 100); key = false; &#125; &#125; stop.onclick = function() &#123; clearInterval(timer); key = true; &#125; &lt;/script&gt; 这里如果不加key来控制start的话，多次点击start会加速下滑，而且此时再点stop无法停下，因为第二次点击start获取的timer值总会覆盖上一次的timer值，使得被覆盖掉的timer无法被清除 让方块运动起来 具体描述：点击方块，方块开始水平运动，再次点击，方块停止运动 12345678910111213141516171819&lt;div style="width:100px;height:100px;background-color:green;position:absolute;"&gt;&lt;/div&gt;&lt;script type='text/javascript'&gt; var div = document.getElementsByTagName('div')[0], timer, key = true; div.onclick = function() &#123; if (key) &#123; this.style.backgroundColor = 'orange'; timer = setInterval(function() &#123; div.style.left = parseInt(window.getComputedStyle(div, null).left) + 2 + 'px'; &#125;, 10); key = false; &#125; else &#123; clearInterval(timer); div.style.backgroundColor = 'green'; key = true; &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Date对象、计时器]]></title>
    <url>%2F2018%2F05%2F16%2Fa27_javascript%2F</url>
    <content type="text"><![CDATA[Date对象的常用方法1. Date()返回当前的日期和时间 1console.log(Date()); 2. getDate()从Date对象返回一个月中的某一天(1~31) 1var date = new Date().getDate(); 3. getDay()从Date方法返回一周中的某一天(0~6，周日是0) 1var date = new Date().getDay(); 4. getMonth()从Date对象返回月份(0~11，一月是0) 1var date = new Date().getMonth(); 5. getFullYear() 从Date对象以四位数字返回年份 返回年份一开始使用的是 getYear() 这个方法，但是这个方法会造成 ‘千年重’的问题 JavaScript是上世纪诞生的，当时对于年份的称谓是80年、90年这样，没有考虑跨世纪的问题，所以当时年份仅仅返回两位数字来表示，这样到了新的世纪以后就无法表示了，所以现在不使用这个方法了，虽然这个方法现在已经不仅仅是返回两位数了，但也不能直观的表示年份，所以不使用这个方法 1var date = new Date().getFullYear(); 6. getHours()返回Date对象的小时(0~23) 1var date = new Date().getHours(); 7. getMinutes()返回Date对象的分钟(0~59) 1var date = new Date().getMinutes(); 8. getSeconds()返回Date对象的秒(0~59) 1var date = new Date().getSeconds(); 9. getMilliseconds()返回Date对象的毫秒(0~999) 1var date = new Date().getMilliseconds(); 10. getTime() 时间戳 返回1970年1月1日（计算机纪元时间）至今的毫秒数 求某一段时间的事件差可以用这个方法 利用时间戳的唯一性可以唯一标记某一个时间 1var date = new Date().getTime(); 11. setDate()设置Date对象中月的某一天(1~31) 12var date = new Date();date.setDate(1); 12. setMonth()设置Date对象中的某一个月(0~11) 12var date = new Date();date.setMonth(0); // 一月 13. setFullYear()设置Date对象中的某一年(4为数字) 12var date = new Date();date.setFullYear(1997); 14. setHours()设置Date对象中的某个小时(0~23) 12var date = new Date();date.setHours(23); 15. setMinutes()设置Date对象的某一分钟(0~59) 12var date = new Date();date.setMinutes(59); 16. setSecons()设置Date对象的某一秒(0~59) 12var date = new Date();date.setSeconds(0); 17. setTime()12var date = new Date();date.setTime(1000000000000); 18. toString()12var date = new Date();var str = date.toString(); 19. toDateString()12var date = new Date();var str = date.toDateString(); JS定时器以下的所有方法都是window上的方法，内部的指针指向window 1. setInterval()1234var time = 1000;setInterval(function() &#123; console.log('a');&#125;, time); 功能 每隔一段设定的时间(time)，执行一次函数(function) 时间间隔 time一旦确定放到setInterval中去执行的时候，这个值就不会再改变了，后面再修改time也不会影响到这个时间间隔 这个时间间隔是很准确的么？ 123456789&lt;script type="text/javascript"&gt; var firstTime = new Date().getTime(), lastTime; setInterval(function() &#123; lastTime = new Date().getTime(); console.log(lastTime - firstTime); firstTime = new Date().getTime(); &#125;, 1000);&lt;/script&gt; 通过打印结果来看，这个时间差是不太精确的，具体原因与js的执行机制以及setInterval的内部原理有关 可参考文章：https://jeffjade.com/2016/01/10/2016-01-10-javaScript-setInterval 另一个用法 1setInterval('str', time); 如果第一个参数是字符串的话，setInterval会执行引号内的代码，但是一般不这样用 2. clearInterval() 功能：让循环停下来 原理：setInterval()方法有一个返回值，这个返回值可以唯一标识一个计时器，通过这个标识可以让setInterval停下来 1234567&lt;script type="text/javascript"&gt; var timer; timer = setInterval(function() &#123; console.log('a'); &#125;, 1000); clearInterval(timer);&lt;/script&gt; 3. setTimeout()隔一段时间后执行一个函数，且只执行一次 12345&lt;script type="text/javascript"&gt; setTimeout(function () &#123; console.log('a'); &#125;, 1000);&lt;/script&gt; 4. clearTimeout()1234567&lt;script type="text/javascript"&gt;var timer; timer = setTimeout(function () &#123; console.log('a'); &#125;, 1000); clearTimeout(timer);&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM练习]]></title>
    <url>%2F2018%2F05%2F15%2Fa26_javascript%2F</url>
    <content type="text"><![CDATA[功能：封装一个方法，要求返回给定元素节点下的所有子元素节点（不使用children） 要求：原型链上编程 具体描述：及自己写一个方法，实现children的功能 123456789101112131415Element.prototype.myChildren = function () &#123;var tmpObj = &#123; length: 0, push: Array.prototype.push, splice: Array.prototype.splice&#125;var nodes = this.childNodes, len = nodes.length;for (var i = 0; i &lt; len; i++) &#123; if (nodes[i].nodeType == 1) &#123; tmpObj.push(nodes[i]); &#125;&#125;return tmpObj;&#125; 功能：遍历元素节点树 要求：原型链上编程 具体描述：要求打印每一个元素节点以及层级关系 思路：可以利用广度优先遍历 12 功能：封装函数，返回元素e的第n层祖先元素节点 要求：原型链上编程 1234567Element.prototype.ancestor = function (n) &#123; var elemNode = this; while (n-- &amp;&amp; elemNode) &#123; elemNode = elemNode.parentElement; &#125; return elemNode;&#125; 功能：封装函数，返回元素e的第n个兄弟元素节点 要求：在原型链上编程 具体描述：n为正，返回后面的兄弟元素节点；n为负，返回前面的兄弟元素节点；n为0，返回自身 12345678Element.prototype.sibling = function (n) &#123; var elemNode = this, loop = Math.abs(n); while (loop-- &amp;&amp; elemNode) &#123; elemNode = n &gt; 0 ? elemNode.nextElementSibling : elemNode.previousElementSibling; &#125; return elemNode;&#125; 功能：封装函数，判断给定元素节点下有没有元素子节点 要求：原型链上编程，不能使用children 12345678910Element.prototype.hasElementChild = function () &#123; var nodes = this.childNodes, len = nodes.length; for (var i = 0; i &lt; len; i++) &#123; if (nodes[i].nodeType == 1) &#123; return true; &#125; &#125; return false;&#125; 给文档中的所有标签添加一个 thisname 属性，属性值为他们的标签名 1234567function addArr() &#123; var arr = document.getElementsByTagName('*'), len = arr.length; for (var i = 0; i &lt; len; i++) &#123; arr[i].setAttribute('thisname', arr[i].nodeName); &#125;&#125; 小技巧：用通配符选择文档中所有的标签 功能：使用标准的DOM方法或属性，实现以下DOM结构 123&lt;div class="example"&gt; &lt;p class="slogan"&gt;sth&lt;/p&gt;&lt;/div&gt; 123456789101112&lt;script type="text/javascript"&gt; var div = document.createElement('div'), p = document.createElement('p'), script = document.getElementsByTagName('script')[0]; div.className = 'example'; p.className = 'slogan'; p.innerText = 'text'; div.appendChild(p); document.body.insertBefore(div, script);&lt;/script&gt; 功能：封装函数 insertAfter()， 功能类似 insertBefore() 要求： 在原型链上编程 忽略老版本浏览器的兼容性问题 1234567Element.prototype.insertAfter = function (newNode, originNode) &#123; if (!originNode.nextSibling) &#123; this.appendChild(newNode); &#125; else &#123; this.insertBefore(newNode, originNode.nextSibling); &#125;&#125; 功能：封装函数，功能是将节点内部的节点顺序逆序 要求：在原型链上编程 12345678Element.prototype.reverse = function () &#123; var nodes = this.childNodes, len = nodes.length, startLoc = len - 2; for (var i = startLoc; i &gt;= 0; i--) &#123; this.appendChild(nodes[i]); &#125;&#125; 功能：封装一个函数，求元素相对于文档的坐标 要求：在原型链上编程 1234567891011121314Element.prototype.getElementPosition = function () &#123; var w = 0, h = 0, node = this; while (node) &#123; w += node.offsetLeft; h += node.offsetTop; node = node.offsetParent; &#125; return &#123; w: w, h: h &#125;&#125; 功能：封装一个函数解决 getElementsByClassName() 的兼容性 要求：在原型链上编程 注意：因为 getElementsByClassName() 在 Document 和 在Element上均有定义，所以兼容性方法也要分别在这两个原型链上 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// Document原型链上Document.prototype.getByClassName = function(className) &#123; if (this.getElementsByClassName) &#123; return this.getElementsByClassName(className); &#125; else &#123; // 首先用兼容性较好的方法把所有标签都取出来 var allDom = this.getElementsByTagName('*'), allDomArr = Array.prototype.slice.call(allDom, 0), ansArr = []; // 判断该dom节点的className是否满足要求 function isTrue(dom) &#123; // 用正则表达式将所有的连续空格替换为一个空格，并将首尾的空格去掉 var oClassName = dom.className, reg = /\s+/g; oClassName = oClassName.replace(reg, ' ').trim(); // 将字符串以空格为分隔符拆成数组 var oClassNameArr = oClassName.split(' '), oClassNameArrLen = oClassNameArr.length; // 满足要求则返回true for (var i = 0; i &lt; oClassNameArrLen; i++) &#123; if (oClassNameArr[i] == className) &#123; return true; &#125; &#125; return false; &#125; allDomArr.forEach(function(elem, index) &#123; if (isTrue(elem)) &#123; // 满足要求就添加到新的数组中 ansArr.push(elem); &#125; &#125;); return ansArr; &#125;&#125; // Element原型链上Element.prototype.getByClassName = function(className) &#123; if (this.getElementsByClassName) &#123; return this.getElementsByClassName(className); &#125; else &#123; var allDom = this.getElementsByTagName('*'), allDomArr = Array.prototype.slice.call(allDom, 0), ansArr = []; function isTrue(dom) &#123; var oClassName = dom.className, reg = /\s+/g; oClassName = oClassName.replace(reg, ' ').trim(); var oClassNameArr = oClassName.split(' '), oClassNameArrLen = oClassNameArr.length; for (var i = 0; i &lt; oClassNameArrLen; i++) &#123; if (oClassNameArr[i] == className) &#123; return true; &#125; &#125; return false; &#125; allDomArr.forEach(function(elem, index) &#123; if (isTrue(elem)) &#123; ansArr.push(elem); &#125; &#125;); return ansArr; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM续]]></title>
    <url>%2F2018%2F05%2F14%2Fa25_javascript%2F</url>
    <content type="text"><![CDATA[查看滚动条位置W3C 标准方法 window.pageXOffset / window.pageYOffset IE9 以下版本方法 document.body.scrollLeft / document.body.scrollTop document.bodyElement.scrollLeft / document.bodyElement.scrollTop IE9以下版本的浏览器，不支持 w3c 的标准方法，只能用这两种方法查看滚动条位置，但是这两种方法兼容性也很混乱，为了解决这个兼容性混乱的问题，对于这两种方法，一般使用两者之和，因为当一个方法有值时，另外一个方法的值一定是0 1234// 查看x轴方向的滚动条位置document.body.scrollLeft + document.documentElement.scrollLeft// 查看y轴方向的滚动条位置document.body.scrollTop + document.documentElement.scrollTop 调试的时候可以先在页面中加一个大的盒子，让滚动条显示出来 1&lt;div style="width:2000px;height:1000px"&gt;&lt;/div&gt; 兼容性方法为了解决不同版本浏览器的兼容性问题，封装一个查看滚动条位置的兼容性方法 12345678910111213function getScrollOffset() &#123; if (window.pageXOffset) &#123; return &#123; x: window.pageXOffset, y: window.pageYOffset &#125; &#125; else &#123; return &#123; x: document.body.scrollLeft + document.documentElement.scrollLeft, y: document.body.scrollTop + document.documentElement.scrollTop &#125; &#125;&#125; 让滚动条滚动让滚动条滚动到指定位置 window.scroll(x, y) window.scrollTo(x, y) 滚动到指定位置，重复的操作是不累加的 让滚动条滚动了指定距离window.scrollBy(x, y) 滚动了指定的距离，重复操作是累加的 查看可视窗口尺寸W3C 标准方法window.innerWidth / window.innerHeight 现在网站的标准宽度一般是 1440px 对于同一个大小的浏览器窗口，如果页面的缩放比例是不同的，那么他的可视区的大小也是不同的 即把一个浏览器窗口固定大小，在页面缩放比例 100% 下求得一个 window.innerWidth，在缩放比例 150%下求得一个 window.innerWidth，后者的值小于前者的值。相当于是拿放大镜看同一块区域，看到的内容肯定要少了 IE9 以下版本方法IE9 以下浏览器不兼容 w3c 的方法，使用以下两种方法 标准模式下使用 document.documentElement.clientWidth / document.documentElement.clientHeigth 非标准模式下使用 document.body.clientWidth / document.body.clientHeight 标准模式、非标准模式(怪异模式 / 混杂模式) 这里的模式说的是浏览器的渲染模式，如果把页面中的&lt;!doctype html&gt;去掉，就进入了怪异模式，加上就是标准模式怪异模式是为了解决浏览器向下兼容的问题: 浏览器升级的过程中，会更新一些语法规则，这些准则在标准模式下是不兼容的，那想象这样一个场景，一个工程师在IE8版本写的一个页面，当更新到IE9时，一些语法不兼容的情况下，该怎么去访问这个页面，怪异模式就是为了解决这样的问题，浏览器使用怪异模式渲染的情况下，可以向下兼容几个版本(具体几个版本不同的浏览器是不一样的) 怎么判断浏览器处于标准模式还是非标准模式： 利用 document.compatMode 标准模式下的返回值：’CSS1Compat’ 怪异模式下的返回值：’BACKCompat’ 兼容性方法封装一个解决不同版本浏览器对于查看窗口尺寸兼容性问题的兼容性方法 1234567891011121314151617181920function getViewPortOffset() &#123; if (!window.innerWidth) &#123; return &#123; w: window.innerWidth, h: window.innerHeight &#125; &#125; else &#123; if (document.compatMode == 'CSS1Compat') &#123; return &#123; w: document.documentElement.clientWidth, h: document.documentElement.clientHeight &#125; &#125; else &#123; return &#123; w: document.body.clientWidth, h: document.body.clientHeight &#125; &#125; &#125;&#125; 查看元素尺寸、位置常用方法 dom.offsetWidth / dom.offsetHeight 查看dom元素的宽高 包含padding、border 不包含margin 123456&lt;div style="width:100px;height:100px;background-color:red;border:5px solid black;padding:5px;margin-left:20px"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; console.log(div.offsetWidth); console.log(div.offsetHeight);&lt;/script&gt; dom.offsetLeft / dom.offsetTop 查看元素位置 对于父级没有定位的元素的，返回该元素相对于文档的坐标；对于父级有定位的元素，返回该元素相对于最近的有定位的父级的坐标。（这句话只强调了父级元素有没有定位，和被查看的元素本身有没有定位没有关系） 12345678910&lt;div class="wrapper" style='width:100px;height:100px;background-color:green;'&gt; &lt;div class="inner" style='width:50px;height:50px;background-color:red;'&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divWrapper = document.getElementsByTagName('div')[0]; var divInner = divWrapper.getElementsByTagName('div')[0]; divWrapper.style.position = 'static'; // divWrapper.style.position = 'absolute'; divInner.style.margin = '22px';&lt;/script&gt; 为了测试父级元素有没有定位对位置的影响， 先测试以上代码，然后将 divWrapper.style.position = ‘static’ 注释掉，将原来的注释关闭，再进行测试，观察两次测试的结果 提示：左右margin相加，上下margin合并 查看有定位父级元素 返回最近的有定位的父级，如无，返回body，body.offsetParent 返回 null 不常用方法dom.getBoundingClientRect() 返回一个对象，有top、right、bottom、left、width、height等属性 兼容性很好，只在老版本IE中，height和width属性没有实现 返回结果不是实时的 返回值有时会出现小数 这个方法不常用，了解即可 脚本化CSS读写css属性dom.style 返回值是一个名称为 ‘CSSStyleDeclaration’ 的类数组，这个数组保存了css的所有属性 读写操作的对象是dom元素的 行间样式 在dom元素行间设置的css样式，才会出现在 CSSSstyleDeclararion 类数组的索引属性上；css所有的属性都在这个类数组中，只不过在行间设置的css属性，它才会以索引属性的形式出现在类数组中。 1234567891011// head&lt;style type="text/css"&gt; .demo &#123; opacity: 0.5; &#125;&lt;/style&gt; // body&lt;div class="demo" style='width:100px;height:100px;background-color:red;'&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; console.log(div.style);&lt;/script&gt; 这个demo一共在两个地方设置css样式，但是在head内设置的css样式，并没有在 CSSStyleDeclaration 中以索引属性的形式展示出来；而在demo行间设置的css样式，都展示了出来，说明 dom.style 只能读写 行间样式 读写行间样式 读 div.style.prop 写 div.style.prop = ‘…’ 没有兼容性问题 组合单词变成小驼峰式写法 background-color —&gt; backgroundColor 有些css属性名是js中的关键字或者保留字，用另一种名称进行读写 eg. float —&gt; cssFloat 复合属性需要拆解 eg. background: 1px solid red; ​ —-&gt; ​ backgroundWidth: 1px; backgroundStyle: solid; backgroundColor: red; 现在的语法不拆解也支持，但是建议拆开来写 写入的之必须是字符串格式 dom.style.backgroundColor = ‘green’; JS中可以写入css的方法就这么一个，其他的都只是能够读取，不能写入 查询计算样式window.getComputedStyle(elem, null) 两个参数 元素节点 和 null / 伪元素 属性值 查询到的属性值是元素在浏览器中展现出来的样式的属性值，即这个无论以哪种方式设置的样式，最终展现出来的样式是什么，查询到的就是什么 计算样式只读 window.getComputedStyle(elem, null)[prop] 返回的计算样式都是绝对值，没有相对单位 这里说的绝对值不是数学意义上的那个绝对值，而是说他的返回值都是经过计算的，已经将一些相对单位进行了转换。比如给某元素设置得字体大小是 ‘1em’，用这个方法查询到的字体大小是 ‘16px’ IE9以下不兼容 关于第二个参数 null 这个参数是用来读取伪元素的： window.getComputedStyle(elem, ‘after / before’)[prop] elem.currentStyle 返回一个 CSSSstyleDeclaration 对象 样式只读 elem.currentStyle[prop] 属性值不是绝对值 IE独有的属性 兼容性方法1234567function getStyle(elem, prop) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(elem, null)[prop]; &#125; else &#123; return elem.currentStyle[prop]; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM基本操作]]></title>
    <url>%2F2018%2F05%2F13%2Fa24_javascript%2F</url>
    <content type="text"><![CDATA[创建DOM元素document.createElement()创建元素节点 document.createTextNode()创建文本节点 document.createComment()创建注释结点 document.createDocumentFragment()创建文本碎片结点（以后讲） 123456789&lt;script type="text/javascript"&gt; var divNew = document.createElement('div'); var textNew = document.createTextNode('This is a text'); var commentNew = document.createComment('This is a comment'); document.body.appendChild(divNew); document.body.appendChild(textNew); document.body.appendChild(commentNew); console.log(document.body);&lt;/script&gt; 添加DOM元素parentNode.appendChild() 向父元素节点中插入子节点，任何一个元素节点中都有这个方法 插入顺序：可以把 append 方法比作 push 方法，向末尾插入 1234567891011&lt;div class="parentNode"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divParent = document.getElementsByTagName('div')[0]; var firstText = document.createTextNode('第一个插入的'); var secondText = document.createTextNode('第二个插入的'); var thirdText = document.createTextNode('第三个插入的'); divParent.appendChild(firstText); divParent.appendChild(secondText); divParent.appendChild(thirdText); console.log(divParent);&lt;/script&gt; 将文档中一个元素从一个位置插入到另一个位置，实现的是剪切操作 1234567891011&lt;div class="box1"&gt;&lt;/div&gt;&lt;div class="box2"&gt; &lt;div class="box2Inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divBox1 = document.getElementsByTagName('div')[0]; var divBox2 = document.getElementsByTagName('div')[1]; var divBox2Inner = divBox2.getElementsByTagName('div')[0]; divBox1.appendChild(divBox2Inner); console.log(divBox1);&lt;/script&gt; parentNode.insertBefore(a, b)在父元素下的子节点 b 之前 插入 a 节点 1234567891011&lt;div class="wrapper"&gt; &lt;div class="divOrigin"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divWrapper = document.getElementsByTagName('div')[0]; var divOrigin = divWrapper.getElementsByTagName('div')[0]; var divNew = document.createElement('div'); divNew.className = 'divNew'; divWrapper.insertBefore(divNew, divOrigin); console.log(divWrapper);&lt;/script&gt; 写这个 demo 时有个思考，关于之前提到的 documen.getElementsByTagName() 方法是动态选取元素： divOrigin 是用 getElementsByTagName 方法选取出来的元素，在没有进行后面的添加操作前，它是divWrapper 元素的第一个子元素；当后面添加了新的元素后，divNew 成了 divWrapper 的第一个元素，那么之前选取出来的 divOrigin 有没有动态的更新呢？ 答案当然是没有，动态更新的是用这个方法选取出来的类数组，divOrigin 已经是一个确定的值了， 不会再动态更新 删除DOM元素parentNode.removeChild(node) 父元素删除自己的一个子节点 这个方法的返回值是被删除的节点对象，所以这个操作相当于是剪切操作 123456789&lt;div class="wrapper"&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divWrapper = document.getElementsByTagName('div')[0]; var divInner = divWrapper.getElementsByTagName('div')[0]; divWrapper.removeChild(divInner); console.log(divWrapper);&lt;/script&gt; node.remove() 节点自己将自己删除，没有返回值 ES5中的新方法，IE9+可以自己填充remove()方法（这个问题先记下，用到再查） 1234567891011&lt;div class="wrapper"&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divWrapper = document.getElementsByTagName('div')[0]; var divInner = divWrapper.getElementsByTagName('div')[0]; divInner.remove(); console.log(divWrapper); divWrapper.remove(); console.log(document.body);&lt;/script&gt; 这个demo说明，如果被删除节点下还有子节点，那么这些子节点也都会被一起删除 替换DOM元素parentNode.replaceChild(new, origin) 将父节点中某一个子节点替换成新的节点 返回被替换对象的引用 12345678910&lt;div class="wrapper"&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divWrapper = document.getElementsByTagName('div')[0]; var divInner = divWrapper.getElementsByTagName('div')[0]; var spanNew = document.createElement('span'); divWrapper.replaceChild(spanNew, divInner); console.log(divWrapper);&lt;/script&gt; Element节点的一些属性innerHTML 可以查看元素的 HTML 的结构内容 可以修改元素的 HTML 可以向 HTML 结构里面添加结构 IE 兼容 12345678910111213141516&lt;div class="wrapper"&gt; &lt;div class="inner" style="width:100px;height:100px;background-color:green;"&gt;text&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divWrapper = document.getElementsByTagName('div')[0]; var divInner = divWrapper.getElementsByTagName('div')[0]; // 查看元素HTML的内容结构 console.log(divWrapper.innerHTML); // 修改元素HTML的内容结构 divInner.innerHTML = 'textNew'; console.log(divInner.innerHTML); // 向元素HTML结构中添加结构，会把原来的内容都覆盖掉 divWrapper.innerHTML = "&lt;span style='color:red;'&gt;把原来的内容覆盖掉了&lt;/span&gt;"; innerText 查看元素的文本内容 修改元素的文本内容(覆盖) 与老版本火狐不兼容，老版本的火狐实现相同功能用的是 textContent() 方法，但是这个方法又和老版本的 IE不兼容；现代主流浏览器普遍支持 innerText 12345678910&lt;div class="wrapper"&gt; &lt;div class="inner"&gt;text&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divWrapper = document.getElementsByTagName('div')[0]; var divInner = divWrapper.getElementsByTagName('div')[0]; divInner.innerText = 'textNew'; console.log(divInner.innerText); &lt;/script&gt; Element 节点的一些方法setAttribute(name, value)给元素节点设置属性 getAttribute(name)获取元素节点的属性 12345678&lt;div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; div.setAttribute('class', 'demo'); console.log(div); var divClassName = div.getAttribute('class'); console.log(divClassName);&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM继承树(DOM 接口)]]></title>
    <url>%2F2018%2F05%2F12%2Fa23_javascript%2F</url>
    <content type="text"><![CDATA[图中的构造函数我们不能拿来构造对象，这是系统自己构造对象用的构造函数 document 对象的直接构造函数是 HMTLDocument()，而 document 对象的最终继承对象是 Object，可以通过原型链查看：document.__proto__.__proto__.__proto__.__proto__.__proto__ getElementById 方法定义在 Document.prototype 上，HTML 和 XML 的 document 元素都可以使用这个方法，而 Element 元素不能使用这个方法 getElementsByName 方法定义在 HTMLDocument.prototype 上，即非 HTML 中的 document 元素不能使用（XMLDocument、Element） getElementsByTagName、getElementsByClassName、querySelector、querySelectorAll这些方法在Document.prototype 和 Element.prototype上均有定义，也就是说 document 元素和 Element 元素均能使用这些方法 12345678&lt;div class="wrapper"&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divWrapper = document.getElementsByTagName('div')[0]; var divInner = divWrapper.getElementsByTagName('div')[0]; console.log(divInner);&lt;/script&gt; HTMLDocument.prototype 定义了一些 常用的属性，body、head 分别指代 HTML 文档中的 &lt;body&gt;和&lt;head&gt; 标签，不用专门取出来使用，直接 document.body 、document.head 就可以 Document.prototype 上定义了 documentElement 属性，指代文档的根元素，在HTML文档中，指代&lt;html&gt; 元素，即如果要使用 html 元素，直接用 document.documentElement 即可 12345&lt;script type="text/javascript"&gt; console.log(document.body); console.log(document.head); console.log(document.documentElement);&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM节点]]></title>
    <url>%2F2018%2F05%2F12%2Fa22_javascript%2F</url>
    <content type="text"><![CDATA[DOM节点 这一部分可以先看第1点，然后跳过2、3点，看完后面再回来看2、3点 节点层次DOM 可以将任何 HTML 或 XML 文档描绘成一个由多层次节点构成的结构。节点分为几种不同类型，每种类型分别表示文档中不同的信息或标记。每个节点都拥有各自的特点，数据和方法，另外也与其它节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特点节点为根节点的树形结构。以下面的 HTML 为例： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 将这个简单的HTML文档表示为一个层次结构图： Document 代表整个文档。&lt;html&gt; 元素是每个文档的根节点，也是文档唯一的一个直接子节点，我们称 &lt;html&gt; 为文档元素。在 HTML 页面中，文档元素始终都是 &lt;html&gt; 元素，在 XML 中，没有预定义的元素，任何元素都可能成为文档元素。 结点类型 介绍 文档中的元素可以分为四大类节点： 元素节点 HTML元素通过元素节点表示 特性节点 特性通过特性节点表示 文档类型节点 文档类型通过文档类型节点表示 注释结点 注释通过注释结点表示 这四大类型包括12种结点，他们都继承自一个基类型，Node 类型。DOM1 定义了一个 Node 接口，这个接口在 JavaScript 中是作为 Node 类型实现的；除了 IE 之外，其他所有的浏览器 中都可以访问到这个类型。JavaScript 中所有的结点类型都继承自 Node 类型，因此所有的结点类型都共享着相同的基本属性和方法。 判断 在 JavaScript 中该如何判断一个节点是哪一种节点呢？ 每一个节点都有一个 nodeType 属性，用于表明该节点的类型。节点类型由在 Node 类型中定义的下列 12 个数值常量来表示，任何节点必居其一： Node.ELEMENT_NODE(1) Node.ATTIRIBUTE_NODE(2) Node.TEXT_NODE(3) Node.CDATA_SECTION_NODE(4) Node.ENTITY_REFERENCE_NODE(5) Node.ENTITY_NODE(6) Node.PROCESSING_INSTRUCTION_NODE(7) Node.COMMENT_NODE(8) Node.DOCUMENT_NODE(9) Node.DOCUMENT_TYPE_NODE(10) Node.DOCUMENT_FRAGMENT_NODE(11) Node.NOTATION_NODEF(12) 括号外面的部分代表常量名称，括号中部分代表常量名称对应的数值，一般在判断节点类型时用nodeType 属性和数值进行比较，因为IE没有公开 Node 类型的构造函数，因此通过 nodeType 与常量名进行比较的话在 IE 中无法实现，为了浏览器兼容，用数值比较即可 记住几个常用的节点类型，即其相应的数值即可 常用节点类型 nodeType数值 元素节点 1 属性节点 2 文本节点 3 注释结点 8 Document 9 DocumentFtagment(文档碎片结点) 11 节点属性 nodeName 元素的标签名，以大写形式表示，只读(不可修改)，IE兼容 1234567891011121314&lt;div class="demo"&gt; &lt;input type="hidden" name="inputName"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByClassName('demo')[0]; var input = document.getElementsByTagName('input')[0]; console.log(document.nodeName); console.log(div.nodeName); console.log(input.nodeName); // 只读，不可修改 div.nodeName = 'divDemo'; console.log(div.nodeName);&lt;/script&gt; 注意: nodeName 是标签的名字，而不是元素的属性 name 的值，参照以上代码中的 input nodeName 只读，不可修改，参照以上代码中修改后的输出 nodeValue 节点的值，只有文本和注释结点的这个属性值有意义，且值可以修改，IE 兼容 12345678910111213141516&lt;div&gt; text &lt;!-- comment --&gt; &lt;p&gt;textInP&lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0], nodes = div.childNodes; console.log(nodes[0].nodeValue); console.log(nodes[1].nodeValue); console.log(nodes[2].nodeValue); // nodeValue值可以修改 nodes[0].nodeValue = 'textInDiv'; console.log(nodes[0].nodeValue);&lt;/script&gt; nodeType 节点类型常量对应的数值，IE兼容 12345678910111213&lt;div&gt; text &lt;!-- comment --&gt; &lt;p&gt;textInP&lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0], nodes = div.childNodes; console.log(nodes[0].nodeType); console.log(nodes[1].nodeType); console.log(nodes[3].nodeType); console.log(document.nodeType);&lt;/script&gt; attributes 代表一个元素的属性集合，属性值可以修改，属性名不可以修改，IE 兼容(了解即可，一般不用) 12345678910111213141516&lt;div class="demo"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; console.log(div.attributes[0].nodeType); // 属性值可以修改 console.log(div.attributes[0].value); div.attributes[0].value = 'newValue' console.log(div.attributes[0].value); // 属性名不能修改 console.log(div.attributes[0].name); div.attributes[0].name = 'newName' console.log(div.attributes[0].name);&lt;/script&gt; 可以用 getAttribute() 方法访问属性值： IE 兼容 123456&lt;input type="hidden" name="demo"&gt;&lt;script type="text/JavaScript"&gt; var input = document.getElementsByTagName('input')[0]; console.log(input.getAttribute('type')); console.log(input.getAttribute('name'));&lt;/script&gt; class 的值可以一般 ‘className’ 属性访问，不用上面的方法 12345&lt;div class="demo"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; console.log(div.className);&lt;/script&gt; 查看DOM节点通过选择的方法查看元素节点通过选择的方法，文档中的元素节点，返回值可能是元素对象或者类数组 (方法中写法是 element 的返回元素对象，方法中写法是 elements 的返回类数组) document.getEelementById() 通过id查找文档中的元素，返回元素对象 IE9 以下的浏览器会把 name 属性也当做 id 匹配，且不区分大小写 id 标签一般作为顶级框架的名称存在，在 html 的结构搭建中一般不要使用 id 选择器 12345&lt;div id="demo"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementById('demo'); console.log(div);&lt;/script&gt; document.getElementsByTagName() 通过标签名查找元素，返回类数组 IE兼容 开发中常用 123456789&lt;div class="wrapper"&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div'); console.log(div); console.log(div[0].className); console.log(div[1].className);&lt;/script&gt; 一般用哪个标签，就直接取到那个标签，比如要用上个代码中的 inner var divInner = document.getElementsByTagName(‘div’)[1]; document.getElementsByClassName() 通过类名查找标签，返回类数组 IE9 以下没有这个方法 12345678&lt;div class="wrapper"&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="wrapper"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var divWrapper = document.getElementsByClassName('wrapper')[0]; console.log(divWrapper.className);&lt;/script&gt; document.getElementsByName() 通过元素的名字查找标签，返回类数组 IE 兼容但是 IE9 及以下不好用 一般不用 12345&lt;input type="hidden" name="demo"&gt;&lt;script type="text/javascript"&gt; var input = document.getElementsByName('demo')[0]; console.log(input);&lt;/script&gt; 这里有一个疑问？ 观察这段代码在 chrome 以及 IE11 浏览器上的运行结果，发现 input 标签内 type 和 name 属性的顺序是不同的，这是为什么呢？如果是这样，那按下表访问属性的话不就会出现差错呢？ document.querySelector() css 选择器，选择元素的规则和 css 选择元素的规则是一样的，返回元素对象 IE8 以下不兼荣 123456789&lt;div&gt; &lt;p&gt; &lt;span&gt;&lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var span = document.querySelector('div&gt;p&gt;span'); console.log(span);&lt;/script&gt; document.querySelectorAll() 与 querySelector() 功能类似，只不过这个选择满足复合条件的所有元素，返回类数组 IE8 以下不兼荣 1234567891011&lt;div&gt; &lt;p&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var span = document.querySelectorAll('div&gt;p&gt;span'); console.log(span);&lt;/script&gt; 虽然用 css 选择器的方法选择元素既直观又方便，但是开发中一般是不用这种方法选取元素的，原因如下： 兼容性不好，IE8 以下不兼容 css 选择器选择元素的机制是静态的，不是实时的：即用这种方法选择出来的元素，当做副本存储起来了，这之后对页面结构做出任何的调整，都不会影响到之前已经选择出来的内容，无法做到实时更新。举个例子，比如某 p 标签下原来有 3 个 span 元素，这时分别用 document.querySelectorAll() 和 document.getElementsByTagName() 两种方法将3个span元素选择出来，然后用新建一个 span 元素，并把它添加到 p 中去，这时 p 中变成了 4 个 span，用前一种方法选择出来的 span 还是3个，而用后者选择出来的 span 元素是4个，是实时更新的 12345678910111213141516&lt;div&gt; &lt;p&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var span = document.querySelectorAll('div&gt;p&gt;span'); var spanTmp = document.getElementsByTagName('span'); var newSpan = document.createElement('span'); var p = document.getElementsByTagName('p')[0]; p.appendChild(newSpan); console.log(span); console.log(spanTmp);&lt;/script&gt; 通过节点树查看节点（遍历节点树） parentNode DOM元素的父节点，一个元素的父节点只有一个，返回元素对象 IE兼容 1234567891011&lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var span = document.getElementsByTagName('span')[0]; console.log(span.parentNode); console.log(span.parentNode.parentNode); console.log(span.parentNode.parentNode.parentNode); console.log(span.parentNode.parentNode.parentNode.parentNode); console.log(span.parentNode.parentNode.parentNode.parentNode.parentNode); &lt;/script&gt; childNodes DOM元素的子节点们，一个DOM元素可能有很多子节点，返回类数组 IE9以下会自动忽略掉空格、回车、换行等文本节点 1234567891011121314&lt;div&gt; textNode &lt;!-- commentNode --&gt; textNode &lt;span&gt;&lt;/span&gt; textNode&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; console.log(div.childNodes.length); // 观察div.childNodes的组成 console.log(div.childNodes);&lt;/script&gt; 一定要清楚，这里的 div.childNodes.length 为什么是 5 而不是 1： 因为 childNodes 代表 DOM 元素的子节点，而不仅仅是元素节点，在 div 中除了有 span 元素节点，还有 1个注释结点，3 个文本节点（textNode) firstChild / lastChild 选择DOM元素的 第一个 / 最后一个 节点，返回元素对象 IE兼容 123456789101112&lt;div&gt; textNode1 &lt;!-- commentNode --&gt; textNode2 &lt;span&gt;&lt;/span&gt; textNode3&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; console.log(div.firstChild); console.log(div.lastChild);&lt;/script&gt; nextSibling / previousSibling 选择 下一个 / 上一个 兄弟结点，返回元素对象 IE兼容 123456789101112&lt;div&gt; textNode1 &lt;!-- commentNode --&gt; textNode2 &lt;span&gt;&lt;/span&gt; textNode3&lt;/div&gt;&lt;script type="text/javascript"&gt; var span = document.getElementsByTagName('span')[0]; console.log(span.previousSibling); console.log(span.nextSibling);&lt;/script&gt; 子节点的个数 childNodes.length 通过元素节点树来查看元素节点（遍历元素节点树）以下方法中，除children外，都是IE9以下不兼容 parentElement DOM节点的父元素节点，返回元素对象 1234567&lt;div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; console.log(div.parentElement); console.log(div.parentElement.parentElement); console.log(div.parentElement.parentElement.parentElement);&lt;/script&gt; 第三个打印结果是 null，说明document不属于元素节点的范畴 children DOM元素的子元素节点们，返回类数组 12345678910&lt;div&gt; &lt;!-- comment --&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; console.log(div.children[0]); console.log(div.children[1]);&lt;/script&gt; firstElementChild / lastElementChild DOM元素的 第一个 / 最后一个 元素节点，返回元素对象 1234567891011&lt;div&gt; &lt;!-- comment --&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;strong&gt;&lt;/strong&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; console.log(div.firstElementChild); console.log(div.lastElementChild);&lt;/script&gt; nextElementSibling / previousElementSibling DOM元素 下一个 / 前一个 兄弟元素节点，返回元素对象 1234567891011&lt;div&gt; &lt;!-- comment --&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;strong&gt;&lt;/strong&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var span = document.getElementsByTagName('span')[0]; console.log(span.nextElementSibling); console.log(span.previousElementSibling);&lt;/script&gt; 子元素节点的个数 children.length == childElementCount hasChildNodes()判断一个元素有没有子节点，返回值类型时 boolean 12345&lt;div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; console.log(div.hasChildNodes());&lt;/script&gt; false，div 中没有任何节点 123456&lt;div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var div = document.getElementsByTagName('div')[0]; console.log(div.hasChildNodes());&lt;/script&gt; true，div 中有一个文本节点 nodeName 和 tagName获取标签的名称，待补充https://blog.csdn.net/wmjblog/article/details/9949035https://blog.csdn.net/borishuai/article/details/5719227]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM简述]]></title>
    <url>%2F2018%2F05%2F12%2Fa21_javascript%2F</url>
    <content type="text"><![CDATA[什么是DOMDOM(文档对象模型)是针对HTML和XML文档的一个API(应用程序编程接口)。DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面中的某一个部分。DOM脱胎于Netscape及微软公司创世的DHTML(动态HTML)，但现在他已经成为表现和操作页面标记的真正的跨平台、语言中立的方式。 W3C DOM由一下三部分组成： 核心 DOM - 针对任何结构化文档 XML DOM - 针对XML文档的标准模型 HTML DOM - 针对HTML文档的标准模型 DOM的地位我们知道，一个网页是由html来搭建结构的，通过css来定义网页的样式，而JavaScript赋予了页面的行为，通过它我们可以与页面进行交互，实现页面的动画效果等等。那javascript究竟通过什么来实现的呢？通过ECMAScript这个标准，我们可以编写程序让浏览器来解析，利用ECMAScript，我们可以通过BOM对象（即browser object model）来操作浏览器窗口、浏览器导航对象(navigator)、屏幕分辨率(screen)、浏览器历史(history)、cookie等等。但这个通过BOM来实现的交互远远不够。要实现页面的动态交互和效果，操作html才是核心。那如何操作html呢？对，就是DOM，简单的说，DOM给我们提供了用程序来动态控制html的接口，也就是早期的DHTMl的概念。因此，DOM处在javascript赋予html具备动态交互和效果的能力的核心地位上。 DOM的发展1. DOM0JavaScript在早期版本中提供了查询和操作web文档内容的API(如图片、表单)，在JavaScript中定义了’images’、’forms’等，因为我们可以像下面这样访问第一张图片或者名为’user’的表单： 12document.images[0];document.forms['user']; 这实际上是未形成标准的试验性质的初级阶段的DOM，现在习惯上被称为DOM0，即第0级DOM。由于DOM0在W3C进行标准化之前出现，还处于未形成标准的初级阶段，这时Netscape和Microsoft各自退出自己的第四代浏览器，自此DOM便开始出现各种问题。 2. DOM0与DHTMLNetscape Navigator 4 和 IE4分别发布于1997年6月和10月，这两种浏览器都大幅扩展了DOM，使JavaScript的功能大大增加，此时也开始出现了一个新名词：DHTML DHTML(Dynamic HTML)，叫做’动态HTML’。DHTML并不是一项新技术，而是将HTML、CSS、JavaScript技术组合的一种描述。即： 利用HTML把网页标记为各种元素 利用CSS设置元素样式即显示位置 利用JavaScript操控页面元素和样式 利用DHTML看起来可以很容易的控制页面元素，并实现原本很复杂的效果，但事实并非如此。因为没有规范和标准，两种浏览器对相同功能的实现完全不一样。为了保持程序的兼容性，程序员必须写一些探查代码以检测JavaScript是运行在哪种浏览器下，并提供与之对应的脚本。JavaScript下入了前所未有的混乱，DHTML也因此在人们心中留下了很差的印象。 我们在阅读DOM标准的时候，经常会看到DOM0级这样的字眼，实际上DOM0级这个标准是不存在的。所谓DOM0级只是DOM历史坐标系中的一个参照点而已，具体地说DOM0级就是指IE4.0和Netscape navigator4.0最初支持的那个DHTML。 3. DOM1在浏览器厂商进行浏览器大站的同时，W3C结合大家的优点推出了一个标准化的DOM，并于1998年10月完成了第一级 DOM，即：DOM1。W3C将DOM定义为一个与平台和编程语言无关的接口，通过这个接口程序和脚本可以动态的访问和修改文档的内容、结构和样式。 DOM1级主要定义了HTML和XML文档的底层结构。在DOM1中，DOM由两个模块组成：DOM Core（DOM核心）和DOM HTML。其中，DOM Core规定了基于XML的文档结构标准，通过这个标准简化了对文档中任意部分的访问和操作。DOM HTML则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法，如：JavaScript中的Document对象. 4. DOM2在DOM1的基础上DOM2引入了更多的交互能力，也支持了更高级的XML特性。DOM2将DOM分为更多具有联系的模块。DOM2级在原来DOM的基础上又扩充了鼠标、用户界面事件、范围、遍历等细分模块，而且通过对象接口增加了对CSS的支持。DOM1级中的DOM核心模块也经过扩展开始支持XML命名空间。在DOM2中引入了下列模块，在模块包含了众多新类型和新接口： DOM视图（DOM Views）：定义了跟踪不同文档视图的接口 DOM事件（DOM Events）：定义了事件和事件处理的接口 DOM样式（DOM Style）：定义了基于CSS为元素应用样式的接口 DOM遍历和范围（DOM Traversal and Range）：定义了遍历和操作文档树的接口 完整的DOM2标准(图片来自百度百科)： 5. DOM3进一步扩展了DOM，引入了以统一方式加载和保存文档的方法，它在DOM Load And Save这个模块中定义；同时新增了验证文档的方法，是在DOM Validation这个模块中定义的. DOM3进一步扩展了DOM，在DOM3中引入了以下模块： DOM加载和保存模块（DOM Load and Save）：引入了以统一方式加载和保存文档的方法 DOM验证模块（DOM Validation）：定义了验证文档的方法 DOM核心的扩展（DOM Style）：支持XML 1.0规范，涉及XML Infoset、XPath和XML Base]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组练习]]></title>
    <url>%2F2018%2F05%2F10%2Fa20_javascript%2F</url>
    <content type="text"><![CDATA[数组去重：封装一个函数，功能是可以去掉一个数组中重复的元素，要求在原型链上编程 123456789101112Array.prototype.unique = function () &#123; var arr = [], obj = &#123;&#125;, len = this.length; for (var i = 0; i &lt; len; i++) &#123; if (obj[this[i]] == undefined) &#123; obj[this[i]] = true; arr.push(this[i]); &#125; &#125; return arr;&#125; 字符串去重：功能类似于数组去重 123456789101112function strUnique(str) &#123; var obj = &#123;&#125;, strNew = '', len = str.length; for (var i = 0; i &lt; len; i++) &#123; if (obj[str[i]] == undefined) &#123; obj[str[i]] = true; strNew += str[i]; &#125; &#125; return strNew;&#125; 给定一个字符串由[a,z]组成，找出其中出现的第一个只出现一次的字母 1234567891011121314151617function find(str) &#123; var obj = &#123;&#125;, strNew = '', len = str.length; for (var i = 0; i &lt; len; i++) &#123; if (obj[str[i]] == undefined) &#123; obj[str[i]] = true; strNew += str[i]; &#125; &#125; for (var i = 0; i &lt; strNew.length; i++) &#123; if (obj[strNew[i]] == undefined) &#123; return strNew[i]; &#125; return 'no'; &#125;&#125; 声明一个长度为100的数组，初始值全是0 12345arrInit1 = new Array(100).fill(0); // 一般使用这种 arrInit2 = Array.apply(null,Array(100)).map(function(v, i) &#123; return 0;&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2018%2F05%2F10%2Fa19_javascript%2F</url>
    <content type="text"><![CDATA[数组的定义方式对象字面量 构造空数组 1var arr = []; 构造有值数组 1var arr = [1, 2, 3]; 值为空： 12var arr = [, , ,];// undefined * 3 这里可能会困惑三个逗号不应该是四个undefined么？为什么是3个？ 因为最后一个逗号会被省略，关于数组中的空值，后面还会详细介绍 new Array() 构造空数组 1var arr = new Array(); 构造指定长度的数组 12var arr = new Array(10);// 构造长度为10的空数组 构造有值数组 1var arr = new Array(10, 1); 一旦括号中的参数超过一个，就不再是构造指定长度的数组了，括号中的每一个参数都是数组中的一个值 数组的常用方法可以改变原数组的一类push() 在数组的末尾添加数据，返回值是修改后的数组长度 123var arr = [1,2,3];arr.push(4,5,6);// arr = [1,2,3,4,5,6] 内部原理 123456Array.prototype.push = function () &#123; for (var index in arguments) &#123; this[this.length] = arguments[index]; &#125; return this.length;&#125; pop() 将数组的末位剪切出来，返回值是剪切出来的值 1234var arr = [1,2,3];var tmp = arr.pop();// tmp = 3// arr = [1,2]; 疑问：JavaScript内部是怎么删除数组元素的呢（pop的内部原理是什么）？ shift() 移除数组中最前一个元素，数组中的值自动前移，返回值是被移除的元素 1234var arr = [5, 4, 3, 2, 1];var tmp = arr.shift();// tmp = 5// arr = [4, 3, 2, 1] unshift 将参数列表添加到数组的最前面，返回值是修改后的数组长度 123var arr = [5, 6, 7, 8];arr.unshift(1, 2, 3, 4);// arr = [1, 2, 3, 4, 5, 6, 7, 8] reverse() 将数组反转，返回值是修改后的数组 123var arr = [1, 2, 3, 4, 5];arr.reverse();// arr = [5, 4, 3, 2, 1] splice(a, b, c) 从a位置开始，截取b的长度，添加c的新数据，返回值是被截取的内容 a：截取操作的起始位置，可以是负值，这个起始位置在内部是这样计算的：pos += pos &gt;= 0 ? 0 : this.length; b：截取跨越持续的长度，不能是负值，可以省略，如果b为空，则从a截取到数组末尾 c：在截取操作的切口处，添加新的数据，可以省略，如果c为空，则只进行截取，不进行添加 1234567891011var arr = [1, 2, 3, 4, 5, 6]; var ret = arr.splice(1, 3, 'insert', 100, true, ['hello']);// ret = [1, 5, 6]// arr = [1, 'insert', 100, true, ['hello'], 5, 6] arr.splice(1, 4);// arr = [1, 5, 6] arr.splice(0);// arr = [] 小技巧：当b的值为0时，可以对数组进行插入操作 123var arr = [1, 4, 5];arr.splice(1, 0, 2, 3);// arr = [1, 2, 3, 4, 5] sort() 没有参数的时：按照默认的定义 ‘把数组元素当做字符串进行升序排序’，返回值是排序后的数组 123var arr = [4, 11, 5, 3];arr.sort();// arr = [11, 3, 4, 5] 有参数时：sort函数为编程提供了接口，可按照自己的需求进行排序 条件： 必须有两个参数 看自己提供的编程接口的返回值：返回值为正，两个参数中后面的数在前面；返回值为负，两个参数中前面的数在前面；返回值为0，两个参数顺序不变 123456789var arr = [4, 11, 5, 3];arr.sort(function (a, b) &#123; if (a &gt; b) &#123; return 1; &#125; else &#123; return -1; &#125;&#125;);// arr = [3, 4, 5, 11] 当 a &gt; b 时，要让b放在前面，a放在后面，所以应该返回一个正值(以1代替)；当a &lt; b 时，要让a放前面，b放后面，所以要返回一个负数(以-1代替)，然后会发现 若 a &gt; b, a - b 就是正值；若 a &lt; b, a - b就是负值，所以直接返回a - b即可 12345var arr = [4, 11, 5, 3];arr.sort(function (a, b) &#123; return a - b;&#125;);// arr = [3, 4, 5, 11] 要真正理解这个内部的过程，下面做两个小练习： 给定一个有序数组，要求让这个数组乱序 12345var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; arr.sort(function (a, b) &#123; return Math.random() - 0.5;&#125;); ​ 将给定数组 [‘111’, ‘11’, ‘111111’, ‘1’, ‘1111111111’, ‘1111’] 按照元素的长度降序输出 1234var arr = ['111', '11', '111111', '1', '1111111111', '1111'];arr.sort(function (a, b) &#123; return b.length - a.length;&#125;); fill(a, b, c) 在 [b, c) 这个区间上添加 a 元素，b、c可以省略 12// 声明一个长度为100的数组，并将所有的元素初始化为0var arr = new Array(100).fill(0); 不改变原数组的一类方法concat() 实现数组的拼接 1234567var arr1 = [1, 2, 3], arr2 = [4, 5, 6], ret;ret = arr1.concat(arr2);// arr1 = [1, 2, 3]// arr2 = [4, 5, 6]// ret = [1, 2, 3, 4, 5, 6] toString() 将数组转换为字符串 1234var arr = [1, 2, 3, '456', [7, 8, 9 ]];var ret = arr.toString();// arr = [1, 2, 3, '456', [7, 8, 9 ]]// arr = "1, 2, 3, 456, 7, 8, 9" slice() 截取数组： 0个参数：整个截取 （常用来将类数组转换为数组） 1个参数：slice(a) —&gt; 从a开始，截取到最后一位 2个参数：slice(a, b) —&gt; 从a开始，截取到 b 位，不包括 b 位 a和b的值都可以是负数，代表着倒数第几位 1234567var arr = [1, 2, 3, 4, 5];var ret = arr.slice();var ret1 = arr.slice(1);var ret2 = arr.slice(1, 3);// ret = [1, 2, 3, 4, 5]// ret1 = [2, 3, 4, 5]// ret2 = [2, 3] join(str) 将数组以参数为连接符，连接成一个字符串，参数是字符串 123var arr = [1, 2, 3, 4];var ret = arr.join('-');// ret = "1-2-3-4" 字符串有一个方法，功能与这个方法相反 split(str) — 将字符串以参数为拆分标志，拆分成数组，参数是字符串 123var str = '1-2-3-4';var ret = str.split('-');// ret = ['1', '2', '3', '4'] 类数组类数组的基本形态首先来看一下类数组一般长什么样子 12345678var obj = &#123; '0': 'a', '1': 'b', '2': 'c', 'length': 3, 'push': Array.prototype.push, // 'splice': Array.prototype.splice&#125; 类数组的基本组成部分 属性要为索引（数字）属性 一定要有length属性 最好加上push方法 加上splice以后这个对象就长得像数组了 注意：这里的push方法内部实现原理要特别注意 一个小练习： 如下， 经过一下操作后，对象最终长什么样子 12345678var obj = &#123; '2': 'a', '3': 'b', length: 2, push: Array.prototype.push&#125;;obj.push('c');obj.push('d'); 结果： 原因： 其实这里只要相同push内部的实现原理就可以了 1234Array.prototype.push = function (target) &#123; this[this.length] = target; this.length++;&#125; 将类数组转换成数组123456789var obj = &#123; '0': 'a', '1': 'b', '2': 'c', 'length': 3, push: Array.prototype.push&#125;; var ret = Array.prototype.slice.call(obj); 数组的空位参考链接：https://www.jianshu.com/p/015e3c176855 迭代forEach 使用形式 arr.forEach(function (ele, index) {}, arr) 功能 与for循环的功能相同，循环遍历数组 参数 ele：每一次循环遍历的元素 index：每一次循环遍历的元素索引 arr: 被遍历的数组（这个参数一般不用，所以一般情况下只写一个function参数） 使用样例 给定一个数组，要求打印数组每一个元素及其对应的索引 123456789101112131415var arr = [ &#123;'name': 'a', 'age': 15, 'sex': 'female'&#125;, &#123;'name': 'b', 'age': 16, 'sex': 'male'&#125;, &#123;'name': 'c', 'age': 17, 'sex': 'female'&#125;];arr.forEach(function (ele, index) &#123;// console.log(`索引：$&#123;index&#125;// name: $&#123;ele.name&#125;// age: $&#123;ele.age&#125;// sex: $&#123;ele.sex&#125;`); console.log('索引：' + index); console.log('姓名：' + ele.name); console.log('年龄：' + ele.age); console.log('性别：' + ele.sex);&#125;); 注释部分是使用模板字面量的方法输出，了解一下 特别注意 forEach方法的不足之处在于无法提前结束循环 看这样一个例子：还是上面代码中的数据，现在要求当打印出的内容中name是 ‘b’时，就停止打印后续的内容，下面用forEach来实现以下 1234567891011121314var arr = [ &#123;'name': 'a', 'age': 15, 'sex': 'female'&#125;, &#123;'name': 'b', 'age': 16, 'sex': 'male'&#125;, &#123;'name': 'c', 'age': 17, 'sex': 'female'&#125;];arr.forEach(function (ele, index) &#123; console.log('索引：' + index); console.log('姓名：' + ele.name); console.log('年龄：' + ele.age); console.log('性别：' + ele.sex); if (ele.name == 'b') &#123; return; &#125;&#125;); 观察打印结果，发现打印结果还是数组中的所有数据，并没有在我们想让它停下来的地方停下来，为了探寻原因，我们先来分析一下forEach方法的内部实现原理 内部实现原理 12345678910111213141516171819202122var arr = [ &#123;'name': 'a', 'age': 15, 'sex': 'female'&#125;, &#123;'name': 'b', 'age': 16, 'sex': 'male'&#125;, &#123;'name': 'c', 'age': 17, 'sex': 'female'&#125;]; Array.prototype.myForEach = function (func) &#123; var len = this.length; for (var i = 0; i &lt; len; i++) &#123; func(this[i], i); &#125;&#125;;arr.myForEach(function (ele, index) &#123; console.log('索引：' + index); console.log('姓名：' + ele.name); console.log('年龄：' + ele.age); console.log('性别：' + ele.sex); if (ele.name == 'b') &#123; return; &#125; // console.log('没有结束');&#125;); 首先这个函数是定义在Array的原型链上的，有一个函数作为参数，内部有一个for循环，从0循环遍历到数组的最后一为；在每一次for循环里面，调用一次被当做参数传进来的func函数，参数是当前的数组元素以及索引值，当这个函数执行完毕后，进行下一轮的循环；我们看这个被当做参数传进来的func函数的函数体，将函数调用传来的值按要求打印后，有一个要终止函数调用的判断，如果成立，则执行return，结束这次函数调用，而这个结束就是结束这一次的函数调用，如果后面还有其他等待执行的语句（注释部分），在这一次的调用中就不会执行了，但是当这次调用结束返回到for循环处时，for循环依然会继续循环调用这个函数，也就是说for循环并没有停止，直到循环遍历完所有数组元素，这就是为什么用forEach方法无法让循环提前结束的原因 小技巧 如果要循环遍历整个数组，那么用forEach方法非常方便，但是如果要是想查询某个元素或者在遍历时想让循环提前结束，直接使用for循环比较好 filter 使用形式 arr.filter(function(ele, index) {}); 功能 filter的意思是过滤器的意思，所以这个方法的功能就是按照指定的要求过滤掉不满足要求的数组元素，筛选出满足要求的数组元素 筛选的过程 当某一个数组元素满要求时，返回一个true代表这个元素应该加入到满足要求的队列中；当某一个元素不满足要求，就返回一个false，代表这个元素应该被过滤掉 返回值 返回值是一个数组，包含所有满足要求的数组元素 参数 ele：循环遍历的数组元素 index：循环遍历的元素索引 使用样例： 现在有一个数组，要求筛选出数组中所有的女性 123456789101112var person = [ &#123;'name': 'a', 'age': 15, 'sex': 'male'&#125;, &#123;'name': 'b', 'age': 16, 'sex': 'female'&#125;, &#123;'name': 'c', 'age': 17, 'sex': 'male'&#125;, &#123;'name': 'd', 'age': 18, 'sex': 'female'&#125;]; var arr = person.filter(function (ele, index) &#123; if (ele.sex == 'female') &#123; return true; &#125;&#125;); 特别注意 将所有满足要求的元素添加到一个数组中，这个过程是一个浅拷贝的过程，也就是说，如果向上面的代码一样，筛选的元素中存在引用类型的值，那么改变筛选出来的数组，原数组也会进行改变，下面从filter的内部实现方法上理解一下 内部原理 1234567891011121314151617181920212223var person = [ &#123;'name': 'a', 'age': 15, 'sex': 'male'&#125;, &#123;'name': 'b', 'age': 16, 'sex': 'female'&#125;, &#123;'name': 'c', 'age': 17, 'sex': 'male'&#125;, &#123;'name': 'd', 'age': 18, 'sex': 'female'&#125;]; Array.prototype.myFilter = function (func) &#123; var len = this.length, arr = []; for (var i = 0; i &lt; len; i++) &#123; if (func(this[i], i)) &#123; arr.push(this[i]); &#125; &#125; return arr;&#125;; var arr = person.myFilter(function (ele, index) &#123; if (ele.sex == 'female') &#123; return true; &#125;&#125;); 解决方法 既然系统给我们提供的filter方法实现的是浅拷贝，那如果我们要实现深拷贝的效果，就要自己封装一个 ‘myFilter’方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function deepClone(option, target) &#123; var copy, src; if (option != null) &#123; for (var prop in option) &#123; src = target[prop]; copy = option[prop]; if (copy &amp;&amp; typeof (copy) == 'object') &#123; if (Object.prototype.toString.call(copy) == '[object Array]') &#123; src = src ? src : []; &#125; else &#123; src = src ? src : &#123;&#125;; &#125; target[prop] = deepClone(copy, src); &#125; else &#123; target[prop] = copy; &#125; &#125; &#125; return target;&#125;var person = [ &#123;'name': 'a', 'age': 15, 'sex': 'male'&#125;, &#123;'name': 'b', 'age': 16, 'sex': 'female'&#125;, &#123;'name': 'c', 'age': 17, 'sex': 'male'&#125;, &#123;'name': 'd', 'age': 18, 'sex': 'female'&#125;]; Array.prototype.myFilter = function (func) &#123; var len = this.length, arr = [], toStr = Array.prototype.toString, arrStr = '[object Array]', tmp; for (var i = 0; i &lt; len; i++) &#123; if (func(this[i], i)) &#123; if (this[i] &amp;&amp; typeof(this[i]) == 'object') &#123; tmp = toStr.call(this[i]) == arrStr ? [] : &#123;&#125;; console.log(tmp); tmp = deepClone(this[i], tmp); &#125; else &#123; tmp = this[i]; &#125; arr.push(tmp); &#125; &#125; return arr;&#125;; var arr = person.myFilter(function (ele, index) &#123; if (ele.sex == 'female') &#123; return true; &#125;&#125;); 这里需要的着重理解的是深度克隆的方法实现，参照以前的笔记 map 使用形式 arr.map(function (ele, index) {}); 功能 循环遍历数组，并对数组元素进行一定的操作，返回操作后的数组 参数 ele：循环遍历的数组元素 index：循环遍历的元素索引 样例 给定一个数组，要求返回这个数组中每一个数的平方 1234var arr = [1, 2, 3, 4, 5];var newArr = arr.map(function (ele, index) &#123; return ele * ele;&#125;); 内部原理 123456789101112var arr = [1, 2, 3, 4, 5];Array.prototype.myMap = function (func) &#123; var len = this.length, arr = []; for (var i = 0; i &lt; len; i++) &#123; arr.push(func(this[i], i)); &#125; return arr;&#125;;var newArr = arr.myMap(function (ele, index) &#123; return ele * ele;&#125;); reduce 使用形式 arr.reduce(function(preValue, ele, index) {}, init); 功能 循环遍历数组，对函数上一次的返回值执行操作 参数 preValue：给定的初始值或者数组的第一位或者函数上一次的返回值 ele：循环遍历的数组元素 index：循环遍历的元素索引 init：preValue的初始值 样例 给preValue赋初始值 1234567var arr = [1, 2, 3, 4, 5];arr.reduce(function (preValue, ele, index) &#123; console.log(preValue); console.log(ele); console.log('---------'); return ele;&#125;, 0); 不给preValue赋初始值 1234567var arr = [1, 2, 3, 4, 5];arr.reduce(function (preValue, ele, index) &#123; console.log(preValue); console.log(ele); console.log('---------'); return ele;&#125;); 可以看到，当给preValue赋一个初始值时，第一次preValue的值就是这个初始值，index下标从0开始；如果没有给preValue赋初始值时，第一次preValue的值是数组的第一个元素，而index下标也就不从0开始了而是从1开始；在这之后每一次preValue的值就是上一次函数的返回值了 内部原理 12345678910111213Array.prototype.myReduce = function (func, init) &#123; var preview = init, i = 0, len = this.length; if (init === undefined) &#123; preview = this[0]; i = 1; &#125; for (i; i &lt; len; i++) &#123; preview = func(preview, this[i], i); &#125; return preview;&#125;; 小练习 给定一个数组，求这个所有元素的和 123456789101112131415161718var arr = [2, 5, 6, 4, 6, 7];Array.prototype.myReduce = function (func, init) &#123; var preview = init, i = 0, len = this.length; if (init === undefined) &#123; preview = this[0]; i = 1; &#125; for (i; i &lt; len; i++) &#123; preview = func(preview, this[i], i); &#125; return preview;&#125;; var sum = arr.myReduce(function (preValue, ele, index) &#123; return preValue + ele;&#125;); reduceRight() reduceRight()与reduce()的使用方法以及功能是一样的，只不过reduceRight的遍历顺序是从右向左的]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承模式]]></title>
    <url>%2F2018%2F05%2F05%2Fa10_javascript%2F</url>
    <content type="text"><![CDATA[原型链继承 思路 利用原型链的结构特点实现简单继承 关键 1构造原型链 实现 1234567891011121314151617181920212223function A(name) &#123; this.nameA = name; this.foo = &#123; a: 1, b: 2 &#125;;&#125;function B() &#123; this.nameB = 'b';&#125;function C() &#123; this.nameC = 'c';&#125;var a = new A('a');B.prototype = a;B.prototype.constructor = B;var b = new B();C.prototype = b;C.prototype.constructor = C; 优点 emmmmmmmmm……，思路简单？ 缺点 继承了过多没用的属性 参与原型链的所有实例，共享他们所继承的原型链中引用类型的值 创建子类型实例时，无法向其父类构造函数中传递参数，可定制性差 12345678910// 此处借用 "实现" 部分代码// 创建子类型实例时，无法向其父类构造函数中传递参数，可定制性差var c = new C(); // A 构造实例所需要的参数，无法从子类实例 b 或 c 得到，只能在自身实例化时实现// 参与原型链的所有实例，共享他们所继承的原型链中引用类型的值c.foo.a = 11111;console.log(c.foo.a); // 11111console.log(b.foo.a); // 11111console.log(a.foo.a); // 11111 借用构造函数 思路 在子类构造函数内部调用父类的构造函数 关键 1改变 this 指向 实现 12345678910111213A.prototype.tmp = 'param';function A(name) &#123; this.nameA = name; this.foo = &#123; a: 1, b: 2 &#125;;&#125;function B(name) &#123; A.call(this, name); this.nameB = 'b';&#125; 优点 子类构造函数实例化时，可向父类传递参数 引用类型属性不在共享 缺点 每次构造函数都要多走几个函数，增加了额外的开销 只能继承构造函数的实例属性或方法，无法继承构造函数原型的属性或方法 1234567891011121314// 此处借用 "实现" 部分代码var a = new A('a');// 构造子类可以向父类传递参数var b = new B('a');// 不在共享原型console.log(a.foo.a); // 1console.log(b.foo.a); // 1b.foo.a = 3;console.log(a.foo.a); // 1console.log(b.foo.a); // 3// 无法继承父类构造函数原型上的属性console.log(b.tmp); // undefined 组合继承 思路 通过原型链实现对原型属性方法的继承，通过借用构造函数实现对实例属性的继承 关键 结合前两种继承方式 实现 12345678910111213141516171819A.prototype.tmp = 'param';function A(name) &#123; this.nameA = name; this.foo = &#123; a: 1, b: 2 &#125;;&#125;function B(name) &#123; A.call(this, name); // 调用一次父类的构造函数 this.nameB = 'b';&#125;var a = new A('a');var b = new B('b'); // 调用一次父类的构造函数B.prototype = a;B.prototype.constructor = B; 优点 避免了一些单独使用的一些劣势，优势互补，比较常用 缺点 子类需要调用两次父类的构造函数，有额外的开销 原型继承 思路 原型继承的效果类似于原型链继承，只是封装了每次都要构造子类实例的过程 关键 使用 ECMAScript5 新增的 Object.create() 方法 详解 执行 Object.create() 发生了什么，为什么其效果类似于原型链继承，首先我们先看 Object.create() 使用一个参数时，它的执行过程是怎样的 1234567function object(obj) &#123; function F() &#123;&#125; F.prototype = obj; return new F();&#125;// 相当于 Object.create(obj); object 函数相当于把原型链继承中的以下过程封装了，只是 constructor 的指向无法明确的指向构造它的函数，因为构造它的是一个临时函数 F 而第二个参数就是给对象自身添加属性或者方法，具体使用方法参照上一节的讲解 实现 123456789101112131415161718A.prototype.tmp = 'param';function A(name) &#123; this.nameA = name; this.foo = &#123; a: 1, b: 2 &#125;;&#125;var a = new A('a');var b = Object.create(a, &#123; nameB: &#123; value: 'b', writable: true, enumerable: true, configurable: true &#125;&#125;); 优点： 和原型链继承一样，还是 emmmmmm….. 缺点： 同原型链继承 寄生式继承 思路 和原型继承的过程基本是一模一样……只是为创建对象添加自身属性的方式不同，原型继承是通过 Object.create() 的第二个参数为对象添加属性或方法，而在这种继承方式中，是直接操作对象添加属性或方法，也叫作 “增强对象” 关键 关键就是，不要用 Object.create() 的第二个参数，emmm确定有病无疑了~ 实现 1234567891011121314151617A.prototype.tmp = 'param';function A(name) &#123; this.nameA = name; this.foo = &#123; a: 1, b: 2 &#125;;&#125;function create(obj) &#123; var clone = Object.create(obj); clone.nameB = 'b'; return clone;&#125;var a = new A();var b = create(a); 优点 ……….. 缺点 除了原型链继承具有的缺点以外，这种继承方式所实现的封装继承过程的函数还不能复用（真是鸡肋啊），比如上述 “实现” 中的代码，create 函数中要增强临时对象 clone ，就要把他的属性名或者方法名写死，这样一来创建其他对象时就得重写 寄生式组合继承(圣杯模式) 思路 顾明思议，寄生式继承就是结合了寄生继承和组合继承的一种继承方式；具体来说，组合继承中继承实例属性说方法的过程不变，还是使用构造函数，要改变的是继承原型属性或方法的方式，改变后的原型继承不再调用父类的构造方法 关键 寄生继承的实现；即不调用父类的构造函数，子类继承父类的原型 实现（使用构造函数继承部分的实现这里就不再描述了） 1234567function extend(subClass, superClass) &#123; function F() &#123;&#125; F.prototype = superClass; subClass.prototype = new F(); subClass.prototype.constructor = subClass; subClass.prototype.uber = superClass.prototype; // 缓存父类的 prototype 方便后续调用&#125; 12345678910// Yahoo YUI3 库中的写法，推荐var extend = (function () &#123; var F = function () &#123;&#125;; // 私有化 F，外部只能通过闭包访问 return function (subClass, superClass) &#123; F.prototype = superClass.prototype; subClass.prototype = new F(); subClass.prototype.constructor = subClass; subClass.prototype.uber = superClass.prototype; &#125;&#125;)();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型]]></title>
    <url>%2F2018%2F05%2F05%2Fa09_javascript%2F</url>
    <content type="text"><![CDATA[原型定义原型（prototype）是具有成为构造函数能力的函数对象的一个属性，它定义了一组实例对象的公有祖先；原型（prototype）本身是一个对象。 详细描述定义只是总结，细节内容较难理解，接下来针对定义中的几个点展开描述 具有成为构造函数能力的函数 这种说法是为了区分 ES6 中新增的箭头函数，箭头函数不能作用构造函数使用，没有 prototype 属性；不过从某种程度上讲，箭头函数的引入也增强了构造函数的语义话 除了箭头函数以外的普通函数都具有原型 prototype，但原型和构造函数的关联更紧密，所以我们所说的原型基本都是构造函数的原型，本文也是基于此进行介绍的，特此说明 函数对象的属性、原型本身是一个对象 可能和我们印象中的认知不同，函数其实也是一种对象，它是由 Function 构造出来的实例，既然是对象就有属性和方法，prototype 就是函数对象的一个属性，这个属性的值是一个对象 123function Foo() &#123;&#125;console.log(Foo.prototype); // &#123; ... &#125;// 打印结果是一个对象，至于对象里面的内容，我们暂时不关心 原型定义了一组实例对象的公有祖先 换一个更好理解的说法，原型定义了由构造函数构造出来的一组实例对象的公有属性或方法 首先我们创建一个 Person 构造函数，p1 和 p2 是 Person 构造的两个实例 123456789function Person(name, age) &#123; this.name = name; this.age = age; this.nose = 1; this.mouth = 1;&#125;var p1 = new Person('qht', 20);var p2 = new Person('thq', 2); 可以看到，构造函数中的 this.nose 和 this.mouth 的值是一个固定的值，对于每一个由构造函数构造出来的实例，nose 和 mouth 属性都是一样的，对于这种在各个实例中都一样的值，每构造一个实例就要执行一次，既影响性能，又造成空间的浪费；对这样的在每个构造函数实例中表现都相同的属性或方法，我们可以把它放到构造函数的原型 prototype 中，作为所有构造函数公有的属性或方法 123456789101112Person.prototype.nose = 1;Person.prototype.mouth = 1;function Person(name, age) &#123; this.name = name; this.age = age; // this.nose = 1; // this.mouth = 1;&#125;var p1 = new Person('qht', 20);var p2 = new Person('thq', 2); 我们把 nose 和 mouth 两个属性作为构造函数的公有的属性放到了构造函数的原型中，这时我们发现，构造函数的实例 p1 和 p2 中已经没有了这个两个属性，但是当他们访问这两个属性时却能访问的到，这是因为 p1 和 p2 继承了 Person 的原型 Person.prototype，Person.prototype 作为 Person 构造的实例 p1 和 p2 的公有祖先存在，导致 p1 和 p2 访问他们的属性时如果自身对象中不存在要访问的属性，就到他们继承的公有祖先(Person.prototype)中寻找，如果存在，则返回相应的值；也就是说，p1 和 p2 访问到的 nose 和 mouth 属性并不是自己对象中的属性，而是他们所继承的原型中的公有属性，可参考下面简略版的示意图理解 原型内部通过上面的讲解，我们已经了解了原型对象的基本概念，也知道了原型对象内部存放着实例对象的公有原型(属性或方法)，除了这些公有的属性或方法，原型内部还有其他东西么？这是接下来我们要探究的问题 我们写一个空的构造对象并打印它的原型 12function Foo() &#123;&#125;console.log(Foo.prototype); 打印结果如下 因为我们没有给 Foo 构造函数的原型添加任何的属性和方法，所以我们看到这两个方法是 Foo 函数被定义时便存在的，那我们就从函数被定义的过程入手，来分析这两个属性 __proto__先把结论放在这里： 每个对象都有 “__proto__“ 属性（除特例），该属性指向此对象所继承的原型对象 特例情况暂时不提，接下来进行讲解 前面提到过，函数也是对象，是 Function 类型构造出来的实例，所以函数定义的过程也就是构造函数实例化对象的过程，所以我们以构造函数构造对象的过程来探究 123function Foo() &#123;&#125;var foo = new Foo(); foo 是 Foo 构造出来的实例，这个过程中发生了什么？如果你了解 new 操作符的执行原理，那么这个过程就很简单了，在前面的文章中有讲解到过，这里针对关键的步骤再啰嗦一下 12345-- 使用 new 运算符是，系统进行以下操作1. 创建一个临时对象2. 为临时对象添加 &quot;__proto__&quot; 属性指向构造函数的原型3. 改变构造函数内 this 指针的指向到临时对象，并执行构造函数内代码4. 如果构造函数的返回值是引用值，则返回这个引用值；否则返回临时对象 以 Foo 构造 foo 的过程来为例模拟一下 123456789function myNew(constructFunction, ...param) &#123; var obj = &#123;&#125;; obj.__proto__ = constructFunction.prototype; var ret = constructFunction(obj, param); // return isPrimitive(ret) ? obj : ret; return obj;&#125;var foo = myNew(Foo); Foo 构造的 foo 对象就是在 new 过程中创建的临时对象，注意看第二句，obj.__proto__ = constructFunction.prototype;，执行完这条语句后，临时对象中增加了一个 __proto__ 属性，这个属性指向构造函数的原型，也就是说 foo 中存在一个 __proto__ 属性，这个属性指向它构造函数 Foo 的原型，即 Foo.prototype 知道了 __proto__ 是怎么来的，接下来便该探究这个属性到底有什么用了，为什么要添加这样一个属性？ 前面讲过，构造函数构造的实例对象会继承构造函数的原型，当访问到实例对象中没有的属性时，会在实例对象继承的原型中进行寻找，那么问题来了，实例对象是怎么找到他的原型的呢？换句话说，构造函数原型和实例对象是怎么建立起继承关系的？ 答案当然和 __proto__ 有关，对象的 __proto__ 属性指向它构造函数的原型，也就是说当我们要访问对象所继承原型时，就要通过 __proto__ 属性来 “引路”。 当然，我们也可以对 __proto__ 的属性值进行修改，比如： 12345678function Foo() &#123;&#125;function Bar() &#123;&#125;var foo = new Foo();console.log(foo.__proto__ == Foo.prototype); // truefoo.__proto__ = Bar.prototype;console.log(foo.__proto__ == Bar.prototype); // true 并非所有JavaScript引擎都支持 __proto__ 属性的访问和修改，通过修改 __proto__ 改变原型并不是一种兼容性方案。 总结一下，对象被构造时，在其内部会产生一个 __proto__ 属性，该属指向此对象所继承的原型 constructorprototype 中的这个属性是比较好理解的，对于这个属性我们可以通过 “顾明思议” 的方式来理解，constructor 的意思是 “构造函数”，所以没错，他记录了原型对象的构造函数 理解了它的定义，关于它的作用可以参考这篇文章，这里想介绍的重点不在这里，而是关于原型改变时对 constructor 所造成的影响，上代码 12function Foo() &#123;&#125;console.log(Foo.prototype.constructor); // Foo() &#123;&#125; Foo.prototype 的构造函数是 Foo() {}，没什么毛病，接下来，我们尝试改变 Foo.prototype 方法一： 1234function Foo() &#123;&#125;console.log(Foo.prototype.constructor); // Foo() &#123;&#125;Foo.prototype.name = 'qht';console.log(Foo.prototype.constructor); // Foo() &#123;&#125; 我们在 Foo 的原型上添加了一个 name 属性，打印 constructor 的值，好像没什么变化，接下来换一种方法 方法二： 1234567function Foo() &#123;&#125;console.log(Foo.prototype.constructor); // Foo() &#123;&#125;Foo.prototype = &#123; name: 'qht'&#125;console.log(Foo.prototype.constructor); // Object() &#123; [native code] &#125; 上面的两种写法除了形式以外，语义上好像没什么区别，但为什么打印结果改变了呢？ 其实原因很简单，方法一只是修改 Foo.prototype 中的属性值，给它添加了一个 name 属性；方法二是让 Foo.prototype 重新指向另一个对象，这个对象中有一个 name 属性；所以方法一中的 Foo.prototype 没有改变，所以他的 constructor 属性还是指向它的构造函数 Foo，而方法二中的 Foo.prototype 指向了一个新的对象，所以这里打印的 constructor 就变成了新对象的构造函数（至于新对象的构造函数为什么是 Object，后面原型链的知识中会提到） 可见，当我们要对构造函数的原型进行修改时，如果用赋值的方式进行修改会影响到原型的 constructor 属性，那是不是就是说用修改的方式修改原型比较好呢？在改动比较少的情况下是这样的，但是如果修改的属性比较多，那就得一条一条的去修改，代码太多，比如 12345function Foo() &#123;&#125;;Foo.prototype.name = 'qht';Foo.prototype.age = 20;Foo.prototype.sex = 'male';Foo.prototype.tel = '1234567'; 这样一条一条的修改很麻烦，如果使用赋值的方法改变原型，代码如下： 1234567function Foo() &#123;&#125;;Foo.prototype = &#123; name: 'qht', age: 20, sex: 'male', tel: '1234567'&#125;; 这样看起来，代码是不是简洁多了，但是它的问题在于 constructor 属性不在指向它真正的构造函数了，无论是对后续的使用还是语义化都不好，所以如果要使用这种方法，一定要在原型修改后，把原型的 constructor 属性也改回来，保证它指向的是正确的构造函数（这一步很重要，一定要记住） 12345678910function Foo() &#123;&#125;;Foo.prototype = &#123; name: 'qht', age: 20, sex: 'male', tel: '1234567', constructor: Foo&#125;;// 或者// Foo.prototype.constructor = Foo; 原型链描述 构造函数的原型通过 “__proto__“属性的指引形成的一种链式的结构 直接上代码 12345678910111213141516171819202122232425function A() &#123; this.nameA = 'a';&#125;function B() &#123; this.nameB = 'b';&#125;function C() &#123; this.nameC = 'c';&#125;var a = new A();B.prototype = a;B.prototype.constructor = B;var b = new B();C.prototype = b;C.prototype.constructor = C;var c = new C();console.log(c.__proto__);console.log(c.__proto__.__proto__);console.log(c.__proto__.__proto__.__proto__);console.log(c.__proto__.__proto__.__proto__.__proto__);console.log(c.__proto__.__proto__.__proto__.__proto__.__proto__); 打印结果 图解 首先我们定义了三个构造函数 A、B、C，以 A 构造的实例 a 作为 B 的原型，所以 B 的实例 b 的 __proto__ 属性指向 B.prototype，也就是 a；c 指向 C.prototype 也就是 b 的过程同理；由此便形成了以 __proto__ 为连接的 prototype 的链式结构，这便是原型链 终点 原型链终点准确的说法是对象最终继承自哪个原型，为了形象化描述，下面讲解使用原型链终点的描述方法 每个对象中都有 __proto__ 属性，那如果我们要持续的调用对象的 __proto__ 属性，是不是能始终访问到它的原型对象呢？换句话说，就是原型链是否具有终点？其实上面的 demo 中已经添加了关于这个问题的测试，当访问到 A.prototype 时，它的 __proto__ 指向 Object.prototype ，继续访问 Object.prototype，这时会返回一个 null 值，说明访问到 Object.prototype 时，就不能继续往下访问了，这便是原型链的终点 再写几组测试样例结果也是一样的，几乎所有对象能访问到的原型链的终点都是 Object.prototype，当然有特殊情况（__proto__ 定义中所说的特例），先公布答案吧，使用 Object.create() 方法创造对象且第一个参数为 null 时，所创建的对象不继承任何原型 12var obj = Object.create(null);console.log(obj); 可以看到，obj就是一个空对象，没有任何的属性方法，也就不存在通过 __proto__ 属性访问原型链重点的说法了，因为它根被就没有这个属性，下面简单介绍一下 Object.create() 方法 Object.create() 功能 创建一个包含指定属性并可选择性包含指定属性的对象 语法 1Object.create(prototype [, descriptors]) 参数 1234- prototype 必填，要用作原型的对象，可以是 null- descriptors 选填，包含一个或多个具有属性描述符的 JavaScript 对象 descriptors 数据属性 数据描述符特性 说明 默认 value 属性的当前值。 undefined writable true 或 false。如果 writable 设置为 true，则可以修改属性值。 false enumerable true 或 false。如果 enumerable 设置为 true，则可以由 for…in 语句枚举属性。 false configurable true 或 false。如果 configurable 设置为 true，则可以更改属性的特性且可以删除属性。 false 访问器属性 访问器描述符特性 说明 默认 get 返回属性值的函数。此函数没有参数。 undefined set 设置属性值的函数。它具有一个包含要分配的值的参数。 undefined enumerable true 或 false。如果 enumerable 设置为 true，则可以由 for…in 语句枚举属性。 false configurable true 或 false。如果 configurable 设置为 true，则可以更改属性的特性且可以删除属性。 false 练习 123456789101112131415161718192021222324252627282930313233343536373839var person = &#123; name: ''&#125;;var qht = Object.create(person, &#123; name: &#123; value: 'qht', writable: true, enumerable: true, configurable: true &#125;, sex: &#123; value: 'male', writable: false, enumerable: false, configurable: false &#125;, get: &#123; value: function () &#123; return this.name; &#125; &#125;, setName: &#123; value: function (name) &#123; this.name = name; &#125; &#125;, setSex: &#123; value: function (sex) &#123; this.sex = sex; &#125; &#125;&#125;);console.log(qht);qht.get();qht.setName('thq'); // 成功，因为 name 属性可修改qht.setSex('female'); // 失败，因为 sex 属性不可修改console.log(qht); 停止原型链继承 前面提到一点，当 Object.create() 方法的第一个参数为 null 时，创建出的对象不继承任何原型，举个例子： 大家知道 var nullObj1 = {}; 和 nullObj2 = object.create() 这两种方法创造出的对象有什么区别么？ 12345var nullObj1 = &#123;&#125;;var nullObj2 = Object.create(null);console.log(nullObj1);console.log(nullObj2); 打印都是两个空对象，好像没什么区别，但当我们点开它们发现： nullObj1 有 __proto__ 属性且指向 Object.prototype，而 nullObj2 没有任何的属性，也就是说，他没有继承任何一个原型，这是两个 “空对象” 最大的区别 一般方法创建的对象，最终都会继承 Object.prototype，Object.prototype 上封装了很多的方法，如果我们不想继承原型上属性或者方法的干扰，这时我们就可以用 Object.create() 方法，将第一个参数设置为null，第二个参数设置成我们需要的对象属性，创建一个不继承任何原型的对象，这样有利于我们更好的实现我们的需求 兼容性 目前支持 Object.create() 的浏览器有 IE9+, Firefox 4+, Safari 5+, Opera 12+ 和 Chrome 操作原型链上的一些基础操作，基于这个例子进行下面的讲解 1234567891011121314151617181920212223242526function A() &#123; this.nameA = 'a'; this.foo = &#123; a: 1, b: 2, c: 3 &#125;&#125;function B() &#123; this.nameB = 'b';&#125;function C() &#123; this.nameC = 'c';&#125;var a = new A();B.prototype = a;B.prototype.constructor = B;var b = new B();C.prototype = b;C.prototype.constructor = C;var c = new C(); 查原型链上属性或方法的查询满足一个特点：先在对象自身进行查找，找到则返回；否则会沿原型链查找原型中属性或方法，直至该对象所继承的最终的原型 12// ......console.log(c.nameA); // "a" 删对象只能删除自身具有的属性，对于从原型链上继承来的属性，无法删除 123456// ......delete c.nameC;console.log(c.nameC); // undefineddelete c.nameB;console.log(b.nameB); // "b" 改对象自身的属性，直接进行修改；对象原型链上的属性，分成两种情况： 属性是原始值 如果要修改对象原型链上原始类型的属性，原则是把该属性从原型上复制到自身对象中，然后对自身对象中的副本进行修改操作，原型上的原始属性保持不变 属性是引用值 如果要修改对象原型链上引用类型的属性，原则也是把该属性从原型到复制到自身对象中，但因为是引用值，所以复制不会建立副本，而是指向了同一地址空间；这导致所有继承该原型的对象都可以修改原型中引用类型的值，换句话说，就是继承自同一原型的对象，共享该原型中的引用类型属性 12345// 修改原始类型值// ......c.nameA = 1111111;console.log(c);console.log(a); 1234567// 修改引用类型值// ......c.foo.a = 1111111;console.log(c);console.log(c.foo.a);console.log(b.foo.a);console.log(a.foo.a); 确定原型和实例的关系instanceof1234567891011121314// 以此例为基础进行讲解function A() &#123;&#125;function B() &#123;&#125;function C() &#123;&#125;var a = new A();B.prototype = a;B.prototype.constructor = B;var b = new B();C.prototype = b;C.prototype.constructor = C;var c = new C(); 语法 1object instanceof constructor 含义 简单解释是 object 是constructor 的实例，返回 true；否则返回 false； 但大多数情况下按照这个解释都无法正确判断返回值，下面给出详细解释（内部机制）： 如果 object 可以通过 __proto__ 最终访问到 constructor 的 prototype，则返回 true，否则返回 false 1234console.log(c instanceof C); // trueconsole.log(c instanceof B); // trueconsole.log(c instanceof A); // trueconsole.log(c instanceof Object); // true isPrototypeOf() 语法 1prototype.isPrototypeOf(object) 含义 判断原型 prototype 是否在对象 object 所继承的原型链上，是返回 true，不是返回 false 其实它与 instanceof 的功能是一样的 1234console.log(C.prototype.isPrototypeOf(c)); // trueconsole.log(b.isPrototypeOf(c)); // trueconsole.log(a.isPrototypeOf(b)); // trueconsole.log(Object.prototype.isPrototypeOf(c)); // true]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象简介、包装类]]></title>
    <url>%2F2018%2F05%2F04%2Fa08_javascript%2F</url>
    <content type="text"><![CDATA[对象基本形式对象是由一组键值对组成的集合，包括属性名及其相应的值，不同键值对以 key : value 的形式展示，不同键值对之间用 “,” 分隔，集合用 {} 来表示 12345678910111213var obj = &#123; 'name': 'qht', 'age': 20, 'money': 0, play: function () &#123; this.money--; return this.money; &#125;, study: function () &#123; this.money++; return this.money; &#125;&#125; 基本操作 增 对象名.属性名 = 属性值 1obj.sex = 'famale'; 查 对象名.属性名 1obj.sex; // 如果该对象不存在查询的属性，不会报错，返回 undefined 删 delete 对象名.属性名 1delete 对象名.属性名 改 对象名.属性名 = 新属性名 1person.sex = 'male'; 创建对象创建对象的方法有三种，根据实际情况选择合适的创建方法 对象字面量 / 对象直接量1var obj = &#123;&#125;; 实例构造函数 系统自带的构造函数 1var obj = new Object(); var obj = {}; 和 var obj = new Object(); 是完全等效的，所以开发中一般采用前一种，即对象字面量的写法 自定义构造函数 12function Foo() &#123; //... &#125;var obj = new Foo(); 注意构造函数的命名要遵循大驼峰命名规范 使用原型1var obj = Object.create(object / null); 第一个参数（说明还有第二个参数，可选，后面会讲到）只能是 object 或者 null，没有参数会报错，声明一个指向 指定对象或者 null 的对象，注意，如果这里的参数是 null，那 obj 原型链的终点就不是 Object，这里涉及到原型链的的知识，简单了解，后续再提； 构造函数的内部原理来看一段代码 1234567891011121314function Foo() &#123; this.num = 1;&#125;var test1 = new Foo();var test2 = new Foo();var test3 = new Foo();test1.num = 1;test2.num = 2; test3.num = 3;console.log(tes1.num); // 1console.log(test2.num); // 2console.log(test3.num); // 3 在分别给，三个对象中的属性赋予不同的值后，将这个值打印，发现确实是我们设置的值，这操作看似很简单，但是却说明了一个问题：他们各自被赋予了不同的值，说明他们的赋值没有被相互影响，那说明这个 num 属性在不同的作用域中，即用 Foo 构造函数构造的这三个对象是相互独立的 提出问题： 为什么当构造函数被实例化后，实例对象就能具有构造函数的全部属性 为什么同一个构造函数构造的实例，相互之间独立存在 内部原理： 首先来铺垫一个知识，每一个函数的内部都存在一个隐式的 this 对象，如果有对象调用它，他就指向当前调用它的对象（至于其他情况 this 的指向后续专门讲解，这里了解这一点即可） 结合构造函数，构造函数在定义的时候，其内部有隐式的 this ，但这个 this 还没有指向任何(非window的)对象，既然我们要用这个构造函数构造一个对象，那么肯定就要让这个 this 和我们构建的对象产生一定的关联，这个关联就是通过 new 运算符产生的 我们来看一下，当使用 new 操作符时，系统进行了哪些操作 12341. 创建一个临时对象2. 为临时对象添加 &quot;__proto__&quot; 属性指向构造函数的原型3. 改变构造函数内 this 指针的指向到临时对象，并执行构造函数内代码4. 如果构造函数的返回值是引用值，则返回这个引用值；否则返回临时对象 根据上面的步骤，我们来模拟一下 new 的执行过程 1234567891011function myNew(name) &#123; var obj = &#123;&#125;; obj.__proto__ = Foo.prototype; var ret = Foo.call(obj, name); var type = typeof ret; if (type === 'undefined' || type === 'number' || type === 'string' || type === 'boolean' || ret === null || type === 'symbol') &#123; return obj; &#125; return ret;&#125; 使用一下 123456789101112131415161718192021function Foo(name) &#123; this.name = name; this.print = function () &#123; console.log(this.name); &#125;&#125;function myNew(name) &#123; var obj = &#123;&#125;; obj.__proto__ = Foo.prototype; var ret = Foo.call(obj, name); var type = typeof ret; if (type === 'undefined' || type === 'number' || type === 'string' || type === 'boolean' || ret === null || type === 'symbol') &#123; return obj; &#125; return ret;&#125;var foo = myNew('qht');foo.print(); // 'qht' 更好的写法 1234567function instantiate(fn, ...rests) &#123; var f = Object.create(fn.prototype); var val = fn.apply(f, rests); return isPrimitive(val) ? f : val;&#125;function A() &#123;&#125;var a = instantiate(A); 这里用到的 isPrimitive() 函数需要单独封装 关于内部原理讲解，涉及到 this、原型、call、apply、ES6 的一些知识，可大概理解，看完后续的文章再加深理解 包装类原始数据类型中，Number、String、Boolean除了以原始类型存在以外，还可以以对象类型存在 123var a = new Number(1); // Number&#123;1&#125;var b = new String('hello'); // String&#123;"hello"&#125;var c = new Boolean(true); // Boolean&#123;true&#125; 对象有属性，原始类型数据没有属性 123456789// 对象var a = new Number(123);a.len = 3;console.log(a.len); // 3// 原始值var b = 123;b.len = 3;console.log(b.len); // undefined a 是 Number 类型的对象，对象有属性所可以给 a 设置属性； b 是 Number 类型的原始值，原始值不能设置属性，那为什么执行 b.len = 3 以及 console.log(b) 都不报错呢 原因就是这个过程中要经历一个包装类的过程： 12345678910111213var b = 123;// 正常执行b.len = 3;// b 是原始类型，不能设置属性，编译即将错误，但是系统为了不让这条语句编译错误，会先隐式的创建一个 b 同类// 型的对象，值为 123，添加 len 属性并赋值为 1，整个操作即：new Number(123).len = 1; 这样一来这条语句// 便可以编译通过，不会报错；在编译通过的同时，系统会立即删除刚才创建的临时对象console.log(b.len);// 同样，b 是原始值，不能访问原始值的属性，编译即将错误，但是系统为了不让这条语句编译错误，会隐式的创建一// 个 b 的同类型对象，值为 123，添加 len 属性但不会给他赋值！！！注意这里不同于之前的一步，这里不会给// len 属性赋值，这时 b 是对象可以访问 len 属性了，所以不会报错，又 len 属性没有被赋值，所以打印结果是// undefined 包装类的练习题： 1234567var str = 'abc';str += 1;var test = typeof (str);if (test.length == 6) &#123; test.sign = 'typeof的结果可能是String';&#125;console.log(test.sign); // undefined]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2018%2F05%2F04%2Fa07_javascript%2F</url>
    <content type="text"><![CDATA[定义闭包是指有权访问另一函数作用域内的变量的函数 形成闭包的形成一般是在函数执 A 行完毕之前，将其内部的某个函数 B 以某种形式保存到函数 A 的外部，这样，在函数 A 执行结束后，外部函数依然可以访问 A 函数作用域内的变量，这个被保存到外部的这个函数就是一个闭包 12345678910function foo() &#123; var a = 1; return function () &#123; console.log(a); &#125;&#125;// console.log(a);var bar = foo()(); 我们知道，如果打开上述代码的注释，直接打印 a 的话一定会报错，因为外部作用域无法访问内部的作用域；但同样和它在同一个作用域下，最后一条语句就可以访问 a 变量，这就是闭包所造成的 本质先来看结论，闭包形成的本质就是内部函数的作用域链被保存到了外部，即作用域链的保留，以一个例子说明： 1234567891011function foo() &#123; var a = 1; return function () &#123; console.log(a); &#125;&#125;// var bar = foo()();var bar = foo();bar(); 为了条理清晰，我们把 var bar = foo()(); 这句代码拆成两句执行，效果是一样的 按照作用域链的形成步骤来看： 当 JS 脚本执行时，执行上下文堆栈中会压入一个全局执行上下文，即 VO foo();，foo 函数对应的执行期上下文 foo.AO 被压入执行上下文堆栈中 var bar = foo();，这步比较关键，在 foo 函数执行完毕之前，return 了一个函数出去，这个被 return 出去的函数对应的执行环境（执行上下文堆栈）和当前执行环境（执行上下文堆栈）是一样的；换句话说，就是在 foo 函数执行结束前，将当前的执行环境赋值了一份，保存在了另一个地方，而接收这个带着执行环境的函数的变量就是 bar，所以 bar 具有和 foo 函数执行完毕前相同的执行环境，在 return 操作结束后，原来（被复制的）执行上下文堆栈中的栈顶元素（foo.AO）被弹出（红色部分为原来的执行上下文堆栈，绿色部分为复制后的执行上下文堆栈） bar();，bar 函数对应的执行期上下文 bar.AO 被压入执行上下文堆栈中 至此 bar 函数执行时的执行上下文堆栈（作用域链）已形成，开始执行 bar 函数中的语句，要访问 a 变量，首先查找 bar.AO 中的 a 变量，发现没有，便到 bar.AO 的词法作用域中寻找，即到 foo.AO 中寻找，a 存在且值为 1，所以打印结果是 1 执行完毕，这时当前执行上下文即执行上下文堆栈的栈顶元素 bar.AO 弹出，但剩下的部分依然存在，所以即使再执行一次 bar(); 还是能访问到 a ，因为 foo.AO --- VO 这个作用域链始终保留着 用途以上讲解可以得出，闭包两个最大的特点是：一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，根据这两个特点可以罗列闭包的以下几点用处： 实现共有变量 可以做缓存结构 可以实现封装，属性私有化 模块化开发 123456789// 累加器，不断 sum(), 其值就一直累加function add() &#123; var basic = 0; return function () &#123; return ++basic; &#125;&#125;var sum = add();sum(); 1234567891011121314151617// 存储变量function eater() &#123; var food = "banana"; var obj = &#123; eat : function ()&#123; console.log("I am eating " + food); &#125;, push : function (myFood)&#123; food = myFood; &#125; &#125; return obj;&#125;var sb = eater();sb.eat();sb.push('Apple');sb.eat(); 123456789101112131415161718192021222324// 实现私有化变量// 实现模块化开发function person() &#123; var name = 'qht'; function setName(n) &#123; name = n; &#125; function getName() &#123; return name; &#125; return &#123; getName: getName, setName: setName &#125;;&#125;var person = person();person.getName(); // 'qht'person.setName('qinhaitao');person.getName('qinhaitao'); // 'qinhaitao' 虽然利用闭包的特点可以实现一些操作，但是它的特点在带来优点的同时也带来一些缺点： 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值 练习 练习一 1234567891011121314151617function foo() &#123; var num = 0; function a() &#123; return ++num; &#125; function b() &#123; return --num; &#125; return [a, b];&#125;var arr = foo();arr[0](); // 1arr[1](); // 0 arr[0]、arr[1] 两个函数是两个闭包，他们在执行前对应的执行上下文堆栈都是 foo.AO --- VO，所以执行时共享同一个词法作用域，他们操作同一个 num 练习二 1234567891011121314function foo() &#123; var arr = []; for (var i = 0; i &lt; 5; i++) &#123; arr[i] = function () &#123; return i; &#125; &#125; return arr;&#125;var arr = foo();arr.forEach(function(ele) &#123; console.log(ele());&#125;); // 5 5 5 5 5 结果并不是预想的 0 1 2 3 4，而是 5 个 5，逐步分析一下： 首先看一下是怎么形成闭包的，for 循环共执行了 5 次，每一次都将一个新的函数保存到数组中，在 foo 执行完毕之前将这个数组 return 到 foo 函数外面用 arr 接收，arr 中的每一个函数都具有 foo 函数运行时的执行环境，他们在执行时，共享同一个词法作用域 接下来看看，这个 5 个函数分别是什么，for 循环的每一次执行，都会把一个函数赋给数组，但是这个函数并没有被执行，所以函数中的语句也不会执行，所以在这期间这里的每一个函数体内的 return i; 不会被解释为 return 0、return 1、return 2、return 3、return 4，每一个都是 return i，所以 arr 数组中的函数是下面这个样子 因为 arr 中每一个函数在执行时共享同一个词法作用域，所以他们在词法作用域中访问的是同一个 i，这个 i 是循环结束后的 i，值为 5，所以会打印 5 个 5 解决方法，既然造成这个现象的主要原因是函数在执行时的执行环境相同，那么解决思路就是改变每一个函数执行时的执行环境，解决方法就是为每一个函数执行前的执行上下文堆栈添加一个栈顶执行上下文，其中 i 的值不同。参考下图，红色部分为原来数组中函数执行前的执行上下文堆栈，绿色部分为修改后，数组中函数执行上下文堆栈 怎么实现上述的效果的，其实有很多中方法，这里列举一些 123456789101112131415161718// 立即执行函数function foo() &#123; var arr = []; for (var i = 0; i &lt; 5; i++) &#123; (function (j) &#123; arr[j] = function () &#123; return j; &#125; &#125;)(i); &#125; return arr;&#125;var arr = foo();arr.forEach(function (ele) &#123; console.log(ele());&#125;); 123456789101112131415161718192021// 普通函数function foo() &#123; var arr = []; function bar(j) &#123; arr[j] = function () &#123; return j; &#125; &#125; for (var i = 0; i &lt; 5; i++) &#123; bar(i); &#125; return arr;&#125;var arr = foo();arr.forEach(function (ele) &#123; console.log(ele());&#125;); 123456789101112131415// let 声明，ES6function foo() &#123; var arr = []; for (let i = 0; i &lt; 5; i++) &#123; arr[i] = function () &#123; return i; &#125; &#125; return arr;&#125;var arr = foo();arr.forEach(function (ele) &#123; console.log(ele());&#125;); 练习三 1234567891011// demo1var name = 'window';var obj = &#123; name: 'obj', foo: function () &#123; return function () &#123; return this.name; &#125; &#125; &#125;;console.log(obj.foo()()); // 'window' 123456789101112// demo2var name = 'window';var obj = &#123; name: 'obj', foo: function () &#123; var _this = this; return function () &#123; return _this.name; &#125; &#125; &#125;;console.log(obj.foo()()); // 'obj' 简单讲解，demo1中闭包执行时的执行上下文堆栈是 AO --- foo.AO --- VO，执行 return this.name 时，在当前的执行上下文中找 this.name，它是存在的（预编译阶段创建的），且它所在的函数在执行时没有其他对象调用它，所以 this 指向全局，所以 this.name 是 ‘window’ demo2中闭包执行时的上下文堆栈也是一样的，AO --- foo.AO --- VO，执行 return _this.name 时，在当前的执行上下文中找 _this.name，不存在，便到它的词法作用域中找，存在且 _this 的值等于当前作用域中的 this，当前的函数是被 obj 对象调用的，所以这个 this 指向 obj，所以 _this 指向 obj，所以 _this.name == this.name == ‘obj’]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域]]></title>
    <url>%2F2018%2F05%2F03%2Fa06_javascript%2F</url>
    <content type="text"><![CDATA[作用域是什么作用域是代码运行时，各个变量、函数和对象的可访问性；作用域决定了代码里中变量和其他资源的生命周期及在各个地区中的可见性 为什么为什么要设置作用域的概念，作用域可以为代码提供一个安全的层级，在计算机中一个常规的原则就是，用户只能访问他们当前需要的东西；作用域还可以帮助我们提升性能，追踪bug减少bug；还可以解决不同范围同名变量冲突的问题 分类JavaScript 中的变量的作用域分为全局作用域和局部作用域；而对于JavaScript来说，它采用的是词法作用域，也可以说是静态作用域，JavaScript不采用动态作用域，但是 this 的运行机制和动态作用域相似；在 ES6 规范声明后，可以用 let 代替 var，将局部作用域声明为块级作用域 12345- 全局作用域- 局部作用域- 词法作用域- 动态作用域- 块级作用域 全局作用域全局变量、即在函数外声明的变量具有全局作用域，全局作用域中的变量生命周期应与整个程序相同；全局作用域中的变量能被其他的方法访问 局部作用域局部变量、即在函数方法题内声明的变量具有局部作用域，局部变量声明周期应与其所在的方法相同；局部作用域中的变量能被其子作用域访问 词法作用域JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了 12345678910var x = 1;function foo() &#123; console.log(x);&#125;function test() &#123; var x = 2; foo();&#125;test(); // 1 词法作用域，此处输出 1 ，动态作用域，此处输出 2 ，JavaScript采用词法作用域，所以这里输出 1 ，至于为什么，讲完后面的的知识，会更好理解 动态作用域动态作用域与词法作用域相对，函数的作用域在调用的时候才决定，JavaScript 中采用的是词法作用域，但是JavaScript 中 this 的执行机制和动态作用域很相似 块级作用域ES6 规范允许使用 let 关键字，声明块级作用域，块级作用域不再允许其他作用域的访问 执行上下文回想上一个文章中讲到的关于预编译的知识，在 JS 执行和方法执行的前一刻，系统会分别创建 VO 和 AO 对象，这个 VO 和 AO 对象就是(刚刚创建的)执行期上下文。执行期上下文包括了预编译的内容，也包括代码执行时对执行期上下文的修改，它就是 js 或者 函数在运行时的作用域 执行上下文堆栈浏览器里面的 JavaScript 解释器是单线程，同一时间只能发生一件事，其他行为会被放到执行堆栈里面排队，因此，在浏览器首次载入脚本时，将直接创建全局的执行上下文对象，将此对象压入栈底，当有函数执行时，将该函数的执行上下文压入栈中，浏览器总会执行栈顶的执行上下文，一旦当前执行上下文函数执行结束，他将被从栈顶抛出，将执行上下文的控制权交给当前的栈顶元素，直至执行堆栈中剩全局执行上下文为止 123456敲黑板： - 单线程 - 同步执行 - 栈底全局执行上下文 - 可变的函数执行上下文 - 执行上下文不同于上下文，关于上下文的讲解后面的文章介绍 作用域链在执行上下文堆栈中，每一个栈元素(执行上下文)都是一个作用域，他们构成的链式的结构，便是作用域链，下面一个实例来描述这个过程 1234567891011function a() &#123; function b() &#123; function c() &#123;&#125; c(); &#125; b();&#125;a(); 123456789101112131415161718// 每个函数的作用域链的产生过程// a defined a.[[scope]] ---&gt; 0 : VO a 函数定义时，执行上下文堆栈中中的情况// a doing a.[[scope]] ---&gt; 0 : aAO a 函数执行前(时)，执行上下文堆栈的情况，下同// 1 : VO// b defined b.[[scope]] ---&gt; 0 : aAO// 1 : VO// b doing b.[[scope]] ---&gt; 0 : bAO// 1 : aAO// 2 : VO// c defined c.[[scope]] ---&gt; 0 : bAO// 1 : aAO// 2 : VO// c doing c.[[scope]] ---&gt; 0 : cAO// 1 : bAO// 2 : aAO// 3 : VO 执行上下文创建包括两部分，预编译部分和代码执行部分，预编译部分除了上一文章中提到的操作以外，还包括一个确定 this 指向，在预编译过程中，this 始终指向 window，在代码执行过程中，this 指向调用它的对象 词法作用域深究从作用域链的角度来讲，某一个执行上下文的词法作用域是当前执行上下文中它的下一个执行上下文，还是以之前的那段代码为例 12345678910var x = 1;function foo() &#123; console.log(x);&#125;function test() &#123; var x = 2; foo();&#125;test(); // 1 123// foo 函数的执行上下文堆栈 // foo.AO(栈顶) --- VO(栈底) // foo.AO 执行上下文中没有 x，就向它的词法作用域中寻找，它的词法作用域是 foo.AO 的下面一个执行上下 // 文，即 VO，VO 中存在 x 且值为 1，所以打印结果为 1 立即执行函数定义立即执行函数没有函数声明，定义后立即执行，执行完毕后即释放，适合做初始化工作 形式1(function (pram) &#123;&#125;)(pram); 说明 以上定义形式只是 W3C 标准建议的声明形式，还有其他的声明形式 立即执行函数可以写函数名，但是因为它立即执行并执行完释放的特点，函数名没有什么用，所以一般不写 除了声明形式和执行机制以外，其他和普通函数一样 立即执行函数的实参写在最后的括号内 立即执行函数可以写函数名，但是因为它立即执行并执行完释放的特点，函数名没有什么用，所以一般不写 123(function foo() &#123; console.log('foo');&#125;)(); 可以看到，为了再次调用立即执行函数，我们给立即执行函数设置了名称，然而在立即执行函数执行过一次我们再调用它时，控制台报错，”foo is not defined”，这说明立即执行函数在执行完毕后就被释放了，所以再次调用就会报错 立即执行函数的实参写在最后的括号内 123(function (a) &#123; console.log(a);&#125;)(1); // 1 以上定义形式只是 W3C 标准建议的声明形式，还有其他的声明形式 1234567891011121314151617181920// 立即执行函数写法的深入探究// W3C建议写法： (function () &#123;&#125;())// 其他写法： (function () &#123;&#125;)()// ! function () &#123;&#125;()// - function () &#123;&#125;()// + function () &#123;&#125;()// 1 &amp;&amp; function () &#123;&#125;()// 0 || function () &#123;&#125;()// 报错写法: function() &#123;&#125;()// 不报错但也不会执行的写法：// function fn(a,b,c) &#123; console.log(a + b + c) &#125;(1,2,3)// 这种写法不报错的原因：因为系统在读到这条语句时，首先判断它不能按照立即执行函数// 执行，然后系统就会找有没有其他可以解释这条语句的方法；系统会把这一个整体当做两// 部分来看待 分别是 function fn(x) &#123;&#125; -----函数声明部分// ('') -----表达式部分// 所以系统不会报错，而且因为前半部分是函数声明，没有被执行，后面表达式部分也不执// 行，所以整个语句，既不报错，也不执行// 注意，因为前半部分属于是函数声明，所以一定要有函数名，如果这里省略函数名的话会报错// 原因：只有表达式才能被执行符号执行]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[预编译]]></title>
    <url>%2F2018%2F05%2F02%2Fa05_javascript%2F</url>
    <content type="text"><![CDATA[JS 运行的三个过程本文的重点是预编译，所以关于 JS 的执行过程及原理不做过多解释，这里简单介绍，以便更好地理解预编译 语法分析 检查 JS 代码，看看有没有语法错误 预编译 创建执行上下文，存储函数及变量声明 解释执行 按顺序解释执行代码 预编译引入首先来看一段代码 12var a;console.log(a); 打印结果是 “undefined”，因为我们声明了 a，但是没有对他赋值，所以不会报错，只是 a 没有值 1console.log(a); 执行结果是报错，错误信息是 “a is not defined”，原因是我们没有声明变量 a，就使用了变量 a 12console.log(a);var a; 这段代码的执行结果和第一段代码是一样的，但是我们来想一个问题，JS 是逐行解释执行的，那就是说先执行 console.log(a) 然后才会执行 var a，那说明在打印 a 的时候，a 还没有被声明，那为什么没有报的错说 a 没有被声明呢？ 回顾文章开始介绍的 JS 执行的三个过程，原因就在第二个过程中的预编译中 在预编译过程中，所有的变量声明会整体提升，所有的函数声明也会整体提升 就是说，在预编译的过程中，变量声明和函数声明都会被提到所有逻辑代码的上面，这样在执行时不会因为变量未定义而报错 123456foo();function foo() &#123; console.log(a); var a；&#125; 这段代码中，函数的声明和变量的声明都在使用它们的语句之后，但是因为预编译阶段已经将声明提到了逻辑代码的前面，所以这里不会报错 仔细看应该能注意到，前面的讲解中，声明两个字都会被加黑显示，这里要强调的是，预编译阶段提升的仅仅是变量或者函数的声明，而赋值操作是在代码执行时进行的，不参与提升 12console.log(a);var a = 1; 这里的打印结果是 “undefined”，虽然看起来我们好像是给 a 赋了值，但是在预编译阶段，只有变量声明会被提升，也就是说，只有 var a 这一部分被提到了 console.log(a); 语句之前，保证它执行不会出错，但是 a = 1 这个赋值操作是在代码执行阶段才执行的，如果我们在这条语句下面再写一句打印 a 的语句，那打印结果就是1了 函数预编译在引入预编译的介绍中，了解了在预编译阶段会发生哪些操作，那这些操作具体是怎么实现的呢，下面先介绍函数的预编译 发生时间函数预编译发生在函数执行的前一刻 四部曲12341. 创建 AO(Activation Object 执行期上下文)2. 将函数的形参变量声明和实参变量声明作为 AO 对象的属性名，值为 undefined3. 将实参和形参统一4. 将函数体中的函数声明作为 AO 对象的属名，值为函数体 以一个具体的例子来讲解上述四个步骤： 123456789101112131415161718192021function foo(a) &#123; console.log(a); var a = 123; console.log(a); function a() &#123;&#125; console.log(a); console.log(b); var b = function b() &#123;&#125;; console.log(b); function c() &#123;&#125; console.log(c);&#125;foo(1); 预编译过程： 第一步：创建 AO 对象 123var AO = &#123; &#125;; 第二步：将函数体内实参和变量声明作为 AO 对象的属性名，值为 undefined 1234AO = &#123; a: undefined, b: undefined&#125;; 第三步：将实参和形参统一 1234AO = &#123; a: 1, b: undefined&#125;; 第四步：将函数体内函数声明作为 AO 对象的属性名，值为函数体 12345AO = &#123; a: a() &#123;&#125;, b: undefined, c: c() &#123;&#125;&#125; 至此，函数预编译结束，此时 AO 对象中的属性及其对应的值如上，接下来我们再来逐步分析代码执行的步骤： 第一行：console.log(a) 1要打印 a，到 AO 对象中找 a，a 存在且值为 a() &#123;&#125;，所以这条语句的打印结果为 a() &#123;&#125; 第二行 &amp; 第三行：var a = 123;、console.log(a) 1第二行 &quot;var a&quot; 这部分的工作已经在预编译阶段第二步做过了，执行阶段执行 &quot;a = 123&quot;，所以此时 a 的值从 function a() &#123;&#125; 变成了 &quot;123&quot;，所以第三行的打印结果是 123 第四行 &amp; 第五行：function a() {}、console.log(a) 1第四行 &quot;function a() &#123;&#125;&quot; 这时一句函数声明，这行代码在预编译阶段第四步中执行过了，所以在执行阶段相当于没有这行代码，所以第五行的打印结果 a 的值还是之前的 a 的值 123 第六行 &amp; 第七行 &amp; 第八行 1第六行打印 b 的值，到 AO 对象中找 b，b 存在且值为 undefined，所以这条语句的打印结果为 undefined；第七行代码中的 &quot;var b&quot; 已经在预编译阶段的地二步执行过了，所以在执行阶段这里执行后半句 &quot;b = function b()&#123;&#125;&quot; 所以第八行的打印结果是 b() &#123;&#125; 第九行 &amp; 第十行 1第九行，&quot;function c() &#123;&#125;&quot; 已经在预编译阶段第四步执行过了，所以这里相当于不执行，第十行打印 c 的值，到 AO 对象中找 c，c 存在且值为 &quot;function c() &#123;&#125;&quot;，所以这里的打印结果是 c() &#123;&#125; 注意点： 可能会引起误导的地方，var b = function b () {}; 这条语句是变量声明，它是函数表达式，而不是函数声明，所以在预编译阶段他发生在第二步，而不是第四步 最终的打印结果如下： 全局变量123- 在全局作用于下声明的变量是全局变量- 未经声明就被赋值的变量是全局变量（imply global 暗示全局变量）- 全局就是 window，所以全局变量就是 window 的属性 123456789var c = 1;function foo() &#123; var a = b = 1;&#125;console.log(a); // 报错console.log(b); // 1// c 在全局作用域下声明所以 c 是全局变量// var a = b = 1，赋值操作从右向左，分解开来是 b = 1, var a = b，所以只有 a 进行了声明，b 未声明，所// 以 b 是全局变量 全局与预编译上面介绍了函数预编译的过程，全局预编译不同于函数预编译，但是过程几乎相同 发生时间JS 执行的前一刻 三部曲1231. 创建 VO 对象2. 将全局作用域下的变量声明作为 VO 对象的属性名，值为 undefined3. 将全局作用域下的函数声明作为 VO 对象的属性名，值为 函数体 这里的 VO 对象其实就是前面提到的 window 同样，以一个实例讲解： 12345678console.log(a);console.log(c);function a() &#123; var b = 1;&#125;a();var c = 1; 第一步：创建 VO 对象 123var VO = &#123; &#125; 第二步：全局作用域下的变量声明作为 VO 对象的属性名，值为 undefined 123VO = &#123; c: undefined&#125; 第三步：全局作用域下的函数声明作为 VO 对象的属性名，值为函数体 123456VO = &#123; c：undefined, a: a() &#123; var b = 1; &#125;&#125; 至此全局预编译全部完成，至于打印结果，因为两条 console.log() 语句是先执行的，所以打印的取值来自 VO 对象，对比 VO 对象找出值，即可理解 练习练习 123456789101112131415161718function foo(a, b) &#123; console.log(a); c = 0; var c; a = 3; console.log(b); b = 2; console.log(b); function b() &#123;&#125; function d() &#123;&#125; console.log(d);&#125;foo(1); 练习 123456789101112131415// 先执行全局预编译// VO = &#123;// b : 123// &#125;function foo() &#123; var a = b = 123; console.log(window.a); console.log(window.b); // b 没有声明就被赋值了，所以b属于全局作用域，被全局预编译，属于VO对象(window)&#125;// 这里执行函数预编译// AO = &#123;// a: 123// &#125;foo(); 练习 12345678910111213141516171819202122// VO对象中属性值的变化过程，只包含预编译部分，不包括执行期的变化! // VO &#123;// foo : undefined ---&gt; foo (foo) &#123;// //······// &#125;// &#125;console.log(foo);function foo(foo) &#123; console.log(foo); var foo = 234; console.log(foo); function foo() &#123;&#125;&#125;// AO 对象中属性值的变化过程，只包含预编译部分，不包括执行期的变化!// AO &#123;// foo : undefined ---&gt; 1 ---&gt; foo() &#123;&#125;// &#125;foo(1);var foo = 2;console.log(foo); 练习 1234567891011121314function foo() &#123; console.log(b); if (a) &#123; var b = 100; &#125; // console.log(c); c = 234; console.log(c);&#125;var a;console.log(a);foo();a = 10;console.log(c); 两个注意点： 在预编译的过程是和逻辑无关的，就像练习中的 if (a)语句，无论它将来是否执行，它里面的代码都会进行预编译 这道题如果打开注释，即在该出打印 c 的话，会报 “c is not defined” 的错误，因为 foo 里面的 c 没有声明，所以函数预编译时它不在 foo 的 AO 对象中，按理说没有声明直接赋值，c 应该是在 VO 对象中，但全局预编译发生在函数预编译前，也就发生在函数执行前，构造 VO 对象的时候，函数还没有执行，c 也就没有被赋值，也就没有在全局预编译阶段被放在 VO 对象中，而是在函数 foo 执行期间，执行到 c = 234 这条语句时，c 才被放到 VO 对象中，在这之前，c 是不存在的，所以打印 c 会报错；那么后面的一条 console.log() 语句为什么能打印出来呢，因为在打印时，如果它当前执行期上下文中没有该变量，他就到上一层执行上下文中去找，找到了就打印，找不到再向上找，直到 window 的执行期上下文，即 VO对象，这里 foo 的 AO 对象中没有 c，便到上一级 VO对象中找，这时 VO 对象中已经有 c 了，值为 234，所以打印结果是 234 关键点是 c 不是在全局预编译的时候被放到 VO 里的，而是代码执行到 c = 234 的时候被放到 VO 里的 练习 123456789101112131415161718192021a = 100;function demo(e) &#123; function e() &#123;&#125; arguments[0] = 2; console.log(e); if (a) &#123; var b = 123; // function c() &#123;&#125; 从2017年开始，if语句里面不再允许使用函数声明 &#125; // var c; a = 10; var a; console.log(b); f = 123; console.log(a);&#125;var a;demo(1);console.log(a);console.log(f); 练习 12345678910111213var x = 1, y = z = 0;function add(n) &#123; return n = n + 1;&#125;y = add(x);function add(n) &#123; return n = n + 3;&#125;z = add(x);console.log(x + "\n" + y + "\n" + z);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数]]></title>
    <url>%2F2018%2F05%2F02%2Fa04_javascript%2F</url>
    <content type="text"><![CDATA[定义方式函数声明1234function foo(param) &#123; //...&#125;console.log(foo.name); // foo 函数实际上也是对象，可称为函数对象，每个函数都是 Function 类型的实例，与其他引用类型一样具有属性和方法，上述声明等价于 1var foo = new Function('param', '//...'); 与普通对象不同的是 12typeof Function; // "function"typeof foo; // "function" 函数表达式命名函数表达式1234var foo = function fn() &#123; //...&#125;console.log(foo.name); // fn 匿名函数表达式1234var foo = function () &#123; //...&#125;console.log(foo.name); // foo 不同命名方式的区别，可以从打印的函数的名字中看出：对于函数声明和匿名函数表达式来说，只有一个函数名，所以没有分歧，而对于命名函数表达式，以上面定义中的例子来说，它的函数名是 fn，但是无法通过 fn() 的方法来调用该函数，必须使用 foo() 的方法来调用它，这个一定要注意 1234567var foo = function fn() &#123; console.log('hello');&#125;foo.name; // fnfoo(); // 可以调用fn(); // 报错，没有 fn 这个函数 如果要用函数表达式的方式的定义函数，一般使用函数匿名表达式而不用命名表达式 函数名命名方法普通函数：小驼峰命名法 构造函数：大驼峰命名法 123456789// 小驼峰function xiaoTuoFeng() &#123; //...&#125;// 大驼峰function DaTuoFeng() &#123; //...&#125; 函数名指代关于函数名指代什么要与C、C++等语言区别开，解释性语言使用指针但是不会输出指针 调用方法函数名() 1234function foo() &#123; //...&#125;foo(); 参数123- 形参没有类型声明- 形参和实参的个数可以不一样- 实参列表 形参没有类型声明 1234function foo(a) &#123; console.log(a)&#125;foo('qht'); 形参和实参的个数可以不一样 个数可以不一样，调用时只匹配前几位公有的参数 1234567function foo(a, b) &#123; console.log(a + ' ' + b);&#125;foo('qht'); // qht undefinedfoo('qht', 20); // qht 20foo('qht', 20, 'hello'); // qht 20 实参列表 对于每一个函数，系统均会为其生成一个 arguments 的变量(类似数组但不是数组)，用来保存传进来的的实际参数,叫做实参数列表，用 arguments.length 来访问该变量的长度；相应的也可以用 函数名.length 来访问形参的长度 12345678910111213function foo(a, b) &#123; if (foo.length &gt; arguments.length) &#123; console.log('形参多于实参'); &#125; else if (foo.length &lt; arguments.length) &#123; console.log('形参少于实参'); &#125; else &#123; console.log('形参等于实参'); &#125;&#125;foo(1); // 形参多于实参foo(1, 2, 3); // 形参少于实参foo(1, 2); // 形参等于实参 对于实参与形参产生匹配关系的几位数，它们之间会产生一个映射关系，一方改变，另一方也会受影响 1234567891011121314151617181920function foo(a, b, c) &#123; // 修改形参之前的形参和实参 console.log('a=' + a + ' b=' + b + ' c=' + c); console.log('arguments[0]: ' + arguments[0]); console.log('arguments[1]: ' + arguments[1]); console.log('arguments[2]: ' + arguments[2]); // 修改形参 a = 'hello'; b = 'world'; c = '!'; // 修改形参之后的形参和实参 console.log('a=' + a + ' b=' + b + ' c=' + c); console.log('arguments[0]: ' + arguments[0]); console.log('arguments[1]: ' + arguments[1]); console.log('arguments[2]: ' + arguments[2]); &#125;foo(1, 2); 可以看到，形参 a、b 改变后，实参数组 arguments 中的值也相应的改变了；但是 c 由 undefined 变成了 ‘!’，实参列表却没有改变，因为实参和形参列表只有前两位是匹配的，第三位没有进行匹配，所以他们不会有映射关系，也就不会相互影响 返回值通过 return 关键字来返回值 1234function foo() &#123; return 'hello world';&#125;foo(); // "hello world" 练习写一个函数，实现加法计数器 1234567function sum() &#123; var ans = 0; for (var i = 0; i &lt; arguments.length; i++) &#123; ans += arguments[i]; &#125; return ans;&#125; 定义一组函数，逆转并输出汉字形式 12345678910111213141516171819202122function reverseChange(x) &#123; // 逆置 var t = x, ans = 0; while (t != 0) &#123; ans = ans * 10 + t % 10; t = parseInt(t / 10); &#125; // 转为汉字 var characeter = ["零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"]; var ansString = "", t = x, tmp; while (t != 0) &#123; tmp = t % 10; ansString += characeter[tmp]; t = parseInt(t / 10); &#125; console.log(ans + "\n" + ansString);&#125; 设计一个函数，求n的阶乘 123456function factorial(n) &#123; if (n == 1) &#123; return 1; &#125; return n * factorial(n - 1);&#125; 设计一个函数，求斐波那契数列的第n项 123456function fabonacci(n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; return fabonacci(n - 1) + fabonacci(n - 2);&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条件循环语句]]></title>
    <url>%2F2018%2F05%2F01%2Fa03_javascript%2F</url>
    <content type="text"><![CDATA[条件语句if…else if…else12345678var a = 1;if (a &gt; 0) &#123; console.log('&gt;0');&#125; else if (a == 0) &#123; console.log('=0');&#125; else &#123; console.log('&lt;0');&#125; switch…case1234567891011121314151617181920212223var x = &apos;hello&apos;;switch (x) &#123; case &apos;a&apos;: console.log(&apos;a&apos;); break; case 2: console.log(&apos;b&apos;); break; case undefined: console.log(&apos;undefined&apos;); break; case &apos;d&apos;: console.log(&apos;d&apos;); break; case true: console.log(&apos;true&apos;); break; case null: console.log(&apos;null&apos;); break; default: console.log(&apos;others&apos;);&#125; 循环语句for123for (var i = 0; i &lt; 5; i++) &#123; console.log(i);&#125; while12345var i = 0;while (i &lt; 5) &#123; console.log(i); i++;&#125; do…while12345var i = 0;do &#123; console.log(i); i++;&#125; while (i &lt; 5);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型转换]]></title>
    <url>%2F2018%2F05%2F01%2Fa02_javascript%2F</url>
    <content type="text"><![CDATA[显式类型转换Number()语法 Number(x) 参数 12- x 被转换的参数 功能 将参数 x 转换为数字 1234Number('123.4'); // 123.4Number('123a'); // NaNNumber(null); // 0Number(undefined); // NaN parseInt()语法 parseInt(x [, radix]) 参数 1234- x 必填，被转换的参数- raidx 选填，被转换的参数的进制，默认是 10 进制 功能 将 radix 进制的参数 x，转换为 10 进制的整数 原则 参数 x 的第一位必须是当前进制可以是别的字符，如果不是，结果将被转换为 “NaN”；如果可以识别，则从第一位开始，一直到当前进制不能识别的那一位为止，将可识别的部分转为 10 进制整数 123456parseInt('a111'); // NaN// 第二位参数省略，则当前进制默认是10进制，第一位是10进制无法识别的字符，所以不进行转换，结果是"NaN"parseInt('111a'); // 111// 第二位参数省略，则当前进制默认是10进制，第一位是10进制可以识别的字符，一直到字符'a'为止，10进制无法识// 识别，所以被转换的部分是"111"，被转为10进制后的结果为"111" 123parseInt('4f5da2', 16); // 5201314// 第二位参数是16，则当前进制是16进制，所有字符都是16进制可以是别的字符，所以被转换的部分是"4f5da2"，结// 果是"5201314" parseFloat()语法 parseFloat(x) 参数 12- x 被转换的参数 功能 将参数 x 转换为小数 原则 如果第一位是数字，则可以进行转换，从第一位开始，直到小数点后第一个不是数字的字符为止，将数字部分转换为小数，其余部分舍弃掉；否则将返回 “NaN”； 123parseFloat('123.1') // 123.1parseFloat('123.1aaa') // 123.1parseFloat('aaa123.1') // NaN String()语法 String(x) 参数 12- x 被转换的参数 功能 将参数 x 转换为字符串类型 1234String(123) // '123'String(undefined) // 'undefined'String(null) // 'null'String(&#123;&#125;) // '[object Object]'，调用了 toSting() 方法 Boolean()语法 Boolean(x) 参数 12- x 被转换的参数 功能 将参数 x 转换成 true 或者 false 原则 false、undefined、null、’’、0、NaN 会被转换为 false，其他都被转换为 true 123456789Boolean(false); // falseBoolean(undefined) // falseBoolean(null) // falseBoolean('') // falseBoolean(0) // falseBoolean(NaN) // falseBoolean(&#123;&#125;) // trueBoolean(function () &#123;&#125;) // true toString()语法 x.toString([radix]) 参数 12- radix 目标进制 功能 无参：没有参数时，其功能类似于 String()，但是 undefined、null、NaN 无法使用 toString() 方法 有参：将 10 进制变量 x 以参数 radix 为目标进制进行转换 12345678910111213var a = true;a.toString(); // 'true'var a = null;a.toString();var a = undefined;a.toString();var a = NaN;a.toString();// 以上三种情况都会报错var a = 1376972;a.toString(8); // 5201314 隐式类型转换 https://juejin.im/post/5a7172d9f265da3e3245cbca#comment 虽然隐式转换是在内部进行的，我们无法看到，但是在内部也是调用一些列方法实现的，接下来我们看一些隐式转换是通过怎么样的内部调用来实现的 isNaN()功能 判断一个数据是否是 NaN 类型的数据 过程 isNaN() 先将数据放在 Number() 里面进行转换，然后针对转换后的结果进行判断 123isNaN(NaN); // trueisNaN('123'); // falseisNaN('abc'); // true ++、–、+、-说明 这里的 +、- 不是数学运算符，而是代表正负 功能 这些符号会将参与他们运算的数据，放在 Number() 中进行转换 12+'123'; // 123+'abc'; // NaN -、*、/、%功能 这些符号会将参与他们运算的数据，放在 Number() 中进行转换 122 - '1'; // 12 - 'a'; // NaN +说明 这里的 + 不代表正负 功能 当 + 两侧的数据，至少有一个是字符串类型的数据，会调用 String() 方法转换成字符类传型的方法 11 + 1 + 'a' + 1 + 1; // '2a11' &amp;&amp;、||、!功能 将每一部分表达式的结果转换为 bool 值，根据 bool 值判断是否要继续进行 120 &amp;&amp; 1 + 1; // 00 || 1 + 1； // 2 &gt;、&lt;、&gt;=、&lt;=功能 将参与运算的数据使用 Number() 进行转换后，进行比较 注意 NaN 和任何值比较，结果都是 false NaN != NaN undefined == null undefined !== null 123456NaN == NaN; // falseNaN &gt; 0; // falseNaN &lt; 0; // falseNaN == 0; // falseundefined == null // trueundefined === null // false ==功能 将两边除去 undefined 和 null 类型以外的原始值类型，用 toNumber() 方法进行转换，结果用于比较；如果除了原始值之外还有引用类型，比如说对象，则使用 toPrimitive() 方法进行转换，其转换规则是：如果对象的 valueOf() 方法的结果是原始值，返回原始值，如果对象的 toString() 方法返回原始值，就返回这个值，其他情况都返回一个错误 1'hello' == true // false ===功能 参与运算的两个数据的类型不同，则直接返回 false，如果类型相同且同为原始值，则数值相同返回 true，如果类型相同且同为引用值，则引用同一个对象时返回 true 1234567891011121314undefined == null; // trueundefined === null; // false'1' == 1; // true'1' === 1; // false1 === 1; // true'1' === '1' // truevar a = &#123;&#125;, b = &#123;&#125;, c = a;a === b; // falsea === c; // true typeof功能 用来判断数据类型 用法 用法一：typeof(x) 用法二：typeof x 返回值 返回值是一个字符串，所有可能的返回值包括，number、string、undefined、boolean、symbol、object、function 注意 1typeof null; // object 原因： 不同类型的数据在计算机底层用二进制数表示，而 JavaScript 中二进制前三位为 0 则会被判断为 object，null 的二进制表示都是 0，所以 typeof null 结果为 object 1typeof NULL; // "undefined" 原因： NULL 不同于 null，NULL 被视为任何其他未定义的变量 练习123456789101112131415161718192021222324typeof undefined;// "undefined"typeof NaN;// "number"typeof null;// "object"typeof typeof true;// "string"typeof(a) &amp;&amp; -true + (+undefined) + '';// "NaN"，typeof 返回值是 "string" 类型，不可能为 false11 + '11' * 2 == 33;// true，先乘除，后加减!!!!!' ' + !!'' - !!false || 2;// 1parseInt(3, 0);// 3 或者 报错，有些浏览器支持0进制，认为0进制就是没有进制，那就是原来的数// 有些浏览器不支持0进制，看到这种情况会报错]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量、数据类型、运算]]></title>
    <url>%2F2018%2F05%2F01%2Fa01_javascript%2F</url>
    <content type="text"><![CDATA[变量声明、赋值、初始化声明，JS 中的变量用 var 关键词声明 1var a; 赋值，给变量赋予一定的值 123a = 1;b = 'hello';c = true; 初始化，在声明变量的同时，赋予变量一定的值 1var a = 1; 单一 var 模式，减少 var 的使用，对于一组变量声明，应当使用一个 var 进行声明 123456789101112// badvar a;var b;var c;// acceptablevar a, b, c;// good for developmentvar a, b, c; 命名命名规则 区分大小写 不允许使用 JavaScript 中的保留字，关键字 可以包含英文字母、_、$、数字，但不能以数字开头 123456789101112// 区分大小写, a 和 A 是两个变量var a;var A;// 不允许使用保留字、关键字，var 是声明关键字，不允许被当做变量使用var var = 1;// 可以包含英文字母、_、$、数字，但是不能以数字开头var a1 = 1; // 正确var _a = 1; // 正确var $a = 1; // 正确var 1a = 1; // 错误 数据类型原始值原始值采用 栈存储（stack），复制时生成副本，共有 6 中原始值类型： 123456- Number // 数字- String // 字符串- Boolean // 布尔- Undefined // 未定义- Null // 不存在- Symbol(ES6) // 引用值引用值采用 堆存储（heap），复制时不生成副本，采用引用方式，常见的引用类型数据有： 12345- Array // 数组- Object // 对象- function // 方法- RegExp // 正则- Date() // 日期 运算运算符数学运算符1234+、-、*、/、%、=、()、++、--、+=、-=、*=、/=、%=- 其中 &apos;+&apos; 运算符除了有数学运算的功能，还有字符串连接的功能- 任何数据类型 + 字符串，结果都是字符串 比较运算符123&gt;、&lt;、==、===、&gt;=、&lt;=、!=- &apos;===&apos;：绝对等于 逻辑运算符12345&amp;&amp;、||、！- &amp;&amp;：自左向右依次检查每一个表达式的运算结果的布尔值，若为真，则继续向后检查，若为假则停止检查，直到整个 与运算表达式结束；返回结果为停止检查时，当前表达式的运算结果- ||：自左向右依次检查每一个表达式的运算结果的布尔值，若为假，则继续向后检查，若为真则停止检查，直到整个 与运算表达式结束；返回结果为停止检查时，当前表达式的运算结果- !： 将表达式的运算结果转换成布尔值再取反，值为true或false 12345678910111213141516171819202122// 练习var a = 1 &amp;&amp; 2 + 3；// a = 5;var a = 0 &amp;&amp; 2 + 3;// a = 0;var a = 1 || 2 + 3;// a = 1;var a = 0 || 2 + 3;// a = 5;var a = !1 + 1;// a = 1;var a = !0 + 1;// a = 2;var a = !(1 + 1)// a = false;var a = !0// a = true;// 应用data &amp;&amp; fn(data)e = e || window.event 小数运算精度小数运算存在精度问题 12345678910111213141516171819202122// 加法 =====================// 0.1 + 0.2 = 0.30000000000000004// 0.7 + 0.1 = 0.7999999999999999// 0.2 + 0.4 = 0.6000000000000001// 2.22 + 0.1 = 2.3200000000000003 // 减法 =====================// 1.5 - 1.2 = 0.30000000000000004// 0.3 - 0.2 = 0.09999999999999998 // 乘法 =====================// 19.9 * 100 = 1989.9999999999998// 19.9 * 10 * 10 = 1990// 1306377.64 * 100 = 130637763.99999999// 1306377.64 * 10 * 10 = 130637763.99999999// 0.7 * 180 = 125.99999999999999// 9.7 * 100 = 969.9999999999999// 39.7 * 100 = 3970.0000000000005 // 除法 =====================// 0.3 / 0.1 = 2.9999999999999996// 0.69 / 10 = 0.06899999999999999 原因 JavaScript 中的数字采用 IEEE 754 的64为双精度标准，第 0 位表示符号位，1~11 位表示指数为，12~63 位表示小数位，符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度，IEEE 754规定，有效数字第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript提供的有效数字最长为53个二进制位 以 0.1 + 0.2 为例，0.1 和 0.2 在被转换成二进制时，其浮点数用二进制表达是无穷的 120.1 -&gt; 0.0001100110011001...(无限)0.2 -&gt; 0.0011001100110011...(无限) IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持 53 位二进制位，所以两者相加之后得到二进制为 10.0100110011001100110011001100110011001100110011001100 因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了 0.30000000000000004。所以在进行算术计算时会产生误差，详细参考 取整向上取整 1Math.ceil() 向下取整 1Math.floor() 随机数生成一个 (0, 1) 之间的随机数 1Math.random() 练习 随机生成 (0, 100) 之间的整数 1Math.floor(Math.random() * 100); 生成 [min, max] 之间的随机数 123Math.floor(Math.random() * (max - min + 1) + min)parseInt(Math.random() * (max - min + 1) + min, 10) 处理位数可以处理小数点前后 16 为的数据]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + NexT 搭建你的专属博客]]></title>
    <url>%2F2018%2F04%2F27%2Fh01_hexo%2F</url>
    <content type="text"><![CDATA[概述参考：个人博客 写在前面个人爱好，对于新旧知识喜欢通过整理笔记来记录或梳理知识点(主要还是脑子不太好使记不住)，之前一直使用笔记软件记录，从 [oneNote] 转到 [为知笔记] 又转到 [有道云笔记]，不是很喜欢他们的 [markdown] 编辑器，而且 [为知笔记] 还曾经把我的几篇笔记给搞丢了，最后想了想还是搭个自己的博客比较靠谱，既可以打造自己的风格，还能分享交流知识，一举多得。自己的博客还在搭建中，所以暂时使用 [GitHub Pages] 托管。 版本首先将我搭建博客时所使用的环境或者插件的版本摆在前面，以供参考（可略过） 12345678910- node v8.11.3- git v2.17.0.windows.1- hexo v3.7.1- hexo-cli v1.1.0- NexT v6.4.0 参考其实利用 [Hexo] 脚手架工具搭建博客相对简单，我们不需要做任何的编码工作，只需要按照自己的需求进行相应的配置，并托管到 [GitHub Pages] 上，至于配置的方法，个人建议参照官方的文档，不仅有详细的说明，还有技术交流社区帮你解决可能遇到的各种错误，我在搭建中参考的官方文档如下，列做参考 NexT Hexo 环境Node 安装 [Hexo] 需要 [Node] 环境，所以首先要安装 [Node] 到 [Node.js] 中文 官网 下载对应操作系统的安装文件，执行安装文件进行安装，持续下一步即可，注意，安装路径可以自定义，但是路径中不要出现中文，安装完成后，在 [cmd] 中使用以下指令查看 [Node] 版本，正确显示版本号则安装成功（因为我们还没有安装 [Git]，所以暂时使用 [cmd] 验证） 12# 查看 Node 版本node -v Git 整个搭建我们使用 [Git] 命令行终端，使用 [GitHub Pages] 托管也需要使用 [Git] 提交，所以要安装 [Git] 安装方法类似 [node] 安装，官网下载，持续下一步即可，同样注意安装路径中不要出现中文，安装完成后，在你桌面右键，这时出现的菜单中会多出两个选项，[Git GUI Here] 和 [Git Bash Here]，这是两种使用 [Git] 的方式，当然我们选择 [Git Bash Here]，点击后在弹出的 [Git] 终端中输入以下指令，查看你安装的 [Git] 版本，当然我们也可以在在这里查看之前安装的 [Node] 的版本 12345# 查看 Git 版本git version# 查看 Node 版本node -v Hexo上述环境安装完成后，[Hexo] 所需要的环境以准备完毕，下面可以安装 [Hexo] 了 在任意一个文件夹下（桌面即可），右键选择 [Git Bash Here]，使用以下命令全局安装 [Hexo] 12345# 全局安装 [Hexo]npm install hexo-cli -g# 或者npm install -g hexo-cli 至此，搭建博客的环境需求已安装完毕，接下来就可以愉快的建站了 本地站点在将博客部署到服务器上之前，我们首先要在本地搭建好站点 首先，创建本地站点存放的文件目录 123# 新建文件夹，用来存放本地站点，路径自定义，不要使用中文# 举个例子，为了演示，我在桌面新建了一个博客项目，所以我的博客根路径是 [C:\Users\QHT\Desktop\blog]# 如果你想在 E 盘根目录下创建 blog 项目也是完全可以，这样你的博客根目录就是 [E:\blog] 点开你所创建的文件夹，右键选择 [Git Bash Here]，使用以下命令初始化站点，并下载或更新相应的包 12345# 初始化站点hexo init# 下载相应的资源包npm install 编译生成静态文件 12345# 生成静态文件hexo generate# 简写hexo g 在本地服务器预览：启动服务器，将主机（域名+端口号）复制到浏览器地址栏中进行预览 12345# 启动服务器hexo server# 简写hexo s 上面编译生成静态文件和开启本地服务可合并成一步，可单独执行以上两步，或者直接执行这一步 12# 编译并开启服务器(顺序不要写反)hexo s -g 看到这个界面，是不是有点小激动~ 部署当然仅仅创建本地站点无法让别人来访问（不能愉快的和小伙伴那啥），所以我们需要把本地站点部署到服务器上 注册 GitHub[GitHub] 这里就不介绍了，全球最大的 JI 友交流社区，还没有 Gay 友通行证的同学抓紧时间了，Gay 网传送门，注册邮箱一定要正确，不然收不到验证邮件很麻烦，用户名建议自己名字全拼或者简拼，万一哪天就火了呢 配置 SSH[GitHub] 是一个分布式的版本控制系统，可以用来托管我们的代码，它相当于一个远程仓库，那如何将远程仓库和我们的电脑关联起来呢？通过配置 SSH 首先在我们电脑任意文件夹下（桌面即可）右键，选择 [Git Bash Here]，输入以下指令 12# 配置 SSH 私钥ssh-keygen 输入以上指令后，命令行会提示你秘钥的路径等信息（记住这个路径），对于所有的提示全部回车选择默认即可，配置完成后，在它默认的文件夹下会生成两个文件，[id_rsa] 和 [id_rsa.pub]，前者是 [SSH私钥]，后者是 [SSH公钥] 执行以下命令将 [SSH公钥] 复制到剪切板中 12# 复制公钥clip &lt; ~/.ssh/id_rsa.pub 打开你的 [GitHub]，点击右上角你的头像，下拉菜单中选择 [Settings] 左侧菜单栏中选择 [SSH and GPG keys]，右侧点击绿色 [New SSH key] 在弹出的窗口中，[title] 栏输入名称，可自定义，建议写你操作的操作系统，比如 windows；[key] 栏内 Ctrl + c 将公钥粘贴进去，完成后点击 [Add SSH key] 创建远程博客仓库在 [GitHub] 上创建一个远程仓库用来部署我们的本地博客仓库，具体步骤如下 点击右上角头像，下拉菜单中选择 [Your repositories] 页面跳转后，点击右上角绿色的 [New] 按钮新建仓库 在设置页面中，填入相应的仓库信息 创建完成后，点击你刚刚创建的仓库，将仓库地址复制下来，具体步骤如图 安装部署插件因为我们要把本地站点推送到 [GitHub] 服务器上，所以要先安装相关的插件 回到 [Git] 终端，在本地站点根路径下，执行以下命令 12# 安装插件npm install hexo-deployer-git --save 本地站点与远程仓库关联 找到你创建本地站点的目录，选择根目录下的 [_config.yml] 文件，用记事本打开 Ctrl + f 定位到 [deploy]，按照以下格式设置 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 首先强调格式，[deploy] 没有缩进，[type]、[repo] 等四个属性名缩进两个空格，属性值与属性名之间缩进一个空格，要严格按照格式配置，不然会出错； [type] 代表部署类型，我们使用 [git] 部署，所以这里填 git；[repo] 是你远程仓库的地址，就是我们在 [创建远程博客仓库] 这一步中复制的地址（如果这之间你进行了其他的复制操作，请回到 [GitHub] 中再复制一遍）；[branch] 是分支结构，我们填 master 即可；[message] 可以不填，给个样例（填你自己的仓库名，填我的没用） 编译部署 每次部署前，都要执行这一步操作，以清除缓存的静态文件 12# 清除hexo clean 编译项目，生成静态文件 12# 编译hexo g 部署到服务器上 12345# 部署hexo deploy# 简写hexo d 以上两步可以合并为一步，可单独执行上面两步，也可直接执行这一步 12345# 合并写法hexo g -d# 或者hexo d -g 预览执行完上述所有的部署操作后，我们的本地站点便部署到了服务器上，这代表我们可以通过域名来访问我们的博客 在地址栏中输入你博客的域名，格式如下，将 username 换成你 [GitHub] 的用户名 1https://username.github.io 至此，博客已经搭建完毕，如果没有审美、绑定域名者其他功能的要求，恭喜你，工作结束，学会怎么发表文章就行了 本地测试在进行接下来的一系列改动之前，我们先来介绍一下怎么在本地对所做的改动进行调试，因为我们一次可能做很多的改动，每个小改动后都要看看改动的效果有没有被实现，那不可能我们每次都把代码部署到服务器上，然后在服务器上观察效果，这样不仅将没有意义的代码推到了服务器上，还会消耗很多时间，所以我们应尽量的现在本地服务器中调试，确定没什么问题后，再部署到 [GitHub] 服务器上，大概有两种方法 编译静态文件，开启本地服务器测试效果 12345678# 编译成静态文件hexo g# 开启本地服务器hexo s# 合并写法，注意顺序，不要写法hexo s -g 在浏览器中通过 localhost:4000 进行访问，观察效果 在调试模式下，开启本地服务器测试效果 12# 在调试模式下开启本地服务器hexo s --debug 还是一样，在浏览器中通过 localhost:4000 进行访问，观察效果；在这种模式下，终端会记录编译以及我们执行各种操作时的调试信息并记录到 [debug.log] 中，我们可以根据调试信息找出找出错误 写作三种布局[Hexo] 有三种内置的布局模式，分别是 post (默认)、draft、page，三种布局代表了创建文章的三种不同的模式，以及文件存储的不同路径 布局 文章模式 存放路径 post(默认) 要发表的文章 source/_posts draft 草稿 source/_drafts page 单独的页面 source 自定义 ———– source/_posts 关于自定义布局这里不讲，很少会用到吧，这里内置的三种布局模式的创建方法及区别 创建文章无论哪种布局，创建指令都是一样的，参数不同 12# 创建文章hexo new [layout] &lt;title&gt; layout 代表布局模式，如果省略的话默认是 post；title 是文章的标题，自定义，这还需要强调的一点是，[Hexo] 中文章格式是 [.md] 的 [markdown] 文档，关于 [markdown] 文档的介绍、语法及使用技巧，会在另外一篇文章中介绍，以供新手参考，这里暂时不提 发表文章如果我们创建的文章，编辑完以后要直接发表，那么我们可以直接使用 post 布局模式创建文章，前面也强调过，这种方法创建的文章都在 [source/_posts] 目录下 12345678# 创建 post 布局文章hexo new post &lt;title&gt;# 可以省略 post 参数，因为默认就是 post 布局hexo new &lt;title&gt;# 样例hexo new "test" 以样例为例，如果执行了 hexo new test 这条语句，[source/_posts] 文件夹下就会出现一个 [test.md] 文档，这就是我们所创建的文档 我们打开这个 [test.md] 这个文档 文档上方有一个配置区域，叫做 [Front-matter]，用于指定当前文件的一些配置信息，默认给出了上图中三项 title 表示改文章的题目，默认是文件名，当然你可以改成其他的名字，但如果这里 title 没有指定值，那么在博客中显示的标题是 [未命名]；date 表示文章被创建的时间，默认即创建文章时的系统时间，tags 表示文章的标签，这个后面再提，暂时不用，不理他或者删掉 我们在文章中写一些内容，比如 “谢谢你长得那么好看还看我的博客~”，Ctrl + s 保存并退出 本地测试 12# 编译并开启本地服务hexo s -g 可以看到，本地站点中已经添加了我们的文章，以上便是，发表文章的基本流程 草稿无论我们是在本地测试还是部署到服务器，[source/_posts] 这个文件夹中的内容都会被编译，那么如我们有些文章还没有写完，不适合被发布到博客上，这时我们就要用到另一种布局 draft 了，即 [草稿] 创建 [草稿] 布局的文章 12# 使用 draft 布局参数hexo new draft "tmp" 前面提到过，draft 布局的文章会被保存在 [source/_drafts] 文件夹下，我们打开这个文件夹中刚刚创建的文件 [草稿] 文件中也有 [Front-matter] 区域，包含了标题、标签信息，相比 post 布局的文章少了 date 属性，这是合理的，因为草稿文件不会被编译发布，所以创建时间是无意义的，可以根据实际需要自己配置，保存并退出，我们在本地测试一下，看看这篇 [草稿] 有没有被发布 本地测试（这里提醒一下，如果还处于上一次的测试状态中，可以先 Ctrl + c 结束） 12# 编译并开启本地服务hexo s -g 并没有我们创建的 [草稿] 文件 [tmp] 所以，我们利用 [草稿] 布局来创建一些暂时不需要传到服务器上的文件，如果需要把它当做发表文章时，我们可以使用命令将它移入 [source/_posts] 目录下 12# 移动文件，举例mv source/_drafts/tmp.md source/_posts 当然，我们也可以将 [source/_posts] 目录下暂时不发表的文章，在编译前先移入 [source/_drafts] 目录下 更好的方法？如果我们不想通过命令的方式来创建一片文章，我们可以现在本地任何一个地方创建 [.md] 文件，编辑结束后，如果需要发布，就把他移入 [blog/source/_posts] 目录下，这样一来，省去了文章在 [source/_drafts] 和 [source/_posts] 之间来回一定的麻烦，而且这可能也是最接近我们日常习惯的方法，但是使用这个方法有一点一定要注意，就是要 手动配置 [Front-matter]，因为是我们自己创建的文件，所以 [Hexo] 不会帮我们填入初始的 [Fromt-matter] 配置，但这又是我们发表文章必须的（至少 title 属性是必须的，因为如果 title 没有配置，那么博客中文章的名字将会是 [未命名]，当然，除非你想这么命名） 配置 [Front-matter] 区 1要配置的属性很好写，重点是怎么开辟这块 [Front-matter] 区域，方法是在 [.md] 文档的最上方打三个连续的中划线 &quot;---&quot;（不包括引号），注意一定要是最上方，如果写在其他地方不仅设置不会生效，发布文章后还会出现未知的错误 接下来把它移入到我们博客目录的 [source/_posts] 目录下，进行本地测试，结果如下 关于第三种布局方式 page ，会在后面 [主题配置] 中讲到，这里暂时不提；至此，博客的搭建、部署、文章发表的讲解已全部结束，如果你满足于博客默认主体的外观，那么可以跳过下一节 [更换主题] 的讲解 更换主题[Hexo] 内置的主题风格算是简约明了，但肯定满足不了骚年们 “花里胡哨” 的想法，所以下面讲解一下更换主题的方法 整体思路[Hexo] 社区中有很多开源的好看的主题，安装方法大同小异，但是每一个主题自己的配置方法有所不同，所以不可能每一套主题都是一个公式进行配置，但可以参考以下整体的配置思路进行配置 1234- 思路 - 下载主题 - 应用主题 - 配置主题 下载主题 我们打开 主题社区 选择一个主题，点击进入博客页面 进入后一般是开发者使用这个主题的博客模板，这个我们不用关心，我们找到作者的 [GitHub] 链接 进入作者 [GitHub] 主页，找到对应主题的仓库 点击进入此仓库，复制仓库地址 回到 [Git] 终端中，把仓库克隆到本地博客目录下 [themes] 目录下 12345# 如果 [Git] 当前的路径在你博客的根路径下，执行下面命令git clone &lt;repository&gt; themes/&lt;filename&gt;# &lt;repository&gt; 主题仓库地址# &lt;filename&gt; 是主题保存在本地的文件名，一般取为主题名称 12# 也可以先进入 [themes] 目录下，或者你的 [Git] 当前路径就在 [themes] 路径下，执行下面路径git clone &lt;repository&gt; &lt;filename&gt; 操作完成后，博客根目录下的 [themes] 会多出一个以 &lt;filename&gt; 命名的存放主题文件的路径 应用主题 打开博客根目录下的 [_config.yml] 文件，Ctrl + f 定位到 theme，将名称修改为 [themes] 路径下，你想应用的主题的 &lt;filename&gt;，还是一定要注意之前提到的格式的问题 Ctrl + s 保存退出后，重新编译并打开本地服务器测试 12# 本地测试hexo s -g 配置主题 每一个主题都有各自不同风格和功能，配置方法也就不尽相同，每个主题 [GitHub] 仓库中都有一份 [README.md] 文档，这份文档介绍了该主题的配置方法，可参考该文档进行配置 使用 NexT介绍了更换主题的整体思路，可能大家还是不会自己去配置，这里以我个人博客使用的 [NexT] 主题为例，带大家一步一步的配置一下，熟悉了这个主题的配置，其他主题配置起来也就得心应手了 两个配置文件再开始之前，先强调一下下面要用到的两个配置文件，一个是博客根目录下的 [_config.yml] 文件，我们称为 [站点配置文件]；另一个是 [themes/next] 路径下的 [_config.yml] 文件，我们称为 [主题配置文件]；两者的文件名都一样，但是在不同的目录下，需要配置的内容也不同，后面的阅读中一定要注意是在哪个配置文件中进行配置 下载主题123# 下载 NexT 主题到本地站点# 保证 [Git] 当前路径在你的博客的根路径下，执行以下命令git clone https://github.com/theme-next/hexo-theme-next.git themes/next 下载完成后，[themes] 文件夹下会出现我们下载的主题 应用主题在 [站点配置文件] 中，Ctrl + f 定位到 theme 属性，将属性值修改为 next 验证主题12# 本地调试hexo s -g 这时再访问 localhost:4000，博客的主题已经变成了 [NexT] 主题的样子，应用成功 排版风格[NexT] 主题中内置了四种博客界面排版的风格，通过修改 [主题配置文件] 中的 scheme 属性来更换排版风格 本地测试，验证主题 现在博客的排版变成了这样样子，emmmm感觉比默认的要好看一点~ 站点描述观察你现在的博客，无论是博客的名称还是作者的名称，都不属于你，虽然这博客是你搭建的，但现在还不属于你，你需要将这些信息修改为与你相关。在 [站点配置文件] 中， Ctrl + f 定位到 site 属性，配置信息如下 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 keywords 搜索关键字 author 作者 language 网站使用的语言 timezone 网站时区，默认使用电脑的时区。 举例： 注意： keywords 作为网站搜索关键字，用作 SEO，后续会另写一篇文章介绍 SEO，这里暂时可以先不写 language 作为网站所采用的语言，这个设定是一定要注意，官网或者网上的很多其他文章给出的属性值时 zh-Hans，可能是因为版本不一样，有一些更新，官网的文旦还没有跟上，其实这个属性我们可以自己查看，在 [themes/next/languages] 目录下，找到你想设置的文件对应哪个文件名即可 timezone 是时区设置，默认跟随系统时间的时区，不填即可 最后在强调一下格式问题（嗯前面好像说过好多次了），属性名和属性值之间用 “: “（冒号加一个空格分开） 设置头像在 [主题配置文件中]，Ctrl + f 定位到 avatar 字段，修改相应的属性，给个样例 第三方服务既然是分享性质的博客，自然少不了 Gay 友们亲切的交流，[Hexo] 作为搭建博客的脚手架不提供像评论、搜索或者统计这样的服务，需要使用第三方服务，[NexT] 内置集成了许多实用的第三方服务，下面以 [不蒜子]，[来必力]，[Local Search] 为例介绍 不蒜子统计服务在 [主题配置文件] 中，Ctrl + f 定位到 busuanzi_count，将 enable 属性值改为 true 即可打开 [不蒜子] 统计服务，下面的三个值 total_visitors、total_views、post_views，分别代表 [站点总访客量]、[站点总阅读量]、[文章的阅读量]，默认值全部是 true ，即全部开启状态，保持默认即可 来必力评论服务 首先到 来必力官网 注册账号 注册成功后登录，选择顶部栏中的 [安装]，选择中间的 [免费] 版本即可，点击 [现在安装] 在弹出的界面中，输入相应的数据，比如博客名称你可以写 xxx&#39;blog，博客地址写你的 https://username.github.io，因为我已经安装过了，不会在弹出这个界面了，所以不能给你们截图了，但其实很好写，而且这里的设置在后台管理都可以修改，不要紧张哈~ 填写完成后就可以进入到后台管理界面了，点击左侧菜单栏中的 [代码管理]，右侧代码中第二行 data-uid 中的值复制 回到 [主题配置文件] 中，Ctrl + f 定位到 livere_uid 属性，将属性值修改为刚刚复制的值 本地测试，点开一篇文章，你就可以看到文章底部的评论区了（可能要加载一会哦~） Local Search 搜索服务在博客的根路径下，[Git] 终端中输入以下指令下载搜索服务插件 12# 下载搜索服务插件npm install hexo-generator-searchdb --save 在 [站点配置文件] 任意位置，添加以下配置： 12345search: path: search.xml field: post format: html limit: 10000 在 [主题配置文件] 中开启搜索服务 123# Local searchlocal_search: enable: true 重新编译测试 新建页在 [写作] 这一节中我们介绍过文章一共有三种内置的布局，[发布文章] post ，[草稿] draft，[单独的页面] page，前两个我们已经讲过了，接下我们讲一下关于 [单独页面] 的用法 [单独页面] 的意思就是开辟一个新的页面，这个页面是专门为了解决一个功能而诞生的，比如 [标签页]、[分类页]、[关于页]，他们的添加方法基本相同，下面以这三种页面为例，介绍添加方法 在博客根目录下使用 [Git] 终端，输入以下指令 12345678# 新建 [标签页]hexo new page tags# 新建 [分类与]hexo new page categories# 新建 [关于页]hexo new page about 这时再 [source] 路径下就会多出三个我们新建的文件夹 每个文件夹中都有一个 [index.md] 文件，这个文件就是最终要显示在我们博客中的一个单独的页 配置 [index.md] 文件夹 初始配置是这样的，只有页面的名称和创建时间 我们给页面添加类型描述，如果希望当前页面不被评论的话，还可以添加 comments 设置 同理，可配置 [分类] 和 [关于] 页面 修改 [主题配置文件] 新建这些页面以后，我们可以把页面的添加到左侧的菜单栏中显示，在 [主题配置文件] 中，定位到 menu，将下面属性中对应的 tags、categories、about 前面的 ’#‘ 去掉以打开注释，保存退出，进行本地测试 至此，这三个页面就添加成功了，但是你一定会点进去看一下的，看了以后发现，除了标题以外好像什么东西也没有，比如我们点进 [标签页] 中 显示，暂无标签，那我们该怎么给这些页面添加内容呢？ 对于 [关于页] 来说，直接在 [source/about] 路径下的 [index.md] 文件中，添加你想要展示的内容，比如说自我介绍，即可显示在博客中；而对于 [标签页] 和 [分类页] 来说，我们要在 [发布文章] 中的 [Front-matter] 区域添加tags 和 categories 属性，这里添加的属性值将会作为 [标签页] 和 [分类页] 内容的依据 比如，我们在[Hexo] 自带的 [hello-world] 文章中添加这些设置 进行本地测试 两个页面中都有了我们设置的内容 添加社交链接把你的一些其他网站的链接添加到博客中，有助于大家更多的了解你，也能分享更多的知识方法很简单 在 [主题配置文件] 中，Ctrl + f 定位到 social 属性，将前面的 # 去掉以取消注释打开此功能，在下面的链接选项中，把你想要添加的社交链接前面的 # 去掉，然后将后面 url 中 yourname 部分替换成你该社交链接相应的用户名，以 GitHub 为例 这时博客中，就出现了对应的链接图标，点击图标即可访问链接 至此，[Hexo] 使用 [NexT] 主题的基本介绍就全部完成了，除了文章中介绍的功能外，还有很多功能大家可以去探索，参考 官方文档 或者其他的博文 部署到服务器最后，别忘了你刚刚所做的修改都只是针对本地站点，还没有把它部署到服务器上，记得把它部署上去，然后通过你的域名 https://yourname.github.io 访问哦，部署方法文章开始便讲过了，这里给个提示 1234567# 清除hexo clean# 编译部署hexo g -d# 合并写法hexo clean &amp;&amp; g -d 绑定个人域名如果只能通过 https://yourname.github.io 形式的域名进行访问，总感觉不够酷，毕竟域名中除了自己的名字外还带了其他的名字，如果你想通过你心怡的专属的域名访问，那么你就需要进行接下来的绑定域名的操作了 说明这里要提前说明的是，我个人的域名是在一年前买的，当时年级小不懂事，没有好好对比就选择了 [Godaddy] 平台，虽然入手叫便宜，但是续费的价钱比一般平台都要高，而且最可气的是，[Godaddy] 平台的隐私保护较差，如果不买他的隐私保护，你的个人信息将会暴露在网上，有可能收到各种各样的垃圾邮件或者短信，意思就是强制你买它的隐私保护套餐，这样一来，和其他平台相比就不是很划算了；现在想想也是悔不当初，最近已经打算把域名转到 [阿里云] 了，但因为博客搭建绑定域名时还在 [Godaddy]，所以下面的讲解就以此为参考，如果你手里有现成的 [Godaddy]，可以参考接下来的介绍，如果你正打算买域名来绑定，那建议选择 [阿里云] 或者 [Namesilo] 注册域名参考上述说明 域名解析并绑定链接推荐在 DNSPod 进行解析，速度较快 首先进入，DNSPod 官网，登录或者注册 成功登录后，在菜单栏选择 [域名解析] 并进入 点击页面中绿色的 [添加域名] 按钮，并填入你的域名 添加成功后会有这条域名的记录，点击进入 在进入的页面中，点击绿色 [添加记录] 按钮 主机记录：建议填 ‘@’ 记录值：在 cmd 中 ping 一下你的网站的网址（https://yourname.github.io），将 ip 值填入此 保存记录，返回到 [Godaddy] 中进入 [DNS] 设置 更改域名服务器 在域名服务器修改页面，按照下图修改，保存 在本地博客根目录下的 [source] 路径下，新建一个 [CNAME] 文件，没有后缀，用记事本打开，写一行内容，即你的域名 部署一下 12hexo cleanhexo g -d 如果域名正常解析的话，这时你就可以通过，你的域名愉快的访问你的博客了]]></content>
      <categories>
        <category>site</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
