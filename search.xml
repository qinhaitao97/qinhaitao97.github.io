<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F12%2F01_%E5%8F%98%E9%87%8F%26%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%26%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[[TOC] 变量声明、赋值、初始化声明，JS 中的变量用 ‘var’ 关键词声明 1var a; 赋值，给变量赋予一定的值 123a = 1;b = 'hello';c = true; 初始化，在声明变量的同时，赋予变量一定的值 1var a = 1; 单一 var 模式，减少 var 的使用，对于一组变量声明，应当使用一个 var 进行声明 123456789101112// badvar a;var b;var c;// acceptablevar a, b, c;// good for developmentvar a, b, c; 命名命名规则 区分大小写 不允许使用 JavaScript 中的保留字，关键字 可以包含英文字母、_、$、数字，但不能以数字开头 123456789101112// 区分大小写, a 和 A 是两个变量var a;var A;// 不允许使用保留字、关键字，var 是声明关键字，不允许被当做变量使用var var = 1;// 可以包含英文字母、_、$、数字，但是不能以数字开头var a1 = 1; // 正确var _a = 1; // 正确var $a = 1; // 正确var 1a = 1; // 错误 数据类型原始值原始值采用 栈存储（stack），复制时生成副本，共有 6 中原始值类型： 123456- Number // 数字- String // 字符串- Boolean // 布尔- Undefined // 未定义- Null // 不存在- Symbol(ES6) // 引用值引用值采用 堆存储（heap），复制时不生成副本，采用引用方式，常见的引用类型数据有： 1234- Array // 数组- Object // 对象- function // 方法- RegExp // 正则 运算运算符数学运算符1234+、-、*、/、%、=、()、++、--、+=、-=、*=、/=、%=- 其中 &apos;+&apos; 运算符除了有数学运算的功能，还有字符串连接的功能- 任何数据类型 + 字符串，结果都是字符串 比较运算符123&gt;、&lt;、==、===、&gt;=、&lt;=、!=- &apos;===&apos;：绝对等于 逻辑运算符12345&amp;&amp;、||、！- &amp;&amp;：自左向右依次检查每一个表达式的运算结果的布尔值，若为真，则继续向后检查，若为假则停止检查，直到整个 与运算表达式结束；返回结果为停止检查时，当前表达式的运算结果- ||：自左向右依次检查每一个表达式的运算结果的布尔值，若为假，则继续向后检查，若为真则停止检查，直到整个 与运算表达式结束；返回结果为停止检查时，当前表达式的运算结果- !： 将表达式的运算结果转换成布尔值再取反，值为true或false 12345678910111213141516171819202122// 练习var a = 1 &amp;&amp; 2 + 3；// a = 5;var a = 0 &amp;&amp; 2 + 3;// a = 0;var a = 1 || 2 + 3;// a = 1;var a = 0 || 2 + 3;// a = 5;var a = !1 + 1;// a = 1;var a = !0 + 1;// a = 2;var a = !(1 + 1)// a = false;var a = !0// a = true;// 应用data &amp;&amp; fn(data)e = e || window.event 小数运算精度小数运算存在精度问题 12345678910111213141516171819202122// 加法 =====================// 0.1 + 0.2 = 0.30000000000000004// 0.7 + 0.1 = 0.7999999999999999// 0.2 + 0.4 = 0.6000000000000001// 2.22 + 0.1 = 2.3200000000000003 // 减法 =====================// 1.5 - 1.2 = 0.30000000000000004// 0.3 - 0.2 = 0.09999999999999998 // 乘法 =====================// 19.9 * 100 = 1989.9999999999998// 19.9 * 10 * 10 = 1990// 1306377.64 * 100 = 130637763.99999999// 1306377.64 * 10 * 10 = 130637763.99999999// 0.7 * 180 = 125.99999999999999// 9.7 * 100 = 969.9999999999999// 39.7 * 100 = 3970.0000000000005 // 除法 =====================// 0.3 / 0.1 = 2.9999999999999996// 0.69 / 10 = 0.06899999999999999 原因 JavaScript 中的数字采用 IEEE 754 的64为双精度标准，第 0 位表示符号位，1~11 位表示指数为，12~63 位表示小数位，符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度，IEEE 754规定，有效数字第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript提供的有效数字最长为53个二进制位 以 0.1 + 0.2 为例，0.1 和 0.2 在被转换成二进制时，其浮点数用二进制表达是无穷的 120.1 -&gt; 0.0001100110011001...(无限)0.2 -&gt; 0.0011001100110011...(无限) IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持 53 位二进制位，所以两者相加之后得到二进制为 10.0100110011001100110011001100110011001100110011001100 因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了 0.30000000000000004。所以在进行算术计算时会产生误差，详细参考 取整向上取整 1Math.ceil() 向下取整 1Math.floor() 随机数生成一个 (0, 1) 之间的随机数 1Math.random() 练习 随机生成 (0, 100) 之间的整数 1Math.floor(Math.random() * 100); 生成 [min, max] 之间的随机数 123Math.floor(Math.random() * (max - min + 1) + min)parseInt(Math.random() * (max - min + 1) + min, 10) 处理位数可以处理小数点前后 16 为的数据]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
